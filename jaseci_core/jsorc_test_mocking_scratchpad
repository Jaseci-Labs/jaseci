from jaseci.jsorc.jsorc import JsOrc
from jaseci.utils.test_core import CoreTest
from unittest.mock import MagicMock, patch, Mock
from kubernetes import config as kubernetes_config, client
from jaseci.extens.svc.kube_svc import KubeService
from jaseci.extens.svc.elastic_svc import Elastic
from jaseci.jsorc.jsorc_settings import JsOrcSettings
from .fixture.elastic_resources import ELASTIC_RESOURCES
from urllib3.response import HTTPResponse


def aggregate_k8s_resources(mocked):
    """Aggregate k8s resources from multiple mocked calls to kube"""
    resources = {}
    call_args_list = mocked.call_args_list
    for call_args in call_args_list:
        args, _ = call_args
        # arg1: kind, arg2: name
        kind = args[0]
        name = args[1]
        if kind not in resources:
            resources[kind] = []
        # The resource name for Namespace is different from run to run
        if kind != "Namespace":
            resources[kind].append(name)

    return resources


class MockKubeTest(CoreTest):
    """Custom test class that mocks methods from the kubernetes library"""

    @patch.object(client.ApiClient, "call_api")
    @patch.object(kubernetes_config, "load_incluster_config")
    def setUp(self, mock_config, mock_call_api):
        super().setUp()
        JsOrcSettings.KUBE_CONFIG["enabled"] = True
        self.kube = JsOrc.svc("kube")

        # Mock the various classes and methods in the kubernetes library
        # Mock CoreV1Api
        # self.mock_core_v1_api = MagicMock(spec=client.CoreV1Api)
        # self.mock_core_v1_api.create_namespace.return_value = (
        #     "core_v1_api.create_namespace"
        # )


class JsOrcTest(MockKubeTest):

    """Unit test for JsOrc"""

    def setUp(self):
        # Use memory_hook instead of redis hook so the tests do notr require redis
        # Swap the priority order of two
        # JsOrc._repositories["hook"] = {
        #     0: JsOrc._repositories["hook"][1],
        #     1: JsOrc._repositories["hook"][0],
        # }
        super().setUp()
        # read_apis = {
        #     "core": ["read_namespace", "read_namespaced_service"],
        #     "api_ext": ["read_custom_resource_definition"],
        #     "auth": ["read_cluster_role"],
        # }
        # self.mocked_clients = {
        #     "core": "CoreV1Api",
        #     "api": "AppsV1Api",
        #     "api_ext": "ApiextensionsV1Api",
        #     "auth": "RbacAuthorizationV1Api",
        #     "reg_api": "AdmissionregistrationV1Api",
        #     "custom": "CustomObjectsApi",
        # }
        # for client_name, module_name in self.mocked_clients.items():
        #     self.mocked_clients[client_name] = MagicMock(
        #         f"kubernets.client.{module_name}", autospec=True
        #     ).return_value

        # for client_name, apis in read_apis.items():
        #     for api in apis:
        #         print(f"mocking {client_name} {api}")
        #         getattr(self.mocked_clients[client_name], api).return_value = Mock()

        # for client_name, mocked in self.mocked_clients.items():
        #     print(f"updating {client_name}")
        #     self.kube.update_client(client_name, mocked)

        # mocked_core = MagicMock(
        #     "kubernetes.client.CoreV1Api", autospec=True
        # ).return_value

        # for read_api in read_apis["core"]:
        #     x = getattr(mocked_core, read_api)
        #     x.return_value = Mock()
        #     setattr(mocked_core, read_api, x)

        # # mocked_core.read_namespace.return_value = Mock()
        # self.kube.update_client("core", mocked_core)

        # self.mocked_api_ext = MagicMock(
        #     "kubernetes.client.ApiextensionsV1Api", autospec=True
        # ).return_value
        # for read_api in read_apis["api_ext"]:
        #     x = getattr(self.mocked_api_ext, read_api)
        #     x.return_value = Mock()
        #     setattr(self.mocked_api_ext, read_api, x)

        # #        self.mocked_api_ext.read_custom_resource_definition.return_value = Mock()
        # self.kube.update_client("api_ext", self.mocked_api_ext)

    # @patch(
    #     "kubernetes.client.CoreV1Api",
    #     return_value=Mock(create_namespace=Mock(return_value={"token": b"YWJjMTIz"})),
    # )
    # @patch.object(ApiextensionsV1Api, "read_custom_resource_definition")
    # @patch.object(CoreV1Api, "read_namespace")
    # @patch(
    #     "kubernetes.client.CoreV1Api.read_namespace",
    #     return_value=Mock(),
    # )
    # @patch(
    #     "kubernetes.client.ApiextensionsV1Api.read_custom_resource_definition",
    #     return_value=Mock(),
    # )
    # @patch.object(self.kube.core, "read_namespace")
    # j@patch.object(client.CoreV1Api, "create_namespaced_service")

    def test_jsorc_elastic_create(self):
        self.call(
            self.smast,
            [
                "config_update",
                {"name": "ELASTIC_CONFIG", "field_key": "enabled", "field_value": True},
            ],
        )
        with patch.object(self.kube, "read") as mock_read, patch.object(
            self.kube, "patch"
        ) as mock_patch, patch.object(self.kube, "create") as mock_create:
            # resource do not exist
            mocked_response = HTTPResponse(status=404)
            mock_read.return_value = mocked_response
            mock_patch.return_value = Mock()
            mock_create.return_value = Mock()

            JsOrc.svc_reset("elastic")

            # Mocking elastic health check to show its up and running
            with patch("jaseci.extens.svc.elastic_svc.Elastic._get") as mocked_get:
                mocked_get.return_value = {"timed_out": False}
                JsOrc.regenerate()

            read_resources = aggregate_k8s_resources(mock_read)
            assert read_resources == ELASTIC_RESOURCES

            create_resources = aggregate_k8s_resources(mock_create)
            assert create_resources == ELASTIC_RESOURCES

            # No resources should be patched
            assert not mock_patch.called

    def test_jsorc_elastic_patch(self):
        self.call(
            self.smast,
            [
                "config_update",
                {"name": "ELASTIC_CONFIG", "field_key": "enabled", "field_value": True},
            ],
        )
        with patch.object(self.kube, "read") as mock_read, patch.object(
            self.kube, "patch"
        ) as mock_patch, patch.object(self.kube, "create") as mock_create:
            mock_read.return_value = Mock()
            mock_patch.return_value = Mock()
            mock_create.return_value = Mock()

            JsOrc.svc_reset("elastic")

            # Mocking elastic health check to show its up and running
            with patch("jaseci.extens.svc.elastic_svc.Elastic._get") as mocked_get:
                mocked_get.return_value = {"timed_out": False}
                JsOrc.regenerate()

            read_resources = aggregate_k8s_resources(mock_read)
            assert read_resources == ELASTIC_RESOURCES

            patch_resources = aggregate_k8s_resources(mock_patch)
            # No need to patch Namespace
            del ELASTIC_RESOURCES["Namespace"]

            assert patch_resources == ELASTIC_RESOURCES

            # No resources should be created
            assert not mock_create.called
