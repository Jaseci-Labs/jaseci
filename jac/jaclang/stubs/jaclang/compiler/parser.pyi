import jaclang.compiler.absyntree as ast
from _typeshed import Incomplete
from jaclang.compiler import jac_lark as jl
from jaclang.compiler.constant import EdgeDir as EdgeDir
from jaclang.compiler.passes.ir_pass import Pass as Pass
from jaclang.vendor.lark import (
    Lark as Lark,
    Transformer as Transformer,
    Tree as Tree,
    logger as logger,
)
from typing import Callable, TypeAlias

class JacParser(Pass):
    dev_mode: bool
    source: Incomplete
    mod_path: Incomplete
    node_list: Incomplete
    def __init__(self, input_ir: ast.JacSource) -> None: ...
    def transform(self, ir: ast.AstNode) -> ast.Module: ...
    @staticmethod
    def proc_comment(token: jl.Token, mod: ast.AstNode) -> ast.CommentToken: ...
    def error_callback(self, e: jl.UnexpectedInput) -> bool: ...
    @staticmethod
    def parse(
        ir: str, on_error: Callable[[jl.UnexpectedInput], bool]
    ) -> tuple[jl.Tree[jl.Tree[str]], list[jl.Token]]: ...
    @staticmethod
    def make_dev() -> None: ...
    comment_cache: list[jl.Token]
    parser: Incomplete
    JacTransformer: TypeAlias

    class TreeToAST(JacTransformer):
        parse_ref: Incomplete
        terminals: Incomplete
        def __init__(self, parser: JacParser, *args: bool, **kwargs: bool) -> None: ...
        def ice(self) -> Exception: ...
        def nu(self, node: ast.T) -> ast.T: ...
        def start(self, kid: list[ast.Module]) -> ast.Module: ...
        def module(
            self, kid: list[ast.ElementStmt | ast.String | ast.EmptyToken]
        ) -> ast.Module: ...
        def element_with_doc(
            self, kid: list[ast.ElementStmt | ast.String]
        ) -> ast.ElementStmt: ...
        def element(self, kid: list[ast.AstNode]) -> ast.ElementStmt: ...
        def global_var(self, kid: list[ast.AstNode]) -> ast.GlobalVars: ...
        def access_tag(self, kid: list[ast.AstNode]) -> ast.SubTag[ast.Token]: ...
        def test(self, kid: list[ast.AstNode]) -> ast.Test: ...
        def free_code(self, kid: list[ast.AstNode]) -> ast.ModuleCode: ...
        def doc_tag(self, kid: list[ast.AstNode]) -> ast.String: ...
        def py_code_block(self, kid: list[ast.AstNode]) -> ast.PyInlineCode: ...
        def import_stmt(self, kid: list[ast.AstNode]) -> ast.Import: ...
        def from_path(self, kid: list[ast.AstNode]) -> ast.ModulePath: ...
        def include_stmt(self, kid: list[ast.AstNode]) -> ast.Import: ...
        def import_path(self, kid: list[ast.AstNode]) -> ast.ModulePath: ...
        def import_items(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.ModuleItem]: ...
        def import_item(self, kid: list[ast.AstNode]) -> ast.ModuleItem: ...
        def architype(
            self, kid: list[ast.AstNode]
        ) -> ast.ArchSpec | ast.ArchDef | ast.Enum | ast.EnumDef: ...
        def architype_decl(self, kid: list[ast.AstNode]) -> ast.ArchSpec: ...
        def architype_def(self, kid: list[ast.AstNode]) -> ast.ArchDef: ...
        def arch_type(self, kid: list[ast.AstNode]) -> ast.Token: ...
        def decorators(self, kid: list[ast.AstNode]) -> ast.SubNodeList[ast.Expr]: ...
        def inherited_archs(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.Expr]: ...
        def sub_name(self, kid: list[ast.AstNode]) -> ast.SubTag[ast.Name]: ...
        def named_ref(self, kid: list[ast.AstNode]) -> ast.NameAtom: ...
        def special_ref(self, kid: list[ast.AstNode]) -> ast.SpecialVarRef: ...
        def enum(self, kid: list[ast.AstNode]) -> ast.Enum | ast.EnumDef: ...
        def enum_decl(self, kid: list[ast.AstNode]) -> ast.Enum: ...
        def enum_def(self, kid: list[ast.AstNode]) -> ast.EnumDef: ...
        def enum_block(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.EnumBlockStmt]: ...
        def enum_stmt(self, kid: list[ast.AstNode]) -> ast.EnumBlockStmt: ...
        def ability(
            self, kid: list[ast.AstNode]
        ) -> ast.Ability | ast.AbilityDef | ast.FuncCall: ...
        def ability_decl(self, kid: list[ast.AstNode]) -> ast.Ability: ...
        def ability_def(self, kid: list[ast.AstNode]) -> ast.AbilityDef: ...
        def abstract_ability(self, kid: list[ast.AstNode]) -> ast.Ability: ...
        def genai_ability(self, kid: list[ast.AstNode]) -> ast.Ability: ...
        def event_clause(self, kid: list[ast.AstNode]) -> ast.EventSignature: ...
        def func_decl(self, kid: list[ast.AstNode]) -> ast.FuncSignature: ...
        def func_decl_params(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.ParamVar]: ...
        def param_var(self, kid: list[ast.AstNode]) -> ast.ParamVar: ...
        def member_block(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.ArchBlockStmt]: ...
        def member_stmt(self, kid: list[ast.AstNode]) -> ast.ArchBlockStmt: ...
        def has_stmt(self, kid: list[ast.AstNode]) -> ast.ArchHas: ...
        def has_assign_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.HasVar]: ...
        def typed_has_clause(self, kid: list[ast.AstNode]) -> ast.HasVar: ...
        def type_tag(self, kid: list[ast.AstNode]) -> ast.SubTag[ast.Expr]: ...
        def builtin_type(self, kid: list[ast.AstNode]) -> ast.Token: ...
        def code_block(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.CodeBlockStmt]: ...
        def statement(self, kid: list[ast.AstNode]) -> ast.CodeBlockStmt: ...
        def typed_ctx_block(self, kid: list[ast.AstNode]) -> ast.TypedCtxBlock: ...
        def if_stmt(self, kid: list[ast.AstNode]) -> ast.IfStmt: ...
        def elif_stmt(self, kid: list[ast.AstNode]) -> ast.ElseIf: ...
        def else_stmt(self, kid: list[ast.AstNode]) -> ast.ElseStmt: ...
        def try_stmt(self, kid: list[ast.AstNode]) -> ast.TryStmt: ...
        def except_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.Except]: ...
        def except_def(self, kid: list[ast.AstNode]) -> ast.Except: ...
        def finally_stmt(self, kid: list[ast.AstNode]) -> ast.FinallyStmt: ...
        def for_stmt(
            self, kid: list[ast.AstNode]
        ) -> ast.IterForStmt | ast.InForStmt: ...
        def while_stmt(self, kid: list[ast.AstNode]) -> ast.WhileStmt: ...
        def with_stmt(self, kid: list[ast.AstNode]) -> ast.WithStmt: ...
        def expr_as_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.ExprAsItem]: ...
        def expr_as(self, kid: list[ast.AstNode]) -> ast.ExprAsItem: ...
        def raise_stmt(self, kid: list[ast.AstNode]) -> ast.RaiseStmt: ...
        def assert_stmt(self, kid: list[ast.AstNode]) -> ast.AssertStmt: ...
        def check_stmt(self, kid: list[ast.AstNode]) -> ast.CheckStmt: ...
        def ctrl_stmt(self, kid: list[ast.AstNode]) -> ast.CtrlStmt: ...
        def delete_stmt(self, kid: list[ast.AstNode]) -> ast.DeleteStmt: ...
        def report_stmt(self, kid: list[ast.AstNode]) -> ast.ReportStmt: ...
        def return_stmt(self, kid: list[ast.AstNode]) -> ast.ReturnStmt: ...
        def walker_stmt(self, kid: list[ast.AstNode]) -> ast.CodeBlockStmt: ...
        def ignore_stmt(self, kid: list[ast.AstNode]) -> ast.IgnoreStmt: ...
        def visit_stmt(self, kid: list[ast.AstNode]) -> ast.VisitStmt: ...
        def revisit_stmt(self, kid: list[ast.AstNode]) -> ast.RevisitStmt: ...
        def disengage_stmt(self, kid: list[ast.AstNode]) -> ast.DisengageStmt: ...
        def global_ref(self, kid: list[ast.AstNode]) -> ast.GlobalStmt: ...
        def nonlocal_ref(self, kid: list[ast.AstNode]) -> ast.NonLocalStmt: ...
        def assignment(self, kid: list[ast.AstNode]) -> ast.Assignment: ...
        def expression(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def walrus_assign(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def binary_expr_unwind(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def lambda_expr(self, kid: list[ast.AstNode]) -> ast.LambdaExpr: ...
        def pipe(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def pipe_back(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def elvis_check(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def bitwise_or(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def bitwise_xor(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def bitwise_and(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def shift(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def logical_or(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def logical_and(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def logical_not(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def compare(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def cmp_op(self, kid: list[ast.AstNode]) -> ast.Token: ...
        def arithmetic(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def term(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def factor(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def power(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def connect(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def atomic_pipe(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def atomic_pipe_back(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def ds_spawn(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def unpack(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def ref(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def pipe_call(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def aug_op(self, kid: list[ast.AstNode]) -> ast.Token: ...
        def atomic_chain(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def atomic_call(self, kid: list[ast.AstNode]) -> ast.FuncCall: ...
        def index_slice(self, kid: list[ast.AstNode]) -> ast.IndexSlice: ...
        def atom(self, kid: list[ast.AstNode]) -> ast.Expr: ...
        def yield_expr(self, kid: list[ast.AstNode]) -> ast.YieldExpr: ...
        def atom_literal(self, kid: list[ast.AstNode]) -> ast.AtomExpr: ...
        def atom_collection(self, kid: list[ast.AstNode]) -> ast.AtomExpr: ...
        def multistring(self, kid: list[ast.AstNode]) -> ast.AtomExpr: ...
        def fstring(self, kid: list[ast.AstNode]) -> ast.FString: ...
        def fstr_parts(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.String | ast.ExprStmt]: ...
        def fstr_sq_parts(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.String | ast.ExprStmt]: ...
        def list_val(self, kid: list[ast.AstNode]) -> ast.ListVal: ...
        def tuple_val(self, kid: list[ast.AstNode]) -> ast.TupleVal: ...
        def set_val(self, kid: list[ast.AstNode]) -> ast.SetVal: ...
        def expr_list(self, kid: list[ast.AstNode]) -> ast.SubNodeList[ast.Expr]: ...
        def kw_expr_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.KWPair]: ...
        def kw_expr(self, kid: list[ast.AstNode]) -> ast.KWPair: ...
        def name_list(self, kid: list[ast.AstNode]) -> ast.SubNodeList[ast.Name]: ...
        def tuple_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.Expr | ast.KWPair]: ...
        def dict_val(self, kid: list[ast.AstNode]) -> ast.DictVal: ...
        def kv_pair(self, kid: list[ast.AstNode]) -> ast.KVPair: ...
        def list_compr(self, kid: list[ast.AstNode]) -> ast.ListCompr: ...
        def gen_compr(self, kid: list[ast.AstNode]) -> ast.GenCompr: ...
        def set_compr(self, kid: list[ast.AstNode]) -> ast.SetCompr: ...
        def dict_compr(self, kid: list[ast.AstNode]) -> ast.DictCompr: ...
        def inner_compr(self, kid: list[ast.AstNode]) -> ast.InnerCompr: ...
        def param_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.Expr | ast.KWPair]: ...
        def assignment_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.Assignment]: ...
        def arch_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def node_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def edge_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def walker_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def class_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def object_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def type_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def enum_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def ability_ref(self, kid: list[ast.AstNode]) -> ast.ArchRef: ...
        def arch_or_ability_chain(self, kid: list[ast.AstNode]) -> ast.ArchRefChain: ...
        def abil_to_arch_chain(self, kid: list[ast.AstNode]) -> ast.ArchRefChain: ...
        def arch_to_abil_chain(self, kid: list[ast.AstNode]) -> ast.ArchRefChain: ...
        def arch_to_enum_chain(self, kid: list[ast.AstNode]) -> ast.ArchRefChain: ...
        def edge_ref_chain(self, kid: list[ast.AstNode]) -> ast.EdgeRefTrailer: ...
        def edge_op_ref(self, kid: list[ast.AstNode]) -> ast.EdgeOpRef: ...
        def edge_to(self, kid: list[ast.AstNode]) -> ast.EdgeOpRef: ...
        def edge_from(self, kid: list[ast.AstNode]) -> ast.EdgeOpRef: ...
        def edge_any(self, kid: list[ast.AstNode]) -> ast.EdgeOpRef: ...
        def connect_op(self, kid: list[ast.AstNode]) -> ast.ConnectOp: ...
        def disconnect_op(self, kid: list[ast.AstNode]) -> ast.DisconnectOp: ...
        def connect_to(self, kid: list[ast.AstNode]) -> ast.ConnectOp: ...
        def connect_from(self, kid: list[ast.AstNode]) -> ast.ConnectOp: ...
        def connect_any(self, kid: list[ast.AstNode]) -> ast.ConnectOp: ...
        def filter_compr(self, kid: list[ast.AstNode]) -> ast.FilterCompr: ...
        def filter_compare_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.CompareExpr]: ...
        def typed_filter_compare_list(
            self, kid: list[ast.AstNode]
        ) -> ast.FilterCompr: ...
        def filter_compare_item(self, kid: list[ast.AstNode]) -> ast.CompareExpr: ...
        def assign_compr(self, kid: list[ast.AstNode]) -> ast.AssignCompr: ...
        def match_stmt(self, kid: list[ast.AstNode]) -> ast.MatchStmt: ...
        def match_case_block(self, kid: list[ast.AstNode]) -> ast.MatchCase: ...
        def pattern_seq(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def or_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def as_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def literal_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def singleton_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def capture_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def sequence_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def mapping_pattern(self, kid: list[ast.AstNode]) -> ast.MatchMapping: ...
        def list_inner_pattern(self, kid: list[ast.AstNode]) -> ast.MatchPattern: ...
        def dict_inner_pattern(
            self, kid: list[ast.AstNode]
        ) -> ast.MatchKVPair | ast.MatchStar: ...
        def class_pattern(self, kid: list[ast.AstNode]) -> ast.MatchArch: ...
        def pattern_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.MatchPattern]: ...
        def kw_pattern_list(
            self, kid: list[ast.AstNode]
        ) -> ast.SubNodeList[ast.MatchKVPair]: ...
        def __default_token__(self, token: jl.Token) -> ast.Token: ...
