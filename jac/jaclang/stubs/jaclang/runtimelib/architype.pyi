import types
from dataclasses import dataclass
from jaclang.compiler.constant import EdgeDir as EdgeDir
from jaclang.runtimelib.utils import (
    collect_node_connections as collect_node_connections,
)
from typing import Any, Callable
from uuid import UUID

@dataclass(eq=False)
class Anchor:
    def spawn_call(self, walk: WalkerArchitype) -> WalkerArchitype: ...
    def __init__(self, obj, id=...) -> None: ...

@dataclass(eq=False)
class NodeAnchor(Anchor):
    obj: NodeArchitype
    edges: list[EdgeArchitype] = ...
    edge_ids: list[UUID] = ...
    persistent: bool = ...
    def populate_edges(self) -> None: ...
    def connect_node(self, nd: NodeArchitype, edg: EdgeArchitype) -> NodeArchitype: ...
    def get_edges(
        self,
        dir: EdgeDir,
        filter_func: Callable[[list[EdgeArchitype]], list[EdgeArchitype]] | None,
        target_obj: list[NodeArchitype] | None,
    ) -> list[EdgeArchitype]: ...
    def edges_to_nodes(
        self,
        dir: EdgeDir,
        filter_func: Callable[[list[EdgeArchitype]], list[EdgeArchitype]] | None,
        target_obj: list[NodeArchitype] | None,
    ) -> list[NodeArchitype]: ...
    def gen_dot(self, dot_file: str | None = None) -> str: ...
    def __init__(
        self, obj, id=..., edges=..., edge_ids=..., persistent=...
    ) -> None: ...

@dataclass(eq=False)
class EdgeAnchor(Anchor):
    obj: EdgeArchitype
    source: NodeArchitype | None = ...
    target: NodeArchitype | None = ...
    source_id: UUID | None = ...
    target_id: UUID | None = ...
    is_undirected: bool = ...
    persistent: bool = ...
    def attach(
        self, src: NodeArchitype, trg: NodeArchitype, is_undirected: bool = False
    ) -> EdgeAnchor: ...
    def detach(
        self, src: NodeArchitype, trg: NodeArchitype, is_undirected: bool = False
    ) -> None: ...
    def spawn_call(self, walk: WalkerArchitype) -> WalkerArchitype: ...
    def __init__(
        self,
        obj,
        id=...,
        source=...,
        target=...,
        source_id=...,
        target_id=...,
        is_undirected=...,
        persistent=...,
    ) -> None: ...

@dataclass(eq=False)
class WalkerAnchor(Anchor):
    obj: WalkerArchitype
    path: list[Architype] = ...
    next: list[Architype] = ...
    ignores: list[Architype] = ...
    disengaged: bool = ...
    def visit_node(
        self,
        nds: (
            list[NodeArchitype | EdgeArchitype]
            | list[NodeArchitype]
            | list[EdgeArchitype]
            | NodeArchitype
            | EdgeArchitype
        ),
    ) -> bool: ...
    def ignore_node(
        self,
        nds: (
            list[NodeArchitype | EdgeArchitype]
            | list[NodeArchitype]
            | list[EdgeArchitype]
            | NodeArchitype
            | EdgeArchitype
        ),
    ) -> bool: ...
    def disengage_now(self) -> None: ...
    def spawn_call(self, nd: Architype) -> WalkerArchitype: ...
    def __init__(
        self, obj, id=..., path=..., next=..., ignores=..., disengaged=...
    ) -> None: ...

class Architype:
    def __init__(self) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...

class NodeArchitype(Architype):
    def __init__(self) -> None: ...
    def save(self) -> None: ...

class EdgeArchitype(Architype):
    persistent: bool
    def __init__(self) -> None: ...
    def save(self) -> None: ...
    def populate_nodes(self) -> None: ...

class WalkerArchitype(Architype):
    def __init__(self) -> None: ...

class GenericEdge(EdgeArchitype): ...

class Root(NodeArchitype):
    reachable_nodes: list[NodeArchitype]
    connections: set[tuple[NodeArchitype, NodeArchitype, EdgeArchitype]]
    def __init__(self) -> None: ...
    def reset(self) -> None: ...

@dataclass(eq=False)
class DSFunc:
    name: str
    trigger: type | types.UnionType | tuple[type | types.UnionType, ...] | None
    func: Callable[[Any, Any], Any] | None = ...
    def resolve(self, cls: type) -> None: ...
    def __init__(self, name, trigger, func=...) -> None: ...
