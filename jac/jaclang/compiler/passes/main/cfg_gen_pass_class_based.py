"""Genrate a control flow graph from genarated bytecode.

This pass generates a control flow graph from the bytecode generated by the previous pass.
"""

import ast as ast3
import marshal
import dis
from collections import defaultdict
import networkx as nx
import matplotlib.pyplot as plt
from typing import List, Optional, Iterator
import jaclang.compiler.absyntree as ast
from jaclang.compiler.passes import Pass

CODEUNIT_SIZE = 2
class CfgGenPass(Pass):
    """Control flow graph generation pass."""

    def before_pass(self) -> None:
        """Before pass."""
        return super().before_pass()

    def enter_module(self, node: ast.Module) -> None:
        """Sub objects.

        name: str,
        doc: Token,
        body: Optional['Elements'],
        mod_path: str,
        is_imported: bool,
        sym_tab: Optional[SymbolTable],
        """
        mods = [node] + self.get_all_sub_nodes(node, ast.Module)
        module_cfgs = generate_module_cfg(mods)
        # for module_name, cfg_graph in module_cfgs.items():
        #     print(f"Control Flow Graph for {module_name}:")
        #     nx.draw(cfg_graph, with_labels=True)
        #     plt.title("Control Flow Graph")
        #     plt.show()
        #     plt.savefig(f"{module_name}_cfg.png")

class BytecodeOp:
    def __init__(self, index: int, op: int, arg: int) -> None:
        self.idx = index
        self.op = op
        self.arg = arg

    def next_instr_idx(self) -> int:
        return self.idx + 1
    def next_instr_offset(self) -> int:
        return self.next_instr_idx() * CODEUNIT_SIZE
    def __repr__(self):
        return f"{self.idx}: f{self.op} - {self.arg}"
    def is_branch(self) -> bool:
        return self.op in {
            #"FOR_ITER",
            #"JUMP_ABSOLUTE",
            "JUMP_FORWARD",
            "POP_JUMP_IF_TRUE",
            "POP_JUMP_IF_FALSE",
            "JUMP_IF_TRUE_OR_POP",
            "JUMP_IF_FALSE_OR_POP",
        }
    def is_relative_branch(self) -> bool:
        return self.op in {
            "FOR_ITER",
            "JUMP_FORWARD",
        }
    def next_instr_idx(self) -> int:
        return self.idx+1
    def next_instr_offset(self) -> int:
        return self.next_instr_idx()*CODEUNIT_SIZE

    def jump_target(self) -> int:
        if self.is_relative_branch():
            return self.next_instr_offset() + self.arg
        return self.arg
    def jump_target_idx(self) -> int:
        return self.jump_target() // CODEUNIT_SIZE
    
    def is_return(self) -> bool:
        return self.op == "RETURN_VALUE"

    def is_raise(self) -> bool:
        return self.op == "RAISE_VARARGS"

class BytecodeSlice:
    """A slice of bytecode from [start, end)."""

    def __init__(
        self,
        bytecode: List[BytecodeOp],
        start: Optional[int] = None,
        end: Optional[int] = None,
    ) -> None:
        self.bytecode = bytecode
        self.start: int = 0 if start is None else start
        self.end: int = len(bytecode) if end is None else end

    def __repr__(self) -> str:
        return f"<BytecodeSlice start={self.start}, end={self.end}>"
    def size(self) -> int:
        return self.end - self.start
    def __iter__(self) -> Iterator[BytecodeOp]:
        return iter(self.bytecode[self.start : self.end])

class Block:
    def __init__(self, id: int, bytecode: BytecodeSlice):
        self.id: int = id
        self.bytecode: BytecodeSlice = bytecode

class BlockMap:
    def __init__(self) -> None:
        self.idx_to_block: Dict[int, Block] = {}

    def add_block(self, idx, block):
        self.idx_to_block[idx] = block

    def __repr__(self) -> str:
        result = []
        for block in self.idx_to_block.values():
            result.append(f"bb{block.id}:")
            for instr in block.bytecode:
                if instr.is_branch():
                    target_idx = instr.jump_target_idx()
                    target = self.idx_to_block[target_idx]
                    result.append(f"  {instr.op} bb{target.id}")
                else:
                    result.append(f"  {instr}")
        return "\n".join(result)
    def __str__(self) -> str:
        return self.__repr__()

def disassemble_bytecode(bytecode):
    code_object = marshal.loads(bytecode)
    instructions = []
    for i, instr in enumerate(dis.get_instructions(code_object)):
        instructions.append(BytecodeOp(i,instr.opname, instr.arg))
    return instructions

def create_BBs(instructions: BytecodeSlice) -> BlockMap:
    block_starts = set([0])
    block_map = BlockMap()
    num_instr = instructions.size()
    for instr in instructions:
        if instr.is_branch():
            block_starts.add(instr.next_instr_idx())
            block_starts.add(instr.jump_target_idx())
        elif instr.is_return():
            next_instr_idx = instr.next_instr_idx()
            if next_instr_idx < num_instr:
                block_starts.add(next_instr_idx)
        elif instr.is_raise():
            block_starts.add(instr.next_instr_idx())

    block_starts_ordered = list(sorted(block_starts))

    block_count = len(block_starts)

    for i, start_idx in enumerate(block_starts_ordered):
        print(i)
        end_idx = block_starts_ordered[i + 1] if i + 1 < block_count else num_instr
        print(f"{start_idx}:{end_idx}")
        block_instrs = BytecodeSlice(instructions.bytecode, start_idx, end_idx)
        block_map.add_block(start_idx, Block(i, block_instrs))
    return block_map



def extract_cfg_from_instructions(instructions):
    cfg = defaultdict(list)
    current_block = []
    block_id = 0
    block_map = {}  # Maps instruction offsets to blocks
    edges = {}

    for instr in instructions:
        current_block.append(instr)
        if instr.opname in {
            "JUMP_ABSOLUTE",
            "JUMP_FORWARD",
            "POP_JUMP_IF_TRUE",
            "POP_JUMP_IF_FALSE",
            "JUMP_IF_TRUE_OR_POP",
            "JUMP_IF_FALSE_OR_POP",
        }:
            cfg[block_id] = current_block
            block_map[instr.offset] = block_id
            target = (
                instr.offset + instr.argval + 2
                if instr.opname == "JUMP_FORWARD"
                else instr.argval
            )
            edges[block_id] = target
            block_id += 1

    # Update edges to use block numbers instead of offsets
    for block_id, target_offset in edges.items():
        if target_offset in block_map:
            edges[block_id] = block_map[target_offset]
        else:
            print(f"Warning: Target offset {target_offset} not found in block_map")
    return cfg, block_map, edges


def build_cfg_graph(cfg, block_map, edges):
    graph = nx.DiGraph()

    for block_id, instructions in cfg.items():
        print(f"Block ID {block_id}:")
        print(
            "\n".join(
                [
                    f"{instr.offset}: {instr.opname} {instr.argval}"
                    for instr in instructions
                ]
            )
        )
        graph.add_node(block_id, instructions=instructions)
        last_instruction = instructions[-1] if instructions else None

        # Verify last_instruction is valid and has 'opname' attribute
        if last_instruction and hasattr(last_instruction, "opname"):
            if (
                "JUMP" in last_instruction.opname
                and last_instruction.argval in block_map
            ):
                target_block = block_map[last_instruction.offset]
                graph.add_edge(block_id, target_block)
        else:
            print(
                f"Warning: Block ID {block_id} does not have a valid jump target or last instruction"
            )
    return graph


def generate_module_cfg(modules):
    module_cfgs = {}
    for mod in modules:
        bytecode = mod.gen.py_bytecode
        instructions = disassemble_bytecode(bytecode)
        bytecode_slice = BytecodeSlice(instructions)
        BBs = create_BBs(bytecode_slice)
        #cfg, block_map, edges = extract_cfg_from_instructions(instructions)
        #module_cfgs[mod.name] = build_cfg_graph(cfg, block_map, edges)
    #return module_cfgs


# Compile the simple function `decisions`
source_code = """
def f(x):
    if x:
        y = 1
    else:
        y = 2
    return y
"""
compiled_code = compile(source_code, filename="<string>", mode="exec")

# Extract the code object of the `decisions` function
decisions_code = compiled_code.co_consts[0]  # The first constant is the code object

# Serialize the bytecode of the function
serialized_bytecode = marshal.dumps(decisions_code)

# Disassemble the serialized bytecode
disassembled_instructions = disassemble_bytecode(serialized_bytecode)
bytecode_slice = BytecodeSlice(disassembled_instructions)
print(bytecode_slice)

# Generate and print basic blocks
BBs = create_BBs(bytecode_slice)
print(BBs)
