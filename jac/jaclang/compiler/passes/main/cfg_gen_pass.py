"""Genrate a control flow graph from genarated bytecode.

This pass generates a control flow graph from the bytecode generated by the previous pass.
"""

import ast

import jaclang.compiler.absyntree as ast
from jaclang.compiler.passes import Pass
from jaclang.runtimelib.cfg import visualize_cfg, disassemble_bytecode, create_BBs, create_cfg

class CfgGenPass(Pass):
    """Control flow graph generation pass."""

    def before_pass(self) -> None:
        """Before pass."""
        return super().before_pass()

    def enter_module(self, node: ast.Module) -> None:
        """Sub objects.

        name: str,
        doc: Token,
        body: Optional['Elements'],
        mod_path: str,
        is_imported: bool,
        sym_tab: Optional[SymbolTable],
        """

        from jaclang.runtimelib.machine import JacMachine
        if JacMachine.get().gin:
            mods = [node] + self.get_all_sub_nodes(node, ast.Module)
            module_cfgs = {}
            for mod in mods:
                bytecode = mod.gen.py_bytecode
                instructions = disassemble_bytecode(bytecode)
                BBs = create_BBs(instructions)  
                print(BBs)        
                cfg = create_cfg(BBs)
                module_cfgs[mod.name] = cfg
            for cfg in module_cfgs.values():
                dot = visualize_cfg(cfg)
                dot.render('cfg.gv', view=True)
            if JacMachine.get().gin:
                try:
                    JacMachine.get().gin.get_cfgs(cfgs=module_cfgs)
                except Exception as e:
                    print(f"Can't save cfgs: {e}")
            
            # cfg, block_map, edges = extract_cfg_from_instructions(instructions)
        #     module_cfgs[mod.name] = build_cfg_graph(cfg, block_map, edges)
        # for module_name, cfg_graph in module_cfgs.items():
        #     print(f"Control Flow Graph for {module_name}:")
        #     nx.draw(cfg_graph, with_labels=True)
        #     plt.title("Control Flow Graph")
        #     plt.show()
        #     plt.savefig(f"{module_name}_cfg.png")


# def disassemble_bytecode(bytecode):
#     code_object = marshal.loads(bytecode)
#     instructions = list(dis.get_instructions(code_object))
#     print(f"Disassembled bytecode for {code_object.co_name}:")
#     print(
#         "\n".join(
#             [f"{instr.offset}: {instr.opname} {instr.argval}" for instr in instructions]
#         )
#     )
#     return instructions


# def extract_cfg_from_instructions(instructions):
#     cfg = defaultdict(list)
#     current_block = []
#     block_id = 0
#     block_map = {}  # Maps instruction offsets to blocks
#     edges = {}

#     for instr in instructions:
#         current_block.append(instr)
#         if instr.opname in {
#             "JUMP_ABSOLUTE",
#             "JUMP_FORWARD",
#             "POP_JUMP_IF_TRUE",
#             "POP_JUMP_IF_FALSE",
#             "JUMP_IF_TRUE_OR_POP",
#             "JUMP_IF_FALSE_OR_POP",
#         }:
#             cfg[block_id] = current_block
#             block_map[instr.offset] = block_id
#             target = (
#                 instr.offset + instr.argval + 2
#                 if instr.opname == "JUMP_FORWARD"
#                 else instr.argval
#             )
#             edges[block_id] = target
#             block_id += 1

#     # Update edges to use block numbers instead of offsets
#     for block_id, target_offset in edges.items():
#         if target_offset in block_map:
#             edges[block_id] = block_map[target_offset]
#         else:
#             print(f"Warning: Target offset {target_offset} not found in block_map")
#     print(edges)
#     return cfg, block_map, edges


# def build_cfg_graph(cfg, block_map, edges):
#     graph = nx.DiGraph()

#     for block_id, instructions in cfg.items():
#         print(f"Block ID {block_id}:")
#         print(
#             "\n".join(
#                 [
#                     f"{instr.offset}: {instr.opname} {instr.argval}"
#                     for instr in instructions
#                 ]
#             )
#         )
#         graph.add_node(block_id, instructions=instructions)
#         last_instruction = instructions[-1] if instructions else None

#         # Verify last_instruction is valid and has 'opname' attribute
#         if last_instruction and hasattr(last_instruction, "opname"):
#             if (
#                 "JUMP" in last_instruction.opname
#                 and last_instruction.argval in block_map
#             ):
#                 target_block = block_map[last_instruction.offset]
#                 graph.add_edge(block_id, target_block)
#         else:
#             print(
#                 f"Warning: Block ID {block_id} does not have a valid jump target or last instruction"
#             )
#     return graph


# def generate_module_cfg(modules):
#     module_cfgs = {}
#     for mod in modules:
#         bytecode = mod.gen.py_bytecode
#         instructions = disassemble_bytecode(bytecode)
#         cfg, block_map, edges = extract_cfg_from_instructions(instructions)
#         module_cfgs[mod.name] = build_cfg_graph(cfg, block_map, edges)
#     return module_cfgs
