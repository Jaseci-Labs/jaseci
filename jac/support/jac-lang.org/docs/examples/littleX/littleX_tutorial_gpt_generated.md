# littleX: A Jac Programming Language Code‐Along Tutorial

Jac is a native superset of Python that not only inherits all of Python’s features but also adds innovative constructs for data spatial programming and direct integration with large language models (LLMs). In this tutorial, you will build **littleX**—a miniature social network (think of it as a simplified Twitter/X)—using Jac’s data-spatial abstractions (nodes, edges, and walkers) alongside LLM integration via the `by llm` syntax.

> **Prerequisites:**
> You should have a background in Python. Although Jac builds on Python, its additional data-spatial constructs and special syntax are new. Follow along step by step: type the snippets into your Jac environment and experiment with modifying or extending the code.

---

## 1. Overview of littleX and Jac’s Key Features

**littleX** is a social network prototype that supports:

- **User Profile Management:** Creating, updating, and retrieving profiles.
- **Tweet Operations:** Posting, updating, deleting tweets, liking/unliking tweets, and commenting.
- **Feed Aggregation:** Loading a feed from the user’s tweets and those of followed profiles, with integrated tweet search and summarization.

Two of Jac’s most innovative features come into play:

1. **Data Spatial Programming:** Instead of traditional procedural code, Jac lets you structure your application as a graph. Data entities are nodes, relationships are edges, and specialized walkers traverse the graph to perform operations.
2. **LLM Integration:** With the `by llm` syntax, you can define functions and methods whose implementations are handled by LLMs—removing the need for prompt engineering and manual API calls.

---

## 2. Setting up Dependencies and Imports

Jac seamlessly reuses Python libraries. At the start of the program, several modules are imported using the `import:py` directive:

```jac
import:py datetime;
import:py from jac_cloud.core.architype { NodeAnchor }
import:py from mtllm.llms { Ollama }
import:py numpy;
import:py from sentence_transformers { SentenceTransformer }
import:py from sklearn.metrics.pairwise { cosine_similarity }
```

**Explanation:**

- `import:py` tells Jac to import Python modules. This lets you use Python libraries (e.g., `datetime`, `numpy`) without any extra interfacing.
- You can also import jac  modules using `import:jac`.
- The import from `mtllm.llms` enables LLM integration directly into your Jac code.

Next, two global variables are defined:

```jac
glob llm = Ollama(host="http://127.0.0.1:11434", model_name="llama3.2:1b");
glob sentence_transformer = SentenceTransformer('all-MiniLM-L6-v2');
```

**Explanation:**

- `glob` declares a global variable.
- Here, `llm` instantiates an LLM (via the Ollama model), while `sentence_transformer` is used for generating text embeddings.

---

## 3. Function Definitions: Data Processing and LLM Integration

Jac functions—declared using the `can` keyword—are similar to Python functions but can delegate their implementation to an LLM using the `by llm` syntax.

### 3.1 Tweet Search Function

The function `search_tweets` calculates cosine similarity between a query embedding and tweet embeddings to filter relevant tweets:

```jac
can search_tweets(query: str, tweets: list, tweet_embeddings: any, similarity_threshold: float=0.25) -> list {
    query_embedding = sentence_transformer.encode([query]);
    similarities = cosine_similarity(query_embedding, tweet_embeddings)[0];
    results = [{**{"Tweet_Info": tweets[i]}, "similarity": similarities[i]}
               for i in range(len(similarities)) if similarities[i] >= similarity_threshold];
    return results;
}
```

**Key Points:**

- The query is encoded into an embedding.
- Cosine similarity is computed between the query and precomputed tweet embeddings.
- A list comprehension filters tweets with a similarity above the threshold.

### 3.2 Tweet Summarization Function via LLM

This ability uses the integrated LLM to summarize tweet content:

```jac
can 'Extract and summarize trending themes, major highlights, and key interactions from recent tweets in one concise sentence.'
summarize_tweets(tweets: list[str]) -> 'Summarisation': str by llm();
```

**Key Points:**

- A descriptive string or semstring (in quotes) explains the function’s purpose.
- The `by llm()` syntax indicates that the summary is generated by the LLM.
- The return type includes a description to clarify the expected output.

---

## 4. Data Structures: Nodes, Objects, and Edges

Jac uses a data-spatial model where data are represented as nodes and relationships as edges.

### 4.1 Profile Node

User profiles are defined as nodes:

```jac
node Profile {
    has username: str = "";

    can update with update_profile entry {
        self.username = here.new_username;
        report self;
    }

    can get with get_profile entry {
        report self;
    }

    can follow with follow_request entry {
        current_profile = [root-->(`?Profile)];
        current_profile[0] +:Follow():+> self;
        report self;
    }

    can un_follow with un_follow_request entry {
        current_profile = [root-->(`?Profile)];
        current_profile[0] del-:Follow:-> self;
        report self;
    }
}
```

**Key Points:**

- The `node` keyword declares a graph node.
- Attributes (like `username`) are defined using `has` syntax.
- Abilities (`update`, `get`, `follow`, `un_follow`) are attached with entry triggers. Note how graph traversal is used to find and connect Profile nodes.

### 4.2 Tweet and Comment Nodes and TweetInfo Object

Define a structured object for tweet information and nodes for tweets and comments:

```jac
obj TweetInfo {
    has id: str;
    has content: str;
    has embedding: list;
    has likes: list;
    has comments: list;
}

node Tweet {
    has content: str;
    has embedding: list;
    has created_at: str = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S");

    can update with update_tweet exit {
        self.content = here.updated_content;
        report self;
    }

    can delete with remove_tweet exit {
        del self;
    }

    can like_tweet with like_tweet entry {
        current_profile = [root-->(`?Profile)];
        self +:Like():+> current_profile[0];
        report self;
    }

    can remove_like with remove_like entry {
        current_profile = [root-->(`?Profile)];
        self del-:Like:-> current_profile[0];
        report self;
    }

    can comment with comment_tweet entry {
        current_profile = [root-->(`?Profile)];
        comment_node = current_profile[0] ++> Comment(content=here.content);
        Jac.unrestrict(comment_node[0], level="CONNECT");
        self ++> comment_node[0];
        report comment_node[0];
    }

    can get_info() -> TweetInfo {
        return TweetInfo(
            id=jid(self),
            content=self.content,
            embedding=self.embedding,
            likes=[i.username for i in [self-:Like:->]],
            comments=[{"id": jid(i), "content": i.content} for i in [self-->(`?Comment)]]
        );
    }
}

node Comment {
    has content: str;
}
```

**Key Points:**

- **TweetInfo** is a structured object (like a data class) holding tweet metadata.
- The **Tweet node** has the ability to update, delete, like, and comment.
- `like` ability will be executed when `like_tweet` walker enter the tweet node.
- ```[root-->(`?Profile)]``` get all the nodes connected to `root` node and filter the node that are `Profile` nodes and return them.
- `self +:Like():+> current_profile[0]` creates and connects `self` which is current `Tweet` node with the filtered `Profile` node.
- `report` reports `self` that means the current node as response.
- `update` ability will be executed when `update_tweet` walker exit the tweet node.
- Within a node, `self` refers to that node, and `here` refers to the walker that was recently spawned on that node.
- `Jac.unrestrict(comment_node[0], level="CONNECT")` sets the permission level of the `Comment` node to `CONNECT` so that other nodes can be connected to this node if required.

### 4.3 Edge Declarations

Edges define how nodes connect, and three types of edges are declared:

```jac
edge Follow {}
edge Like {}
edge Post {}
```

**Key Points:**

- These edge types are used in connecting nodes (e.g., a Profile following another Profile or a Profile posting a Tweet).
- Custom edges can also include attributes, as seen when using connection syntax with additional parameters.

#### Edge Operations

- **`++>` (Unidirectional Edge Creation):**
  Use this operator to create a one-way connection between nodes.
  ```jac
  first_node = MyNode();
  second_node = MyNode();
  root ++> first_node;
  first_node ++> second_node;
  ```
  This means the edge flows from `root` to `first_node` and then from `first_node` to `second_node`.

- **`<++>` (Bidirectional Edge Creation):**
  To connect two nodes in both directions, use:
  ```jac
  node_1 <++> node_2;
  ```
  This creates a bidirectional link, so traversal is possible in either direction.

- **Custom Edges with Attributes:**
  Custom edges can have properties:
  ```jac
  edge Follow {
      has status: str;
  }

  with entry {
      profile1 +:Follow:status='active':+> profile2;
  }
  ```
  This creates a Follow edge with an attribute `status`.

- **Deleting Edges:**
  Remove an edge with:
  ```jac
  node_1 del --> node_2;
  ```

---

## 5. Walkers: Graph Traversal and Dynamic Operations

Walkers are processes that traverse the graph, executing abilities on nodes as they visit.

### 5.1 Basic Walker for Profile Traversal

```jac
walker visit_profile {
    can visit_profile with `root entry {
        visit [-->(`?Profile)] else {
            new_profile = here ++> Profile();
            Jac.unrestrict(new_profile[0], level="CONNECT");
            visit new_profile;
        }
    }
}

walker update_profile :visit_profile: {
    has new_username: str;
}

walker get_profile :visit_profile: {}

walker load_user_profiles {
    obj __specs__ {
        static has auth: bool = False;
    }
    can load_profiles with `root entry {
        self.profiles: list = [];

        for user in NodeAnchor.Collection.find({"name": "Profile"}) {
            user_node = user.architype;
            self.profiles.append(
                {"name": user_node.username, "id": jid(user_node)}
            );
        }
        report self.profiles;
    }
}

walker follow_request {}

walker un_follow_request {}

walker create_tweet :visit_profile: {
    has content: str;

    can tweet with Profile entry {
        embedding = sentence_transformer.encode(self.content).tolist();
        tweet_node = here +:Post:+> Tweet(content=self.content, embedding=embedding);
        Jac.unrestrict(tweet_node[0], level="CONNECT");
        report tweet_node;
    }
}

walker update_tweet {
    has updated_content: str;
}

walker remove_tweet {}

walker like_tweet {}

walker remove_like {}

walker comment_tweet {
    has content: str;
}

walker update_comment {
    has updated_content: str;
}

walker remove_comment {}

walker load_tweets :visit_profile: {
    has if_report: bool = False;
    has tweet_info: list[TweetInfo] = [];

    can go_to_tweet with Profile entry {
        visit [-->(`?Tweet)];
        if (self.if_report) {
            report self.tweet_info;
        }
    }

    can report_tweet with Tweet entry {
        self.tweet_info.append(here.get_info());
    }
}

walker load_feed :visit_profile: {
    has search_query: str = "";

    can load with Profile entry {
        feeds: list = [];
        user_tweets = here spawn load_tweets();
        feeds.extend(user_tweets.tweet_info);

        for user_node in [-:Follow:->](`?Profile) {
            user_tweets = user_node spawn load_tweets();
            feeds.extend(user_tweets.tweet_info);
        }
        tweets = [feed.content for feed in feeds];
        tweet_embeddings = [numpy.array(feed.embedding) for feed in feeds];
        summary: str = summarize_tweets(tweets);

        # Filter tweets based on search query
        if (self.search_query) {
            filtered_results = search_tweets(
                self.search_query,
                feeds,
                tweet_embeddings
            );
            report {"feeds": filtered_results, "summary": summary};
        } else {
            report {"feeds": feeds, "summary": summary};
        }
    }
}
```

**Key Points:**

- **Walker Declaration:** A walker type named `visit_profile` is defined.
- **Traversal with `visit`:** The walker attempts to visit all the nodes with `Profile` type using the `visit` keyword and the traversal operator `[-->(`?Profile)]`.
- **Fallback Action:** If no Profile node is found, the walker creates one and then visits it.

### 5.2 Creating Tweets via Walkers

A walker that creates a tweet might look like this:

```jac
walker create_tweet :visit_profile: {
    has content: str;

    can tweet with Profile entry {
        embedding = sentence_transformer.encode(self.content).tolist();
        tweet_node = here +:Post:+> Tweet(content=self.content, embedding=embedding);
        Jac.unrestrict(tweet_node[0], level="CONNECT");
        report tweet_node;
    }
}
```

**Key Points:**

- The walker `create_tweet` inherits from `visit_profile` so it begins at a Profile node.
- It computes an embedding for the tweet content.
- Then it creates a Tweet node and connects it using a Post edge.

Additional walkers (update, remove, like, comment, load feed, etc.) are defined similarly, orchestrating interactions between Profiles and Tweets.

### 5.3 Loading the Feed and Summarization

The `load_feed` walker aggregates tweets from the current Profile and followed profiles, applies tweet search filtering if needed, and then summarizes the tweets:

```jac
walker load_feed :visit_profile: {
    has search_query: str = "";

    can load with Profile entry {
        feeds: list = [];
        user_tweets = here spawn load_tweets();
        feeds.extend(user_tweets.tweet_info);

        for user_node in [-:Follow:->](`?Profile) {
            user_tweets = user_node spawn load_tweets();
            feeds.extend(user_tweets.tweet_info);
        }
        tweets = [feed.content for feed in feeds];
        tweet_embeddings = [numpy.array(feed.embedding) for feed in feeds];
        summary: str = summarize_tweets(tweets);

        # Filter tweets based on search query
        if (self.search_query) {
            filtered_results = search_tweets(
                self.search_query,
                feeds,
                tweet_embeddings
            );
            report {"feeds": filtered_results, "summary": summary};
        } else {
            report {"feeds": feeds, "summary": summary};
        }
    }
}
```

**Key Points:**

- The walker aggregates tweets from multiple sources.
- It uses the previously defined `summarize_tweets` ability (which leverages LLM integration) to generate a summary.
- Optionally, if a search query is provided, the tweets are filtered accordingly.

---

## 6. Test functionality

Using tools like Swagger or Postman, you can test these APIs to confirm their functionality.

1. Start the Server
`jac serve filename.jac` run using command line.

2. Access Swagger Docs
Open your browser and navigate to http://localhost:8000/docs

3. Test an API Endpoint
      - Click on an endpoint
      - Click "Try it out" to enable input fields.
      - Enter required parameters (if any).
      - Click "Execute" to send the request.
      - View the response (status code, headers, and JSON response body).

## 7. Special Data Spatial Syntax: Operators and Traversal

Jac’s unique syntax makes graph manipulation intuitive. Let’s dive deeper into some of these constructs.

### 7.1 Edge Connection Operators

#### a. Unidirectional and Bidirectional Connections

- **`++>` (Unidirectional Edge Creation):**
  Use this operator to create a one-way connection between nodes.
  ```jac
  first_node = MyNode();
  second_node = MyNode();
  root ++> first_node;
  first_node ++> second_node;
  ```
  This means the edge flows from `root` to `first_node` and then from `first_node` to `second_node`.

- **`<++>` (Bidirectional Edge Creation):**
  To connect two nodes in both directions, use:
  ```jac
  node_1 <++> node_2;
  ```
  This creates a bidirectional link, so traversal is possible in either direction.

- **Custom Edges with Attributes:**
  Custom edges can have properties:
  ```jac
  edge Follow {
      has status: str;
  }

  with entry {
      profile1 +:Follow:status='active':+> profile2;
  }
  ```
  This creates a Follow edge with an attribute `status`.

- **Deleting Edges:**
  Remove an edge with:
  ```jac
  node_1 del --> node_2;
  ```

#### b. Traversal Operators in Filtering

When traversing the graph, you can specify which edges to follow:
```jac
print([root-:a:-> (`?C)]);
```
- Here, `-:a:->` tells the walker to follow only edges of the custom type `a`.

You can chain operators to represent more complex paths:
```jac
print([root-:a:-> -:b:-> -:c:->(`?C)]);
```
This chains three different edge filters in sequence.

### 7.2 The `visit` Keyword for Graph Traversal

The `visit` keyword directs walkers to navigate the graph:
```jac
visit [-->(`?Profile)];
```
**Explanation:**

- **`-->` in Traversal:**
  Inside a `visit` expression, the arrow indicates the direction of traversal (following outgoing edges).
- **Type Filtering:**
  The pattern ``(`?Profile)`` filters for nodes of type `Profile`.
- **Conditional Traversal:**
  Walkers can also include an `else` clause to handle missing nodes:
  ```jac
  walker visit_profile {
      can visit_profile with `root entry {
          visit [-->(`?Profile)] else {
              new_profile = here ++> Profile();
              Jac.unrestrict(new_profile[0], level="CONNECT");
              visit new_profile;
          }
      }
  }
  ```
  If no `Profile` node exists, the walker creates one before proceeding.

---

## 8. Conclusion and Next Steps

In this combined tutorial, we have:

- **Introduced littleX:** A social network prototype built using Jac that leverages both Python interoperability and new language constructs.
- **Set up the environment:** Imported Python libraries and defined global variables for LLM and embedding functionality.
- **Defined functions and data structures:** Used the `can` keyword for functions (including LLM-based implementations) and declared nodes/objects (Profile, Tweet, Comment, and TweetInfo) to model the application data.
- **Explained walkers:** Demonstrated how walkers traverse the graph with the `visit` keyword and how they spawn to execute operations like creating tweets.
- **Detailed data spatial syntax:** Provided an in-depth look at edge operators (`++>`, `<++>`, `-->`), traversal filtering, and the special `visit` keyword that power Jac’s data-spatial programming model.

With these foundations, you are now equipped to experiment with Jac’s powerful, hybrid approach. Try extending littleX by adding new abilities (such as retweeting or sentiment-based filtering), or design your own data-spatial application. Jac’s natural integration with Python and LLMs offers a versatile platform for building modern, scalable applications.

Happy coding with Jac!

---

This completes the comprehensive tutorial on littleX and the unique data spatial syntax of the Jac programming language. Enjoy exploring and building with Jac!