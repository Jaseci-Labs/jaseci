<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Jaseci Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Jaseci Official Documentation</li><li class="chapter-item expanded "><a href="LICENSE.html"><strong aria-hidden="true">1.</strong> License</a></li><li class="chapter-item expanded "><a href="CHANGELOG.html"><strong aria-hidden="true">2.</strong> About this Release</a></li><li class="chapter-item expanded "><a href="CONTRIBUTING.html"><strong aria-hidden="true">3.</strong> How to Contribute</a></li><li class="chapter-item expanded "><a href="CONTRIBUTORS.html"><strong aria-hidden="true">4.</strong> Contributors</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="support/guide/getting_started/introduction.html"><strong aria-hidden="true">5.</strong> Introducing Jaseci</a></li><li class="chapter-item expanded "><a href="support/guide/getting_started/installation.html"><strong aria-hidden="true">6.</strong> Installing Jaseci</a></li><li class="chapter-item expanded "><a href="support/guide/getting_started/setting_up_your_editor.html"><strong aria-hidden="true">7.</strong> Setting Up Your Editor</a></li><li class="chapter-item expanded "><a href="support/guide/getting_started/writing_your_first_app.html"><strong aria-hidden="true">8.</strong> Writing Your First App</a></li><li class="chapter-item expanded "><a href="support/guide/getting_started/understanding_jac_programs.html"><strong aria-hidden="true">9.</strong> Understanding JAC Programs</a></li><li class="chapter-item expanded affix "><li class="part-title">The JAC Programming Language Guide</li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/jac_language_overview.html"><strong aria-hidden="true">10.</strong> Language Overview</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/jac_grammar.html"><strong aria-hidden="true">11.</strong> Grammar</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/operators.html"><strong aria-hidden="true">12.</strong> Operators</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/control_flow.html"><strong aria-hidden="true">13.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/collections.html"><strong aria-hidden="true">14.</strong> Collections</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/nodes.html"><strong aria-hidden="true">15.</strong> Nodes</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/edges.html"><strong aria-hidden="true">16.</strong> Edges</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/graphs.html"><strong aria-hidden="true">17.</strong> Graphs</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/walkers.html"><strong aria-hidden="true">18.</strong> Walkers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/traversing_a_graph.html"><strong aria-hidden="true">18.1.</strong> Traversing a Graph</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/referencing_node_context.html"><strong aria-hidden="true">18.2.</strong> Referencing a Node in Context</a></li></ol></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/passing_arguments.html"><strong aria-hidden="true">19.</strong> Passing Arguments</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/specifying_operating_context.html"><strong aria-hidden="true">20.</strong> Specifying Operating Context</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/actions.html"><strong aria-hidden="true">21.</strong> Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/date_actions.html"><strong aria-hidden="true">21.1.</strong> Date Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/file_actions.html"><strong aria-hidden="true">21.2.</strong> File Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/net_actions.html"><strong aria-hidden="true">21.3.</strong> Net Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/rand_actions.html"><strong aria-hidden="true">21.4.</strong> Rand Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/request_actions.html"><strong aria-hidden="true">21.5.</strong> Request Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/standard_actions.html"><strong aria-hidden="true">21.6.</strong> Standard Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/vector_actions.html"><strong aria-hidden="true">21.7.</strong> Vector Actions</a></li><li class="chapter-item expanded "><a href="support/guide/jac_language_guide/jaseci_actions.html"><strong aria-hidden="true">21.8.</strong> Jaseci Actions</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Examples and Tutorials</li><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter1.html"><strong aria-hidden="true">22.</strong> Building a Conversational AI System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter2.html"><strong aria-hidden="true">22.1.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter3.html"><strong aria-hidden="true">22.2.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter4.html"><strong aria-hidden="true">22.3.</strong> Chapter 4</a></li><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter5.html"><strong aria-hidden="true">22.4.</strong> Chapter 5</a></li><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter6.html"><strong aria-hidden="true">22.5.</strong> Chapter 6</a></li><li class="chapter-item expanded "><a href="support/codelabs/canonicai/chapter7.html"><strong aria-hidden="true">22.6.</strong> Chapter 7</a></li></ol></li><li class="chapter-item expanded "><a href="examples/CanoniCAI/CCAI_codelab.html"><strong aria-hidden="true">23.</strong> CanoniCAI Example</a></li><li class="chapter-item expanded "><a href="examples/ner_examples/index.html"><strong aria-hidden="true">24.</strong> NER Examples</a></li><li class="chapter-item expanded affix "><li class="part-title">Jaseci Library Reference</li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/index.html"><strong aria-hidden="true">25.</strong> Jaseci Kit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/encoders/index.html"><strong aria-hidden="true">25.1.</strong> Encoders</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/encoders/use_enc/index.html"><strong aria-hidden="true">25.1.1.</strong> USE Encoder</a></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/encoders/use_qa/index.html"><strong aria-hidden="true">25.1.2.</strong> USE QA</a></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/encoders/fast_enc/index.html"><strong aria-hidden="true">25.1.3.</strong> FastText</a></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/encoders/bi_enc/index.html"><strong aria-hidden="true">25.1.4.</strong> Bi-Encoder</a></li></ol></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/entity_utils/index.html"><strong aria-hidden="true">25.2.</strong> Entity Recognition</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html"><strong aria-hidden="true">25.2.1.</strong> FLair NER</a></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html"><strong aria-hidden="true">25.2.2.</strong> Transformer NER</a></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/entity_utils/lstm_ner/index.html"><strong aria-hidden="true">25.2.3.</strong> LSTM NER</a></li></ol></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/summarization/index.html"><strong aria-hidden="true">25.3.</strong> Text Summarization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/summarization/cl_summer/index.html"><strong aria-hidden="true">25.3.1.</strong> CL Summarization</a></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/summarization/t5_sum/index.html"><strong aria-hidden="true">25.3.2.</strong> T5 Summarization</a></li></ol></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/text_processing/index.html"><strong aria-hidden="true">25.4.</strong> Text Processing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/text_processing/text_seg/index.html"><strong aria-hidden="true">25.4.1.</strong> Text Segmenter</a></li></ol></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/object_detection/index.html"><strong aria-hidden="true">25.5.</strong> Object Detection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/object_detection/yolo_v5/index.html"><strong aria-hidden="true">25.5.1.</strong> YOLO V5</a></li></ol></li><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/non_ai/index.html"><strong aria-hidden="true">25.6.</strong> Non-AI Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="support/guide/jaseci_kit/modules/non_ai/pdf_ext/index.html"><strong aria-hidden="true">25.6.1.</strong> PDF Extractor</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Jaseci Studio</li><li class="chapter-item expanded "><a href="jaseci_ui_kit/index.html"><strong aria-hidden="true">26.</strong> Jaseci UI Kit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/gettingStarted.html"><strong aria-hidden="true">26.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/basic-concepts.html"><strong aria-hidden="true">26.2.</strong> Basic Concepts</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/built-in-actions.html"><strong aria-hidden="true">26.3.</strong> Built-in Actions</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/connecting-an-api.html"><strong aria-hidden="true">26.4.</strong> Connecting an API</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/list_of_componets.html"><strong aria-hidden="true">26.5.</strong> List of Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/AuthForm.html"><strong aria-hidden="true">26.5.1.</strong> AuthForm</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Badge.html"><strong aria-hidden="true">26.5.2.</strong> Badge</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Breadcrumbs.html"><strong aria-hidden="true">26.5.3.</strong> Breadcrumbs</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Button.html"><strong aria-hidden="true">26.5.4.</strong> Button</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/ButtonGroup.html"><strong aria-hidden="true">26.5.5.</strong> ButtonGroup</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Card.html"><strong aria-hidden="true">26.5.6.</strong> Card</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Carousel.html"><strong aria-hidden="true">26.5.7.</strong> Carousel</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Checkbox.html"><strong aria-hidden="true">26.5.8.</strong> Checkbox</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Collapse.html"><strong aria-hidden="true">26.5.9.</strong> Collapse</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Checkbox.html"><strong aria-hidden="true">26.5.10.</strong> Checkbox</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Collapse.html"><strong aria-hidden="true">26.5.11.</strong> Collapse</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Column.html"><strong aria-hidden="true">26.5.12.</strong> Column</a></li><li class="chapter-item expanded "><a href="jaseci_ui_kit/components/docs/components/Container.html"><strong aria-hidden="true">26.5.13.</strong> Container</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jaseci Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mit-license"><a class="header" href="#mit-license">MIT License</a></h1>
<p><em>Copyright (c) 2021 Jaseci Labs LLC</em></p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jaseci-change--release-notes"><a class="header" href="#jaseci-change--release-notes">Jaseci Change / Release Notes</a></h1>
<h2 id="version-134"><a class="header" href="#version-134">Version 1.3.4</a></h2>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<ul>
<li>Deprecation: Stripe API soft removed.</li>
<li>Improvement: Improved the deref operator <code>*</code> to be more nimble</li>
<li>New Feature: Can now pluck lists of values from collections of nodes and edges.</li>
<li>Major Language Feature: Introducing the <code>yeild</code> feature. See bible for details</li>
<li>Improvement/Bug: Here behavior is now specified for ability calls and inheritance in intuitive way</li>
<li>Major Feature: Can now specify various forms of breadth first and depth first search on <code>take</code> commands (e.g., <code>take:bfs</code>, <code>take:dfs</code>, and <code>take:b</code> and <code>take:d</code> for short)</li>
<li>Improvement: Added deep copy for lists and dictionaries</li>
<li>Improvement: The connect operator between 2 nodes now returns the left-hand side. (e.g., <code>n1 --&gt; n2 --&gt; n3</code> will create an intuitive chain of connections not <code>n1 --&gt; n3 &lt;-- n2</code>)</li>
<li>Bug Fix: Root nodes now return valid <code>.type</code></li>
<li>Bug Fix: With exit within walker now executes after exit events in nodes</li>
</ul>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>Behavior change for jac programs utilizing chained connection operators. Connection orders are now intuitive (e.g., <code>n1 --&gt; n2 --&gt; n3</code> will create an intuitive chain of connections not <code>n1 --&gt; n3 &lt;-- n2</code>)</li>
<li>API interface update: <code>sentinel_register</code> auto_run_ctx replaces ctx to be more specific, <code>auto_gen_graph</code> is now <code>auto_create_graph</code> for same reason as well</li>
<li>API interface update: <code>master_create</code> API return format updated</li>
</ul>
<h2 id="version-133"><a class="header" href="#version-133">Version 1.3.3</a></h2>
<h3 id="updates-1"><a class="header" href="#updates-1">Updates</a></h3>
<ul>
<li>Improvement: Added <code>reversed</code> to set of list builtin functions</li>
<li>Bug Fix: Mem leak on graph node setting fixed</li>
<li>Major Feature: Jsctl graph walking tooling</li>
<li>Improvement: Optimized the self generation of jaseci internal APIs</li>
<li>New Feature: Added <code>jaseci</code> standard library as patch through to all jaseci core APIs</li>
<li>New Features: Report payloads can be customized with <code>report:custom</code></li>
<li>Improvement: Disengage can now do disengage with report action</li>
<li>Improvement: import now works recursively through chain of files</li>
<li>Improvement: JSCTL shows token on login</li>
<li>Major Feature: JSCTL has persistent log in sessions, and can logout</li>
<li>Improvement: <code>*</code> and <code>&amp;</code> precedence hierarch locations improved.</li>
<li>Bug Fix: Indirect node field updates tag elements to be written to db</li>
<li>Major Feature: Multiple inheritance support on nodes and edges!</li>
<li>Improvement: Fixed and much improved <code>actions load local</code> functionality</li>
<li>Bug Fix: Globals imports of imports working</li>
<li>Improvement: Sentinel registering improved to include ir mode</li>
<li>Improvement: <code>edge</code> semantics improved</li>
<li>Major bug fix: Re registering new code was breaking architype abilities</li>
<li>Improvement: Tests now only show stdout and stderr on a test by test basis in detailed mode (Much cleaner)</li>
<li>Improvement: JSKit package architecture established, normalized, and standardized</li>
<li>New Lang Feature: Added list built in call of <code>.l::max</code>, <code>.l::min</code>, <code>.l::idx_of_max</code>, and <code>.l::idx_of_min</code></li>
<li>Improvement: Api so super masters can <code>become</code> any master id, also jsctl can issue <code>master allusers</code></li>
<li>New Lang Feature: Can now have <code>can</code> statements in spawn graphs after <code>has anchor rootname</code></li>
<li>Improvement: <code>actions load module</code> added as capability where module strings are accepted</li>
<li>New Feature: Added global root finder <code>net.root</code> to std lib and <code>net.min</code> to go with existing <code>net.max</code></li>
<li>New Feature: New global element type and <code>global</code> keyword</li>
</ul>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes</a></h3>
<ul>
<li>Special report actions now use <code>:</code> instead of <code>.</code> eg <code>report.status = 200</code> is now <code>report:status = 200</code></li>
</ul>
<h2 id="version-132"><a class="header" href="#version-132">Version 1.3.2</a></h2>
<h3 id="updates-2"><a class="header" href="#updates-2">Updates</a></h3>
<ul>
<li>New Feature: Introduction of new standard library option for loading actions in Jac with <code>std.actload_local</code> and <code>std.actload_remote</code></li>
<li>Improvement: Disallowing spawning of unlinked edges, i.e., <code>spawn --&gt; node::generic</code> not allowed without <code>here</code></li>
<li>New Feature: Random library adds random text generation lorem style with <code>rand.word()</code>, <code>rand.sentence()</code>, <code>rand.paragraph()</code>, and <code>rand.text()</code>.</li>
<li>New Feature: Standard input <code>std.input(prompt)</code> :-p</li>
<li>Improvement: Status codes auto plucked from return payload in jsserv</li>
<li>New Feature: Can now control status codes with <code>report.status = 201</code> style statements</li>
<li>Improvement: No longer saves action data into graph and keeps it in architypes</li>
<li>New Feature: Walkers can be called directly using <code>wapi/{walkername}</code> api</li>
<li>New Feature: New <code>master_allusers</code> API available for super master users</li>
<li>Improvement: Superusers now have access to all data</li>
<li>Improvement: Jaseci's admin api route changed to <code>/js_admin/...</code> vs <code>/admin/</code> to not conflict with Django's internals</li>
<li>Update: Django 3 upgraded to latest as well as all other dependencies.</li>
<li>Fix: Believe it or not, I never fully implemented <code>continue</code>. LIKE REALLY??? Anyway, fixed now. FTLOG!</li>
<li>New Feature: Added <code>jac dot</code> cli command much like <code>jac run</code> but prints dot graph</li>
<li>New Feature: Created shorthand for string, list, and dict functions i.e., <code>.s::</code>, <code>.d::</code>, and <code>.l::</code> respectively</li>
<li>New Feature: Added suite of dict manipulation functions</li>
<li>New Feature: Added suite of list manipulation functions</li>
</ul>
<h3 id="notes-2"><a class="header" href="#notes-2">Notes</a></h3>
<ul>
<li>All api calls to Jaseci admin apis using the <code>/admin/</code> route must be updated to <code>/js_admin/</code></li>
</ul>
<h2 id="version-131"><a class="header" href="#version-131">Version 1.3.1</a></h2>
<h3 id="updates-3"><a class="header" href="#updates-3">Updates</a></h3>
<ul>
<li>New Feature: File I/O Library in with json support</li>
<li>New Lang Feature: <code>.str::load_json</code> added to string library</li>
<li>Fix: Error output when key not in object or dict</li>
<li>New Lang Feature: Can now spawn root nodes in addition to generic nodes</li>
<li>Improvement: Line numbers provided for all &quot;Internal Errors&quot;</li>
<li>Fix: Dot strings now handled as expected (stripping quotes etc)</li>
<li>Improvement: General improvements to error reporting</li>
<li>Improvement: Changed meta requirement for actions to be option at hook points</li>
<li>Improvement: Now you can arbitrarily chain array indexs into function calls as per <code>std.get_report()[0]</code>.</li>
<li>New Feature: <code>std.get_report</code> gives the what is to be reported so far</li>
<li>Improvement: General polish items of JSCTL UI</li>
<li>Improvement: Raised the default core logging reporting level to warning</li>
</ul>
<h2 id="version-13"><a class="header" href="#version-13">Version 1.3</a></h2>
<h3 id="updates-4"><a class="header" href="#updates-4">Updates</a></h3>
<ul>
<li>Improvement: JSCTL now takes args without flags in sensible places for quality of life.</li>
<li>Improvement: Better Error reporting all around</li>
<li>New Feature: APIs for manipulating actions</li>
<li>New Feature: Hotloading jaseci action modules</li>
<li>Update: New action creation methodology and architecture</li>
<li>New Feature: Decorator interface for creating jaseci action modules</li>
<li>New Feature: New profiling flag added to run walker api for performance profiling</li>
<li>New Feature: Direct jac file building, test, and run from in JSCTL</li>
<li>New Language Feature: Tests and testing features as first order language semantics</li>
<li>New Lang Feature: Asserts!</li>
<li>Fix: Simplified and optimized global abilities</li>
<li>New Support Feature: Started vs code for JAC extension first beta</li>
<li>New Lang Feature: Multifile codebase support and import keyword and semantic added</li>
<li>New Lang Feature: Try-else blocks introduced for exception handling</li>
<li>New Lang Feature: Added new <code>&amp;</code> reference and <code>*</code> dereference semantic for getting psuedo-pointers to node, edges, etc</li>
<li>New Lang Feature: Massively expanded functionality with destroy and list slice management</li>
<li>New Lang Feature: can now explicitly reference and dereference graph elements (nodes, edges, etc)</li>
<li>New Lang Feature: Field filtering for dictionaries, particularly useful for context, info, details</li>
<li>New Lang Feature: Type checking primitives, and type casting primitives</li>
<li>New Lang Feature: String library finally present</li>
</ul>
<h3 id="notes-3"><a class="header" href="#notes-3">Notes</a></h3>
<ul>
<li>Various flags are now args for <code>jsctl</code> i.e., <code>walker run -name init</code> is now <code>walker run init</code> as name is now the standard arg. If you wanted to specify a node the flag would be used as per <code>walker run init -nd {uuid}</code></li>
<li>Reports back from walker is now dictionary of form <code>{'report': list(report)}</code> instead of currnet <code>list(report)</code></li>
<li><code>std.sort_by_col</code> tweaked to make last paramter a boolean for reverse (instead of string)</li>
<li>Format of <code>walker get -mode key</code> api changed from {key:namespace} to {namespace:key}</li>
<li><code>test</code> is now a keyword with added test capabilities in jaseci</li>
<li>Type, int, float, str, list, dict, bool, are now keywords, if you used these as variable names in legacy code, must make updates.</li>
<li>The destroy built-in is totally revised <code>lst.destroy(idx)</code> on lists should be changed to <code>destroy lst[idx]</code>.</li>
<li>Get_uuid standard library function is deprecated since we have string manipulation</li>
<li>Internal representation of element now <code>jac:uuid:</code> format, should not be visible to coder, <code>&amp;</code> references still produce <code>urn:uuid:</code> as strings. To dereference use new <code>*</code> dereference operators.</li>
<li>Standard, output and logging now will print proper values (e.g. json values for null, true, and false)</li>
</ul>
<h2 id="version-122"><a class="header" href="#version-122">Version 1.2.2</a></h2>
<h3 id="updates-5"><a class="header" href="#updates-5">Updates</a></h3>
<ul>
<li>New Language Feature: can now perform assignments arbitrarily (not just to named variables)</li>
<li>New Language Feature: can spawn assign on creation of nodes and edges</li>
<li>New Language Feature: can filter references to nodes and edges</li>
<li>Added new built-ins for nodes and edges (context, info, and details)</li>
<li>Fixed dot output</li>
<li>Added reset command to jsctl to clear complete state</li>
<li>Various language grammar tweaks</li>
</ul>
<h2 id="version-121"><a class="header" href="#version-121">Version 1.2.1</a></h2>
<h3 id="updates-6"><a class="header" href="#updates-6">Updates</a></h3>
<ul>
<li>Both jaseci and jaseci_serv are architected to be standalone packages</li>
<li>Stripe API integrated</li>
<li>EMails can be templated with HTML content</li>
<li>Token expiry time can be set as config through live api</li>
<li>Added auto sync to global sentinel for spawned walkers</li>
<li>FIX: Global sentinels cascade to all users on change</li>
<li>FIX: Multi pod concurrency issue corrected</li>
</ul>
<h2 id="version-120"><a class="header" href="#version-120">Version 1.2.0</a></h2>
<h3 id="updates-7"><a class="header" href="#updates-7">Updates</a></h3>
<ul>
<li>New Hierarchal user creation and management through core Jaseci</li>
<li>New version labels for Jac programs</li>
<li>New custom action for nodes and edges</li>
<li>New Jaseci server support for new API and Jaseci architecture</li>
<li>New namespaces for public walker permissions management with key access</li>
<li>New object sharing across users and access control APIs</li>
<li>New Jaseci object permissions architecture</li>
<li>New Jac library for outbound requests</li>
<li>New Globals Jac standard library and API interfaces</li>
<li>New support for server-side Jac deployments and relevant APIs</li>
<li>New Jac language updates</li>
<li>New access language features for edge manipulation and traversal</li>
<li>New code IR format and handling across Architypes and Walkers</li>
<li>New dot integration redesign</li>
<li>New added editor to JSCTL</li>
<li>New complete API redesign and deprecation of legacy APIs</li>
<li>New introduced new standard Jaseci Bible (unfinished)</li>
<li>New redesigned graphs nodes and edges to support multi-graph semantic.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-the-jaseci-open-source-project"><a class="header" href="#contributing-to-the-jaseci-open-source-project">Contributing to the Jaseci Open Source Project</a></h1>
<ul>
<li><a href="CONTRIBUTING.html#how-to-start-contributing">How to start contributing</a>
<ul>
<li><a href="CONTRIBUTING.html#working-on-a-new-feature-or-fixing-a-bug-you-found">Working on a new feature or fixing a bug you found</a></li>
<li><a href="CONTRIBUTING.html#work-on-an-existing-issue">Work on an existing issue</a></li>
</ul>
</li>
<li><a href="CONTRIBUTING.html#how-to-contribute-code">How to contribute code</a>
<ul>
<li><a href="CONTRIBUTING.html#what-is-a-pull-request--pr--">What is a Pull Request (PR)?</a></li>
<li><a href="CONTRIBUTING.html#how-to-open-a-pr-and-contribute-code-to-jaseci-open-source">How to open a PR and contribute code to Jaseci Open Source</a>
<ul>
<li><a href="CONTRIBUTING.html#1-forking-the-jaseci-repository">1. Forking the Jaseci Repository</a></li>
<li><a href="CONTRIBUTING.html#2-cloning-the-forked-repository-locally">2. Cloning the Forked Repository Locally</a></li>
<li><a href="CONTRIBUTING.html#3-update-your-forked-repository">3. Update your Forked Repository</a></li>
<li><a href="CONTRIBUTING.html#4-implement-your-code-contribution-on-a-feature-branch">4. Implement your code contribution on a feature branch</a></li>
<li><a href="CONTRIBUTING.html#5-push-changes-to-your-forked-repository-on-github">5. Push changes to your forked repository on GitHub</a></li>
<li><a href="CONTRIBUTING.html#6-opening-the-pull-request-on-jaseci-open-source">6. Opening the Pull Request on Jaseci Open Source</a></li>
<li><a href="CONTRIBUTING.html#8-merging-your-pr-and-the-final-steps-of-your-contribution">8. Merging your PR and the final steps of your contribution</a></li>
</ul>
</li>
<li><a href="CONTRIBUTING.html#things-to-know-about-creating-a-pr">Things to know about creating a PR</a>
<ul>
<li><a href="CONTRIBUTING.html#opening-issues-before-prs">Opening issues before PRs</a></li>
<li><a href="CONTRIBUTING.html#draft-work-in-progress-wip--prs">Draft/Work-in-progress(WIP) PRs</a></li>
<li><a href="CONTRIBUTING.html#code-style---linting">Code style &amp; Linting</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="CONTRIBUTING.html#how-to-update-the-official-documentation">How to Update the Official Documentation</a></li>
</ul>
<hr />
<h2 id="how-to-start-contributing"><a class="header" href="#how-to-start-contributing">How to start contributing</a></h2>
<p>Welcome to Jaseci! To start contributing, we would like you to start with issues.</p>
<h3 id="working-on-a-new-feature-or-fixing-a-bug-you-found"><a class="header" href="#working-on-a-new-feature-or-fixing-a-bug-you-found">Working on a new feature or fixing a bug you found</a></h3>
<p>If you would like to add a new feature or fix a bug you have found, we prefer that you open a new issue in the Github repo before creating a pull request.</p>
<p>It’s important to note that when opening an issue, you should first do a quick search of existing issues to make sure your suggestion hasn’t already been added as an issue.
If your issue doesn’t already exist, and you’re ready to create a new one, make sure to state what you would like to implement, improve or bugfix.</p>
<h3 id="work-on-an-existing-issue"><a class="header" href="#work-on-an-existing-issue">Work on an existing issue</a></h3>
<p>If you want to contribute code, but don't know what to work on, check out the existing list of issues</p>
<p>Certain issues are marked with the &quot;good first issue&quot; label. These are issues that we think are great for first time contributor to work on while they are still getting familarized with the Jaseci codebase.</p>
<p>To work on an existing issue, go to the issue in Github, add a comment stating you would like to work on it and include any solutions you may already have in mind. Assign the issue to yourself.</p>
<p>The Jaseci team will then work with you on the issue and the downstream pull request to guide you through merging your code into the Jaseci codebase.</p>
<hr />
<h2 id="how-to-contribute-code"><a class="header" href="#how-to-contribute-code">How to contribute code</a></h2>
<p>Code contribution will be in the form of Pull Request (PR) on Github.</p>
<h3 id="what-is-a-pull-request-pr"><a class="header" href="#what-is-a-pull-request-pr">What is a Pull Request (PR)?</a></h3>
<p>This is how the GitHub team defines a PR:</p>
<blockquote>
<p>“Pull requests let you tell others about changes you’ve pushed to a branch in a repository on GitHub. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch.”</p>
</blockquote>
<p>This process is used by both Jaseci team members and Jaseci contributors to make changes and improvements.</p>
<h3 id="how-to-open-a-pr-and-contribute-code-to-jaseci-open-source"><a class="header" href="#how-to-open-a-pr-and-contribute-code-to-jaseci-open-source">How to open a PR and contribute code to Jaseci Open Source</a></h3>
<h4 id="1-forking-the-jaseci-repository"><a class="header" href="#1-forking-the-jaseci-repository">1. Forking the Jaseci Repository</a></h4>
<p>Head to Jaseci repository and click ‘Fork’. Forking a repository creates you a copy of the project which you can edit and use to propose changes to the original project.</p>
<p>Once you fork it, a copy of the Jaseci repository will appear inside your GitHub repository list, under your username.</p>
<h4 id="2-cloning-the-forked-repository-locally"><a class="header" href="#2-cloning-the-forked-repository-locally">2. Cloning the Forked Repository Locally</a></h4>
<p>To make changes to your copy of the Jaseci repository, clone the repository on your local machine. To do that, run the following command in your terminal:</p>
<pre><code>git clone https://github.com/your_github_username/jaseci.git
</code></pre>
<p>Note: this assumes you have git installed on your local machine. If not, check out the <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">following guide</a> to learn how to install it.</p>
<h4 id="3-update-your-forked-repository"><a class="header" href="#3-update-your-forked-repository">3. Update your Forked Repository</a></h4>
<p>Before you make any changes to your cloned repository, make sure you have the latest version of the original Jaseci repository. To do that, run the following commands in your terminal:</p>
<pre><code>cd jaseci
git remote add upstream https://github.com/Jaseci-Labs/jaseci.git
git pull upstream main
</code></pre>
<p>This will update the local copy of the Jaseci repository to the latest version.</p>
<h4 id="4-implement-your-code-contribution-on-a-feature-branch"><a class="header" href="#4-implement-your-code-contribution-on-a-feature-branch">4. Implement your code contribution on a feature branch</a></h4>
<p>We recommend you to add your code contribution to a new branch (different from main). Then you can continuously run the previous step to always keep the <code>main</code> branch in your forked repo up-to-date with the original repo. This way you have the flexibility to easily inspect your changes and resolve any potential merge conflicts all within the forked repo.</p>
<pre><code>git checkout -b name-of-your-new-branch
</code></pre>
<h4 id="5-push-changes-to-your-forked-repository-on-github"><a class="header" href="#5-push-changes-to-your-forked-repository-on-github">5. Push changes to your forked repository on GitHub</a></h4>
<p>Once you are happy with the changes you made in the local files, push them to the forked repository on GitHub. To do that, run the following commands:</p>
<pre><code>git add .
git commit -m ‘fixed a bug’
git push origin name-of-your-new-branch
</code></pre>
<p>This will create a new branch on your forked Jaseci repository, and now you’re ready to create a Pull Request with your proposed changes!</p>
<h4 id="6-opening-the-pull-request-on-jaseci-open-source"><a class="header" href="#6-opening-the-pull-request-on-jaseci-open-source">6. Opening the Pull Request on Jaseci Open Source</a></h4>
<p>Head to the forked repository and click on a <em>Compare &amp; pull</em> request button.</p>
<p>This will open a window where you can choose the repository and branch you would like to propose your changes to, as well as specific details of your contribution. In the top panel menu choose the following details:</p>
<ul>
<li>Base repository: <code>Jaseci-Labs/jaseci</code></li>
<li>Base branch: <code>main</code></li>
<li>Head repository: <code>your-github-username/jaseci</code></li>
<li>Head branch: <code>name-of-your-new-branch</code></li>
</ul>
<p>Next, make sure to update the pull request card with as many details about your contribution as possible. <em>Proposed changes</em> section should contain the details of what has been fixed/implemented, and Status should reflect the status of your contributions. Any reasonable change (not like a typo) should include a changelog entry, a bug fix should have a test, a new feature should have documentation, etc.</p>
<p>Once you are happy with everything, click the <em>Create pull request</em> button. This will create a Pull Request with your proposed changes.</p>
<p>If you are ready to get feedback on your contribution from the Jaseci team, leave a comment on the PR.</p>
<h4 id="8-merging-your-pr-and-the-final-steps-of-your-contribution"><a class="header" href="#8-merging-your-pr-and-the-final-steps-of-your-contribution">8. Merging your PR and the final steps of your contribution</a></h4>
<p>A member from the Jaseci team will review your PR and might ask you to make additional changes and update. To update your PR, head back to the local copy of your repo, implement the changes requested and repeat the same steps above. Your PR will <em>automatically</em> be updated with your latest changes. Once you've implemented all of the suggested changes, tag the person who first reviewed your PR in a comment of the PR to ask them to review again.</p>
<p>Finally, if your contribution is accepted, one of the Jaseci team member will merge it to the codebase!</p>
<h3 id="things-to-know-about-creating-a-pr"><a class="header" href="#things-to-know-about-creating-a-pr">Things to know about creating a PR</a></h3>
<h4 id="opening-issues-before-prs"><a class="header" href="#opening-issues-before-prs">Opening issues before PRs</a></h4>
<p>Like, mentioned above, We recommend opening an issue before a pull request if there isn’t already an issue for the problem you’d like to solve. This helps facilitate discussions and tracking progress.</p>
<h4 id="draftwork-in-progresswip-prs"><a class="header" href="#draftwork-in-progresswip-prs">Draft/Work-in-progress(WIP) PRs</a></h4>
<p>If you're ready to get some quick initial feedback from the Jaseci team, you can create a draft pull request. You can prefix the PR title with [WIP] to indicate this is still work in progres.</p>
<h4 id="validate-your-changes-through-test"><a class="header" href="#validate-your-changes-through-test">Validate your changes through test</a></h4>
<p>Jaseci has a set of automated tests and PRs are required to pass these tests for them to be merge into the main branch. So we recommend you to validate your changes via these tests before creating a PR. Checkout <code>scripts/script_sync_code_kube_test</code> to see how to run the tests.</p>
<h4 id="code-style--linting"><a class="header" href="#code-style--linting">Code style &amp; Linting</a></h4>
<p>To standardize coding style, Jaseci code is enforeced by the flake8 linter and a set of linting rules. Please run the linting command to check your code style before creating a PR.</p>
<pre><code>flake8 --exclude=settings.py,*migrations*,jac_parse --max-line-length=88 --extend-ignore = E203,
</code></pre>
<hr />
<h2 id="how-to-update-the-official-documentation"><a class="header" href="#how-to-update-the-official-documentation">How to Update the Official Documentation</a></h2>
<p>The source of the Jaseci Official Documentation comes from the collection of <code>README.md</code> files placed in specific folders throughout the codebase. Developers and Maintainers must ensure that their contributions are properly documented according to the following procedures outlined in this section.</p>
<h3 id="adding-a-new-module-or-library"><a class="header" href="#adding-a-new-module-or-library">Adding a new module or library</a></h3>
<p>Ensure that you follow the prevailing directory sturcture convention when adding a new module or library to Jaseci. </p>
<ul>
<li>All source files belonging to your module or library must be contained within a folder bearing the non-whitespace, lowercase name of your module or library. </li>
<li>You must author a <code>README.md</code> document to describe the purpose of your module or library, any features, configurations or uses as well as code excerpts on how to implement your module's functionaliy. </li>
<li>The <code>README.md</code> must be included in the root folder of the module or library.</li>
<li>Ensure you update the related <code>README.md</code> in the subsection (if applicable) which contains your module, e.g. <code>jaseci_kit/README.md</code> as well as the main <code>README.md</code> in the root directory of the codebase to include references to your new module or library. </li>
</ul>
<h3 id="adding-a-new-code-lab-example"><a class="header" href="#adding-a-new-code-lab-example">Adding a new code lab example</a></h3>
<p>All codelabs are organized within the <code>/examples</code> folder. You may add new codelabs to this folder by following the prescribed guidelines below:</p>
<ul>
<li>Ensure that your codelab is organized within its own named folder. Ensure you use all lowercase, non-whitespace names.</li>
<li>Ensure your new codelab has its own <code>README.md</code> file placed in its root folder. This should be the main page of the documented codelab.</li>
<li>If any images are used, ensure they are stored in the <code>[your_code_lab]/assets</code> folder and referenced using relative paths.</li>
<li>Once the codelab is added, ensure that you update the main <code>README.md</code> in the root directory of the codebase to include references to your new codelab under the section &quot;Samples and Tutorials&quot;.</li>
</ul>
<h3 id="adding-a-new-guide"><a class="header" href="#adding-a-new-guide">Adding a new guide</a></h3>
<p>All informational content which do not directly refer to modules / libraries or codelabs are typically stored under the <code>/support/guide</code> folder.</p>
<ul>
<li>Ensure that your new guide is contained within its own named folder. Ensure you use all lowercase, non-whitespace names.</li>
<li>If any images are used, ensure they are stored in the <code>[your_guide]/assets</code> folder and referenced using relative paths.</li>
<li>The markdown pages of your guide must be named based on the title of the rendered page in lowercase, non-whitepsace characters, e.g. <code>this_is_my_guide.md</code>.</li>
<li>Once the guide is added, ensure that you update the main <code>README.md</code> in the root directory of the codebase to include references to your new guide under the applicable section.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped create and improve Jaseci. Big shout-out to them!</p>
<ul>
<li><a href="https://github.com/marsninja">Jason Mars (marsninja)</a></li>
<li><a href="https://github.com/ypkang">Yiping Kang (ypkang)</a></li>
<li><a href="https://github.com/AshishMahendra">Ashish Mahendra (AshishMahendra)</a></li>
<li><a href="https://github.com/king-mango">Timothy Shiwprasad (king-mango)</a></li>
<li><a href="https://github.com/Gim3l">Gimel Dick (Gim3l)</a></li>
<li><a href="https://github.com/codedbychavez">Chavez Harris (codedbychavez)</a></li>
<li><a href="https://github.com/ashagraw91">Ashish Agrawal (ashagraw91)</a></li>
<li><a href="https://github.com/SatyamRajawat">Satyam Singh (SatyamRajawat)</a></li>
<li><a href="https://github.com/amadolid">Alexie Madolid (amadolid)</a></li>
<li><a href="https://github.com/BrianLifeLogify">Brian Yang (BrianLifeLogify)</a></li>
<li><a href="https://github.com/Gorgeous-Patrick">Gorgeous-Patrick</a></li>
<li><a href="https://github.com/Shawn-Jemmott">Shawn Jemmott (Shawn-Jemmott)</a></li>
<li><a href="https://github.com/azealin">azealin</a></li>
<li><a href="https://github.com/pathakshyam">pathakshyam</a></li>
<li><a href="https://github.com/dominicbraam">dominicbraam</a></li>
<li><a href="https://github.com/ChrisIsKing">Christopher Clarke (ChrisIsKing)</a></li>
<li><a href="https://github.com/eldonm">Eldon Marks (eldonm)</a></li>
</ul>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jaseci-overview"><a class="header" href="#jaseci-overview">Jaseci Overview</a></h1>
<h2 id="what-is-jaseci"><a class="header" href="#what-is-jaseci">What is Jaseci?</a></h2>
<p>Jaseci is an end-to-end open-source and Open Computational Model, Technology Stack, and Methodology for bleeding edge AI. It enables developers to rapidly build robust products with sophisticated AI capabilities at scale.</p>
<h2 id="why-jaseci"><a class="header" href="#why-jaseci">Why Jaseci?</a></h2>
<ul>
<li>Jaseci brings application development, AI Models and code infrastructure together under a single solution stack. </li>
<li>Jaseci comes with pre-built, pre-trained AI models for most AI Related tasks out of the box.</li>
<li>Using the JAC Programming language you are able to leverage all the goodness that Jaseci has to offer such as wielding powerful AI models and exposing complex business logic via automatically generated APIs.</li>
<li>The integrated Jaseci Diffuse Runtime System handles the orchestration, configuration and optimization of the full cloud compute stack and inter-machine resources such as container formation, scaling and optimization. In essence it provides all the technology needed to develop an AI application in one platform.</li>
<li>Jaseci allows you to remove data management from your workflow with a baked-in data persistence layer.</li>
<li>Jaseci was desgined to reduce development team specializations. You'll only need a single Jaseci Engineer to do the work of DevOps Engineers, Frontend and Backend engineers and AI engineers.</li>
<li>With Jaseci's graph-based representation of data and operations, you'll be able to visualize your solutions and navigate complexity with ease.</li>
<li>Develop rapidly with Jaseci's level of abstraction and automatically generated APIs.</li>
<li>You get to focus focus on building your solution instead of reinventing the wheel.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-jaseci"><a class="header" href="#installing-jaseci">Installing Jaseci</a></h1>
<ul>
<li><a href="support/guide/getting_started/installation.html#installing-on-windows">Installing on Windows</a></li>
<li><a href="support/guide/getting_started/installation.html#installing-on-mac">Installing on Mac</a></li>
</ul>
<h2 id="installing-on-windows"><a class="header" href="#installing-on-windows">Installing on Windows</a></h2>
<h3 id="software-requirements"><a class="header" href="#software-requirements">Software Requirements</a></h3>
<ul>
<li>Ubuntu 20+</li>
<li>python 2.8 +</li>
<li>pip package manager</li>
</ul>
<p>To run commands for Jaseci we need a terminal that accepts bash arguments. We recommend using the Ubuntu terminal that comes as the default with WSL.</p>
<ol>
<li>Check if WSL is installed by running the following the Windows powershell terminal :</li>
</ol>
<p> <code>python  wsl -l -v  </code>
 This will return  the flavour of the distribution used for WSL. The version column will show the version of WSL.</p>
<ol start="2">
<li>If no version is specified open windows powershell in  adminstrator mode and install WSL by running :</li>
</ol>
<pre><code class="language-bash">  wsl --install
</code></pre>
<ol start="3">
<li>Restart your Computer</li>
</ol>
<p>4.Open the Ubuntu terminal. for more information on installation see <a href="https://docs.microsoft.com/en-us/windows/wsl/install">here.</a></p>
<p>Install Python and Pip packet Manager</p>
<ol start="5">
<li>Check version of Python and Pip by running :</li>
</ol>
<pre><code>python3 --version
pip3 --version
</code></pre>
<p>If these packages are installed they will return a version number. Move to step 7 if a version number is present.</p>
<p>6.Install Python3 and pip3 by running the following:</p>
<pre><code>sudo apt update
sudo apt install python3-dev python3-pip
</code></pre>
<p>7.Once the Python and pip packages are installed. Now to install Jaseci and Jaseci Kit</p>
<pre><code>pip install jaseci
</code></pre>
<pre><code>pip install jaseci-kit
</code></pre>
<ol start="8">
<li>To ensure our installation is working run :</li>
</ol>
<pre><code>jsctl
</code></pre>
<p>Once it shows a list of options and commands, you're installation is complete</p>
<h2 id="installing-on-mac"><a class="header" href="#installing-on-mac">Installing on Mac</a></h2>
<p>Install Python and Pip packet Manager</p>
<ol start="5">
<li>Check the version of Python and Pip by running :</li>
</ol>
<pre><code>python3 --version
pip3 --version
</code></pre>
<p>If these packages are installed they will return a version number. Move to step x if a version number is present.</p>
<p>6.Install Python3 and pip3 by running the following:</p>
<pre><code>brew update
brew install python
</code></pre>
<p>7.Once the Python and pip packages are installed. Now to install Jaseci and Jaseci Kit</p>
<pre><code>pip install jaseci
</code></pre>
<pre><code>pip install jaseci-kit
</code></pre>
<ol start="8">
<li>To ensure our installation is working run :</li>
</ol>
<pre><code>jsctl
</code></pre>
<p>Once it shows a list of options and commands, you're installation is complete.</p>
<p>Linux Installation</p>
<p>Install Python and Pip packet Manager</p>
<ol start="5">
<li>Check the version of Python and Pip by running :</li>
</ol>
<pre><code>python3 --version
pip3 --version
</code></pre>
<p>If these packages are installed they will return a version number. Move to step x if a version number is present.</p>
<p>6.Install Python3 and pip3 by running the following:</p>
<pre><code>sudo apt update
sudo apt install python3-dev python3-pip
</code></pre>
<p>7.Once the Python and pip packages are installed. Now to install Jaseci and Jaseci Kit</p>
<pre><code>pip install jaseci
</code></pre>
<pre><code>pip install jaseci-kit
</code></pre>
<ol start="8">
<li>To ensure our installation is working run :</li>
</ol>
<pre><code>jsctl
</code></pre>
<p>Once it shows a list of options and commands, your installation is complete.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-your-code-editor"><a class="header" href="#setting-up-your-code-editor">Setting up your Code Editor</a></h1>
<p>Visual Studio code is a popular IDE used by developers of all operating systems. This IDE comes with a Jac extension to aid in your coding Journey.</p>
<ol>
<li>
<p>If you already have VS code installed move to step 3. Download Visual Studio code by selecting <a href="https://code.visualstudio.com/">here</a></p>
</li>
<li>
<p>Once download is completed . Open and follow the installation instructions.</p>
</li>
<li>
<p>Once Installation is completed open VS code and install the JAC extension.</p>
</li>
<li>
<p>Go to View &gt; Command Palette . Type Install and select extensions.</p>
</li>
<li>
<p>search JAC and select it then install.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-first-app"><a class="header" href="#writing-your-first-app">Writing your first app</a></h1>
<p>Let's create a simple conversational Agent using Jaseci and Jaseci Kit. We're gonna create a Chatbot for students to sign up for Jaseci Dojo !</p>
<p>Before we begin ensure you have Jaseci and Jaseci Kit installed. If not, see the Installation <a href="support/guide/getting_started/&#x27;/installation&#x27;">here</a></p>
<p>Create a file called graph.jac. Here we are going to create the conversational flow for the chatbot .</p>
<pre><code class="language-jac">
# state is the name of the node
node state {
    has title;
    has message;
    has prompts;
}

</code></pre>
<p>Nodes can be thought of as the representation of an entity.
Nodes are the fundamental unit of  a gaph. These can be considered to be the steps in which the Walker can take.</p>
<ul>
<li>Nodes are composed of Context and excutable actions.</li>
<li>Nodes execute a set of actions upon entry and exit.
 Here we are creating a <code>node</code> of name &quot;state&quot;
The <strong>has</strong> keyword is used to declare a variable of the node.</li>
</ul>
<pre><code class="language-jac">
# state is the name of this node
node state {
    has title;
    has message;
    has prompts;
}

# transition is the name of this edge
edge transition {
    has intent;
}
</code></pre>
<p>Edges are the link between nodes. They walker will use these edges to determine the next node to traverse to.
The <strong>has</strong> key word is used to declare the variable &quot;intent&quot;. This &quot;intent&quot; is what the Walker will use to to determine which node to go to next.</p>
<pre><code class="language-jac">
# state is the name of this node
node state {
    has title;
    has message;
    has prompts;
}
# transition is the name of this edge
edge transition {
    has intent;
}

# main_graph is name of the graph
graph main_graph {

    has anchor main_root

</code></pre>
<p>The <code>graph</code> is a collection of initialized nodes. 
The <code>has anchor</code> key word is used to identify the root node. The Root node is the node where the walker's traversal begins.
The <strong>has anchor</strong> key word is used to state the root node. The Root node is the node where the walker's traversal begins.</p>
<pre><code class="language-jac"># state is the name of this node
node state {
    has title;
    has message;
    has prompts;
}

edge transition {
    has intent;
}
graph main_graph {

    has anchor main_root

spawn {
     # this is the first node in the graph.
     main_root = spawn node::state(
        title = &quot;Welcome&quot;,
        message = &quot;Welcome to Jaseci Dojo, how can i help?&quot;,
        prompts = [&quot;class&quot;,&quot;times&quot;,&quot;prices&quot;,&quot;quit&quot;]
    );


    # this creates a node that goes from main_root to class.
    prices = spawn main_root -[transition(intent=&quot;prices&quot;)] -&gt; node::state(
        title = &quot;prices&quot;,
        message = &quot;Prices Vary based on age&quot;,
        prompts = [&quot;12 and younger&quot;, &quot;18 and younger&quot; ,&quot;Older than 18&quot;, &quot;quit&quot;]
    );

    # this creates a node from the prices node to here.
     prices_12 = spawn prices -[transition(intent=&quot;12 and younger&quot;)] -&gt; node::state(
        title = &quot;prices&lt;12&quot;,
        message = &quot;Childer under 12 pay $100 per month&quot;,
        prompts = [&quot;more prices&quot;, &quot;quit&quot;]
    );

    # this create an edge from prices_12 back to prices.
     prices_12 -[transition(intent=&quot;more prices&quot;)] -&gt; prices;


}

</code></pre>
<p><code>spawn</code> is used to create to create child nodes, which is used to design flow of the conversational experience.
We are able to create additional edges to connnect nodes which which do not share a parent -child relationship. This is shown in the last line.</p>
<pre><code class="language-jac">node state {
    has title;
    has message;
    has prompts;
}


edge transition {
    has intent;
}

graph main_graph {
    has anchor main_root;

    spawn {

        main_root = spawn node::state(
        title = &quot;Welcome&quot;,
        message = &quot;Welcome to Jaseci Dojo, how can i help?&quot;,
        prompts = [&quot;class&quot;,&quot;times&quot;,&quot;prices&quot;,&quot;quit&quot;]
    );

    prices = spawn main_root -[transition(intent=&quot;prices&quot;)] -&gt; node::state(
        title = &quot;prices&quot;,
        message = &quot;Prices Vary based on age&quot;,
        prompts = [&quot;12 and younger&quot;, &quot;18 and younger&quot; ,&quot;Older than 18&quot;, &quot;quit&quot;]
    );

    prices_12 = spawn prices -[transition(intent=&quot;12 and younger&quot;)] -&gt; node::state(
        title = &quot;prices&lt;12&quot;,
        message = &quot;Childer under 12 pay $100 per month&quot;,
        prompts = [&quot;more prices&quot;, &quot;quit&quot;]
    );
     prices_12 -[transition(intent=&quot;more prices&quot;)] -&gt; prices;

     prices_18 = spawn prices -[transition(intent=&quot;18 and younger&quot;)] -&gt; node::state(
        title = &quot;prices&lt;18&quot;,
        message = &quot;Childer under 18 pay $110 per month&quot;,
        prompts = [&quot;more prices&quot;, &quot;quit&quot;]
    );

    prices_18 -[transition(intent=&quot;more prices&quot;)] -&gt; prices;

     pricesabove18 = spawn prices -[transition(intent=&quot;Older than 18&quot;)] -&gt; node::state(
        title = &quot;pricesadults&quot;,
        message = &quot;Adults over 18 pay $150 per month&quot;,
        prompts = [&quot;more prices&quot;,&quot;quit&quot;]
    );
     pricesabove18 -[transition(intent=&quot;more prices&quot;)] -&gt; prices;


    class = spawn main_root -[transition(intent=&quot;class&quot;)]-&gt; node::state(
        title = &quot;class&quot;,
        message = &quot;There are 3 classes per week and you are required to attend a minimum of 2.&quot;,
        prompts = [&quot;time&quot;,&quot;days&quot;,&quot;prices&quot;,&quot;quit&quot;]

    );



    time = spawn class -[transition(intent=&quot;time&quot;)]-&gt; node::state(
        title = &quot;time&quot;,
        message = &quot;Classes are from 3 pm to 4 pm&quot;,
        prompts = [&quot;other times&quot;,&quot;days&quot;,&quot;quit&quot;]
    );

    main_root -[transition(intent=&quot;times&quot;)] -&gt; time;

    other_time = spawn time -[transition(intent=&quot;other times&quot;)]-&gt; node::state(
        title = &quot;Other times&quot;,
        message =&quot;The clases are at 4 pm to 5 pm but you need at least 4 other students to start&quot;,
        prompts = ['days',&quot;quit&quot;]
    );




     days = spawn time -[transition(intent=&quot;days&quot;)]-&gt; node::state(
        title = &quot;days&quot;,
        message =&quot;The classes are on Monday ,Wednesday , Friday&quot;,
        prompts = ['time',&quot;quit&quot;]
    );


     other_time - [transition(intent=&quot;days&quot;)] -&gt; days ;
     days - [transition(intent=&quot;time&quot;)] -&gt; time ;

    }
}

</code></pre>
<p>This last code block we created several nodes and connected them together. To move from node to node we use the intent to sepcify which route to take.</p>
<p>Walker</p>
<ul>
<li>Walkers traverse the nodes of the graph triggering execution at the node level.</li>
</ul>
<p>Now lets create a file called walker.jac
Here is where we will create  the method for traveral of the graph.</p>
<pre><code class="language-jac">
#here we initialize the walker which we named talker.
walker talker {

    has utterance;

    state {
        #prints out the message and prompts variables for the node the walker is currently on
        std.out(here.message,here.prompts);

        #here we take the input from the terminal.
        utterance =  std.input(&quot;&gt; &quot;);

        #if the user enters &quot;quit&quot; the programs ends.
        if(utterance==&quot;quit&quot;): disengage;

        #checks the utterance and determine which node to traverse too.
        take -[transition(intent==utterance )] -&gt; node::state else{
            take here ;
        }
    }

}

</code></pre>
<p>The Walker will start from the main root and from the utterance intered it will determine which node to go to next.
It should be noted the utterance must match the prompts chosen or the walker will not move from the graph.
Jaseci-kit has features that makes it possible for users to not enter the exact intent but still traverse to the right node.</p>
<p>Main</p>
<p>Create a file named main.jac .</p>
<pre><code class="language-jac"># import the graph and walker made earlier.
import {*} with &quot;./graph.jac&quot;;
import {*} with &quot;./walker.jac&quot;;

# this walker is reponsible for starting the program.
walker init {

    root {
        #creates an instant of the graph
        spawn here --&gt; graph::main_graph;

        #creates an instance of the walker, talker
        spawn  --&gt; walker::talker;
    }


}

</code></pre>
<p>Once we run main.jac we can use the Chatbot. Play around with graph and add your own nodes and link other nodes together to create an even better chatbot.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-jac-programs"><a class="header" href="#understanding-jac-programs">Understanding JAC Programs</a></h1>
<p>JAC Programs are authored by the JAC language which is used to define structure and behaviour. Behaviour can be modeled in the form of actions and abilities within node elements of the graph as well as walker elements which are specifically designed to traverse the nodes and edges of a graph. Structure can be modeled by arranging a number of nodes and edges in a particular manner, compelte with state, to form a graph. </p>
<p>When a JAC program executes, the structural and behavioral definitions encoded in JAC are registered with the Jaseci Runtime Machine in the form of a Sentinel. Named Walkers may then be launched on a graph via an API call. </p>
<p>Walkers may be designed to report their output. Reports come back via API once a walker has completed its walk, these reports will be a json payload of objects.</p>
<p>Graphs comprise nodes and edges. Nodes have abilities that can be activated when a walker travers on it. The Walker traverse the graph and decides which paths to take by using the edges. </p>
<p>All traversal begins at the Init or default node. This <code>init</code> node will connect to the main root of our graph.</p>
<p><img src="support/guide/getting_started/../assets/root_node.png" alt="Pic of Main Root" /></p>
<p>The Walkers are initialized and added on the root node and from there they begin traveral.
The walkers decide which node to travel to based on which edge satisfies it's intent. The intent being a criteria meet by the edge.</p>
<p><img src="support/guide/getting_started/../assets/graph.png" alt="Pic of Nodes and Edges" /> </p>
<p>The Walker can move from node to node along edges. It can also be spawned directly on any node without the need for a traversal</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-overview-of-the-jac-language"><a class="header" href="#an-overview-of-the-jac-language">An Overview of the JAC Language</a></h1>
<p>JAC is the official programming language of Jaseci, specifically designed for developers to author the computational logic which governs the various Jaseci constructs such as libraries, walkers, nodes, edges and graphs. Syntactically, JAC draws from JavaScript and Python but it brings a variety of graph-based operators and expressions that go with the unique development paradigm of Jaseci.</p>
<p>To get acquainted with JAC, you'll first have to understand its various constructs which are governed by the language. Here's an overview of the Jaseci constructs and related terms:</p>
<h3 id="action"><a class="header" href="#action">Action</a></h3>
<ul>
<li>Actions are computational processing elements. </li>
<li>Actions take in a list of context items as input and outputs one or many context items. </li>
<li>All possible actions are provided by Jaseci. </li>
<li>Actions attached to nodes, edges, etc will search walker, itself, then higher dimentional nodes for input contexts in that order,</li>
</ul>
<h3 id="context"><a class="header" href="#context">Context</a></h3>
<ul>
<li>Context is a list of one or more key-value pairs. </li>
</ul>
<h3 id="nodes-and-hd-graph-domains-and-planes"><a class="header" href="#nodes-and-hd-graph-domains-and-planes">Nodes and HD Graph Domains and Planes</a></h3>
<ul>
<li>Nodes are composed of context and executable actions. </li>
<li>Nodes accumulate context via a push function, context can be read as well. </li>
<li>Nodes execute a set of actions upon: 
<ol>
<li>Entry </li>
<li>Exit </li>
</ol>
</li>
<li>Activity actions in a node denote actions that a walker can call at any time</li>
<li>Nodes must be aware of the set of HDGDs of which it is a member. </li>
<li>Nodes must trigger processing of HDGDs of which it is a member upon events. 
<ul>
<li>Seperate actions at the HDGDs above can occur on entry and exit events </li>
</ul>
</li>
<li>At the first dimension, these are essentially subsets of nodes for which there are common traits. Traits can include context both static and dynamic (built over time) or actions to be executed upon []
<ol>
<li>entry from some edge into the domain from another domain at the given dimensionality,</li>
<li>edge traversals within a domain, or</li>
<li>exits out of the domain to antoher domain at the domains given dimensionality.</li>
</ol>
</li>
<li>At higher dimensions, these HDGDs are comprised of HDGDs of the next dimension down and function similarly with the element case but instead of nodes they comprise of HDGDs. (HDGD_2 is a graph comprised of HDGD_1 graphs)</li>
<li>Transitions at a given dimension can only occur between domains of that dimension or to non-domain nodes.</li>
<li>HDGDs can overlap at a given dimension.</li>
<li>Each domain at any dimensionality has a root node.</li>
<li>Transitions at the node level trigger computation in parallel at all dimensions of HDGDs for which that node is a member of.</li>
<li>Optional:
<ul>
<li>Upon creation of an edge between nodes that is first to span HDGD bounderies at any dimensionality, an edge is created implicity betwen HDGDs at that dimensionality (these edges function exactly like edges between nodes). At this point the edges can carry context and actions.</li>
<li>Upon deletion of an edge between nodes that is the last to span HDGD bounderies at any dimensionality, the edge that was created connecting those HDGDs is deleted.</li>
<li>Nodes have an anchor context value that is used to represent the 'value' of the node, for example when deciding which outbound node a walker should take based on some evaluation. Each node can select only one element from context to be it's anchor</li>
</ul>
</li>
</ul>
<h3 id="edges"><a class="header" href="#edges">Edges</a></h3>
<ul>
<li>Edges are composed of context and executable actions </li>
<li>Edges accumulate context via a push function, context can be read as well </li>
<li>Edges execute a set of actions when traversed. </li>
<li>Edges much be aware of the set of HDGDs of which it is a member. </li>
<li>Edges crossing HDGD boundaries must trigger higher order HDGD plane edges. </li>
</ul>
<h3 id="walkers"><a class="header" href="#walkers">Walkers</a></h3>
<ul>
<li>Walkers walk nodes triggering execution at the node level and HDGD levels.</li>
<li>Walkers can pick up context as they traverse.</li>
<li>Walkers also decide which node to travel through next and records the path of travel (trail) to be recorded within it's own context.</li>
<li>Walkers can be spawned at any node.</li>
<li>Walkers can spawn other walkers.</li>
<li>Computation happens at the Node and HDGD levels. However walkers make decisions on where to walk next and which context to pick up.</li>
<li>Walker context must be preloaded by sentinel or applications as a form of input and configuration for the walk</li>
<li>Walkers can carry with them their own actions and contexts that is executed whenever specified in the walkers own code</li>
</ul>
<h3 id="sentinels"><a class="header" href="#sentinels">Sentinels</a></h3>
<ul>
<li>Sentinels watch walkers, aggregate outcomes of walking, and enact policies.</li>
<li>Each walker must have a sentinel and the division of labor is
<ol>
<li>Walkers are concerned primarily for walking the graph.</li>
<li>Sentinels will take the results of one or more walkers to perform some higher order objective (i.e., resolution)</li>
</ol>
</li>
<li>Keeps context that can be used to save derivitave application behavior.</li>
<li>Sentials harbor walkers, architype and jac programs that encode walkers and architypes</li>
<li>Sentials can 'register' Jac programs which is a sort of compile that will generate architypes and walkers</li>
<li>If the program has syntax errors registration fails, once registered walkers fail at runtime</li>
</ul>
<h3 id="architypes"><a class="header" href="#architypes">Architypes</a></h3>
<ul>
<li>Registers templatized version of instances of any Jaseci abstractions or collections of instances (e.g., subgraphs, etc)</li>
</ul>
<h3 id="graph"><a class="header" href="#graph">Graph</a></h3>
<ul>
<li>A graph is a root node (inhereted from node) and manages sentinels, and higher dimentional nodes</li>
</ul>
<h3 id="masters"><a class="header" href="#masters">Masters</a></h3>
<ul>
<li>This is the center of management of a jaseci instance that orchestrates the manipulation of graphs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jac-grammar"><a class="header" href="#jac-grammar">JAC Grammar</a></h1>
<pre><code>program     : element*

element     : architype
            : walker

architype   : KW:NODE (COLON INT)? ID LBRACE attr_stmts RBRACE
            : KW:EDGE ID LBRACE attr_stmts RBRACE

walker      : KW:WALKER ID code_block

statements  : statement*

statement   : architype
            : walker
            : code_block
            : node_code
            : expression SEMI
            : if_stmt
            : for_stmt
            : while_stmt

code_block  : LBRACE statements RBRACE
            : COLON statement SEMI

node_code   : dotted_name code_block

expression  : dotted_name EQ expression
            : compare (KW:AND|KW:OR compare)*

if_stmt     : KW:IF expr code_block (elif_stmt)* (else_stmt)*

for_stmt    : KW:FOR expression KW:TO experssion KY:BY expression code_block

while_stmt  : KW:WHILE expression code_block

attr_stmts  : attr_stmt*

dotted_name : ID (DOT ID)*

compare     : NOT compare
            : arithmetic ((EE|LT|GT|LTE|GTE) arithmetic)*

attr_stmt   : KW:HAS ID (, ID)* SEMI
            : KW:CAN dotted_name (, dotted_name)* SEMI
            : arch_set SEMI

arch_set    : KW:NAME EQ expression
            : KW:KIND EQ expression

arithmetic  : term ((PLUS|MINUS) term)*

term        : factor ((MUL|DIV) factor)*

factor      : (PLUS|MINUS) factor
            : power

power       : func_call (POW factor)*

func_call   : atom (LPAREN (expression (COMMA expression)*)? RPAREN)?

atom        : INT|FLOAT|STRING
            : dotted_name (LSQUARE expression RSQUARE)*
            : LPAREN expr RPAREN
            : list</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<h2 id="arthimetic"><a class="header" href="#arthimetic">Arthimetic</a></h2>
<pre><code class="language-jac">// addition
a = 4 + 4;
e = a + b + c + d;

// multiplication
b = 4 * -5;

// division
c = 4 / 4;  # Returns a floating point number

// subtraction
d = 4 - 6;

// exponent / power
a = 4 ^ 4;

// modulus
b = 9 % 5

</code></pre>
<h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<pre><code class="language-jac">// equal
a == b

// not equal
a != b

// less than
a &lt; b

// greater than
a &gt; b

// less than and equal to
a &lt;= b

// greater than and equal to
a &gt;= b
</code></pre>
<h2 id="logical"><a class="header" href="#logical">Logical</a></h2>
<pre><code class="language-jac">// not
!a,

// and
a &amp;&amp; b
a and b

// or
a || b
a or b

// mixture
!a or b
!(a and b)
</code></pre>
<h2 id="assigments"><a class="header" href="#assigments">Assigments</a></h2>
<pre><code class="language-jac">a = 4 + 4;
a += 4 + 4;
a -= 4 * -5;
a *= 4 / 4;
a /= 4 - 6;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<h2 id="select-statement"><a class="header" href="#select-statement">Select Statement</a></h2>
<pre><code class="language-jac"># simple If statement
walker init {
    x = 3.56;
    y = &quot;X is not equal to 3.45&quot;;

    if (x ==3.45) {
        std.out(x);
    }
    elif (x==3.56){
        std.out(&quot;it's a match&quot;);
    }
     else {
        std.out(y);
    }
}

</code></pre>
<p>Other Conditional statements like &lt; , &gt; ,!= , &quot;and&quot; and &quot;or&quot; are also supported.</p>
<h2 id="for-and-while-loop"><a class="header" href="#for-and-while-loop">For and While loop</a></h2>
<p>Loops are written similiar to python it run a specific amount of time as in the case of the &quot;For&quot; loop or until a condition is meet as in the case for the &quot;While&quot; loop.</p>
<pre><code class="language-jac">walker init {
    # the for loop
    for i=0 to i&lt;10 by i+=1:
        std.out(i)

    #the while loop
    while(x&lt;10){
        std.out(x);
        x = x +1;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>Collection refers to dictionary , lists ...</p>
<h2 id="dictionary"><a class="header" href="#dictionary">Dictionary</a></h2>
<pre><code class="language-jac">
dict = {
    'name' : 'John',
    'height_in_ft' : 6.8,
    'employed' : True
    
} ;

</code></pre>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<pre><code class="language-jac">AI_modesl  = ['use_qa','use_enc','bi_enc'];
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nodes"><a class="header" href="#nodes">Nodes</a></h1>
<p>Nodes are the building blocks of any JAC program. Nodes are the destinations of Walkers. Nodes have abilities which are similar to functions in python. These abilities can be triggered when walkers traverse on to or leave the Node or even triggered by the Walker if needed. 
Nodes can be created to serve different functions. All Nodes are linked together in a graph by edges.</p>
<p>A node is a representation of an entity.</p>
<ul>
<li>Nodes are composed of Context and excetuable actions.</li>
<li>Nodes accumulate context via a push function, context can be read ass well</li>
<li>Nodes can execute a set of actions upon entry and exit.</li>
</ul>
<h2 id="defining-node-attributes"><a class="header" href="#defining-node-attributes">Defining Node Attributes</a></h2>
<p>Attributes are variables within the node.</p>
<pre><code class="language-jac">node [name of node]{
    # to declare an attribute we uses the [has] keyword followed by the attribute name.
    has variable;
    # to use a module from jaseci kit
    can use_qa;
}
</code></pre>
<h2 id="adding-abilities"><a class="header" href="#adding-abilities">Adding abilities</a></h2>
<p>Functions in JAC are avalibale to Nodes only. They are called Abilities instead of Functions.These abilities can be activated when a walker travers over a node . Abilities can be triggered when a Walker first traverse over a node , leaves a node , triggered by the walker or when a specific walker enter or leaves a node.</p>
<p>Abilities in nodes can be declared as followed:</p>
<pre><code class="language-jac">node state {
  # any walker can use ability
  can ability6 {
    # execute some code
  }
  # Walker enters a node 
    can ability  entry {
        #execute some code.
    }
    # Walker exits a node 
    can ability2  exit {
        # execute some code 
    }
    
    # specific walker enters
    can ability3 with walker1 entry {
        # execute some code
    }

    # specific walker exits
    can ability4 walker1 exits {

    }

    # only specifc walker can use ability 
    can ability5 walker2 {
        # code to execute
    }
}

</code></pre>
<h2 id="inheritance-on-nodes"><a class="header" href="#inheritance-on-nodes">Inheritance on Nodes</a></h2>
<p>Nodes can inherit abilities and attributes of other nodes. </p>
<pre><code class="language-jac"># parent node 

node state {
    has title;
    has message;
    has prompts;
}

# inherits attributes from state node.
node input_state:state {
    has input;
}

# inherits attributes from input_state.
node output_state :input:state{
    has output;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="edges-1"><a class="header" href="#edges-1">Edges</a></h1>
<p>Edges are the links that connect nodes to each other</p>
<ul>
<li>Edges associate one node with another by way of a uni-directional or bidirectional path definition.</li>
<li>Edges are composed of context and executable actions.</li>
<li>Edges accumulate context via a push function, context can be read as well.</li>
<li>Edges execute a set of actions when traversed.</li>
<li>Edges much be aware of the set of HDGDs of which it is a member.</li>
<li>Edges crossing HDGD boundaries must trigger higher order HDGD plane edges.</li>
</ul>
<pre><code class="language-jac">edge [name of edge] {
    has variable;
}

</code></pre>
<h2 id="linking-nodes-together-with-an-edge"><a class="header" href="#linking-nodes-together-with-an-edge">Linking Nodes together with an Edge</a></h2>
<pre><code class="language-jac">
node state {
    has context;
}

edge transition {
    has intent ;
}

graph main {
    has anchor main_root ; 

    # create nodes here with the edges linking them.
    spawn {
        main_root = spawn node:: state(context=&quot;main node&quot;);

        # create node that connects to main_root
        node_one = spawn main_root -[transition(intent=&quot;one&quot;)] -&gt; node::state(context=&quot;node one&quot;);

        
        # connect node that connects to node_one
        node_two  = spawn node_one -[transition(intent=&quot;two&quot;)] -&gt; node::state(context=&quot;node two&quot;);

    }

}

</code></pre>
<h2 id="inheritance-on-edges"><a class="header" href="#inheritance-on-edges">Inheritance on Edges</a></h2>
<p>Edges can inherit abilities and attributes of other edges.</p>
<pre><code class="language-jac"># parent edge 
edge transition {
    has transition_next ;
}
# child edge
edge transition_back: transition {
    has prev_step ;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphs"><a class="header" href="#graphs">Graphs</a></h1>
<ul>
<li>Graphs are an arrangement of nodes and edges</li>
</ul>
<pre><code class="language-jac">graph [name of graph] {
    this is the root node of the graph
    has anchor [name of anchor];

    #here is where we start to connect nodes with edges creating a graph.
    spawn{
        # declare your nodes in here 

     }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="walkers-1"><a class="header" href="#walkers-1">Walkers</a></h1>
<ul>
<li>Walkers traverse nodes triggering execution at the node level.</li>
<li>Walkers have the ability to pick upand retain context, which can be taken across nodes.</li>
<li>Walkers also decides which node to travel to through next and records the path of travel to b recorded within it's own context.</li>
<li>Walkers can be spawned at any node</li>
<li>Walker can spawn other walkers.</li>
<li>Walkers can carry with them their own actions and contexts that is executed whenever specified in the walkers own code</li>
</ul>
<h2 id="defining-a-walker"><a class="header" href="#defining-a-walker">Defining a Walker</a></h2>
<pre><code class="language-jac"> walker [name_of_walker]{

}
</code></pre>
<p>Defining specific node code to execute When defining a walker, you also write specific code blocks that will only execute when the walker is on a specific node.</p>
<pre><code class="language-jac"> walker [name_of_walker]{
    [Any code here is executed regardless of the node the walker is on]
    ...
    ...

    person{
     [Any code within this block will only be executed when the walker is on a person node]
   }

   ...

   family{
    [Any code within this block will only be executed when the walker is on a family node]
   }

}
</code></pre>
<h2 id="more-on-behaivour-with-abilities"><a class="header" href="#more-on-behaivour-with-abilities">More on Behaivour with Abilities</a></h2>
<h3 id="with-entry-and-exit"><a class="header" href="#with-entry-and-exit">With Entry and Exit</a></h3>
<p>When defining a walker, you also have the ability to write specific code blocks that execute if and only if a walker enters or exists a node. Any code within the with_entry block is the first thing that executes as soon as a walker enter a node. And the opposite is true for with_exit, triggering only when the walker is about to leave a node.</p>
<pre><code class="language-jac">walker [name_of_walker]{
    with entry{
        [code to execute when a walker first enters a node]
    }
    ...
    ...

    with exit{
        [code to execute when a walker is about to leave a node]
    }
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traversing-a-graph"><a class="header" href="#traversing-a-graph">Traversing a Graph</a></h1>
<ul>
<li>Take is used for nodes/Edge trversal in a walker </li>
<li>Only until all other walker logic is executed, then all queued up take operations are executed.</li>
<li>An operation would tell the walker to move/traverse on to the next node with the given filter provided when using take.</li>
<li>When using the take command, you have the ability to filter by edges or edges that have a specific node attached.</li>
</ul>
<p>Consider the following diagram</p>
<p><img src="support/guide/jac_language_guide/../assets/take.png" alt="Diagram of a road map" /></p>
<p>The take command performs a breath first search to add take operations to the queue. Let's define a walker that traverses the various nodes and prints the node data. We'll assume this walker spawns and starts from the root <code>node 0</code>.</p>
<p><strong>Traversing to a generic node from a walker</strong></p>
<pre><code class="language-jac">// generic definition of the nodes. Nodes of type 'myNode' will have a 'data' property

node myNode: has anchor data;

walker myWalker{
    myNode{
        take --&gt;;
        std.out(here.data);
    }
}
</code></pre>
<p>With the assumption that this walker starts from <code>node 0</code>, this is how the take operations are queued and executed.</p>
<p><img src="support/guide/jac_language_guide/../assets/take-2.png" alt="Diagram of a road map" /></p>
<p>Upon spawning, the walker executes whatever logic it has to when on node of type myNode and in the logic of the above code snippet, the walker executes a take operation then prints the node data.</p>
<p>However, due to the way the take command works, the data is first printed before any traversal occurs. This is becasue the take command is asynchronous and doesn't execute right away. Instead, it queues up any traversal that needs to occur, executes any logic that come after the take command and once that is complete, dequeues and executes the next operation, which would be the traversal to node1.</p>
<p><img src="support/guide/jac_language_guide/../assets/take-3.png" alt="Diagram of a road map" /></p>
<p>At node 1 the walker executes a similar logic, queuing up nodes 3 and 4 then printing the value of node 1 before any traversal. Once that logic is finished, it checks the end of the queue for the next operation, which in this case would be traversal to node 2.</p>
<p><img src="support/guide/jac_language_guide/../assets/take-4.png" alt="Diagram of a road map" /></p>
<p>This process continues until the queue is empty or the walker is killed.</p>
<p><strong>Basic traversal using take</strong></p>
<pre><code class="language-jac">walker testWalker{
    node_type{
        take --&gt;;
    }
}

 walker testWalker2{
    node_type{
        take &lt;--;
    }
}
</code></pre>
<p><strong>Traversing to a specific type of node from a walker</strong></p>
<pre><code class="language-jac">walker testWalker{
    node_type{
        take --&gt; node::node_type;
    }
}

//node of type person as the filter

walker testWalker2{
    school{
        take --&gt; node::person;
    }
}
</code></pre>
<p>Take also allows the use of an else statement, should there be no edges with the filter specified in the take command.</p>
<p><strong>Executing alternative logic should there be no edges with the take filter</strong></p>
<pre><code class="language-jac">walker testWalker{
    node_type{
        take [some filter] else {

            // some additional logic if edge of filter not found
        }
    }
}

//traverse to friend edge, else print 'no friends found'

walker testWalker2{
    person{
        take -[friend]-&gt; else{;
            std.out('no friends found');
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="referencing-a-node-in-context"><a class="header" href="#referencing-a-node-in-context">Referencing a Node in Context</a></h1>
<p>The <code>here</code> keyword is used reference the node the walker is currently on.</p>
<pre><code class="language-jac">walker talker {
    has utterance;

    state {
        #the message and prompts attribute of the current node will be printed
        std.out(here.message, here.prompts);

        utterance = std.input(&quot;&gt; &quot;);

        if(utterance == &quot;quit&quot;): disengage;

        take -[transition(intent == utterance)]-&gt; node::state else {
            take here;
        }
    }
}

</code></pre>
<p>The <code>visitor</code> keyword is used to reference attributes of the walker from the node it is currently on.</p>
<pre><code class="language-jac">node state{
    has prev_value;

    can getvalue with talker entry {
        here.prev_value = visitor.value;
        std.out(here.prev_value);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="passing-arguments"><a class="header" href="#passing-arguments">Passing Arguments</a></h1>
<p>You can pass arguments to walkers , Nodes and Edges, in a similar way as passing arguments to functions in python.</p>
<h3 id="passing-arguments-to-walkers"><a class="header" href="#passing-arguments-to-walkers">Passing Arguments to Walkers</a></h3>
<pre><code class="language-jac">walker talker {
    has name;
    has value;

}

spawn::talker(name=&quot;Jaseci&quot; ,value = 10);
</code></pre>
<h3 id="passing-arguments-to-nodes"><a class="header" href="#passing-arguments-to-nodes">Passing Arguments to Nodes</a></h3>
<pre><code class="language-jac">node::calculator(first_number, second_number);
</code></pre>
<h3 id="passing-arguments-to-edges"><a class="header" href="#passing-arguments-to-edges">Passing arguments to Edges</a></h3>
<pre><code class="language-jac"># edge named transittion with argument orperation
[transition(operation)]-&gt; node ;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specifying-operating-context"><a class="header" href="#specifying-operating-context">Specifying Operating Context</a></h1>
<p>Several types Of  Nodes can be created and each can  have several unique abilities. The abilities of specific nodes can be activated when a walkers traverese on to it . This can be done by specifying an operating context. This allows a walker to execute any of the nodes ability that it is currently on. The operating context of each type of node must be specified for it to be used.</p>
<pre><code class="language-jac">node state {
    has title;
    has message;
    has prompts;
}

node input_state:state {
    has input;
}

node closing_state:state;

edge transition {
    has intent;
}

walker talker {

state, input_state{

    #execute code specific to the state and input_state nodes

    input_state{

        #These operating context can be embedded within other operating context.
        
    }

}

closing_state{
 
    #execute code specific to  closing_state nodes

}

}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actions-in-jaseci"><a class="header" href="#actions-in-jaseci">Actions in Jaseci</a></h1>
<ul>
<li>Actions are computational processing elements. </li>
<li>Actions take in a list of context items as input and outputs one or many context items.</li>
<li>All possible actions are provided by Jaseci. </li>
<li>Actions attached to nodes, edges, etc will search walker, itself, then higher dimentional nodes for input contexts in that order.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="date-actions"><a class="header" href="#date-actions">Date Actions</a></h1>
<p>Jaseci has it's own set of built-in Date Functions </p>
<h3 id="quantize-to-year"><a class="header" href="#quantize-to-year">Quantize to Year</a></h3>
<pre><code class="language-jac">#take a standard python datetime string and extract the year out of it accordingly

x = '2021-12-12';
z = date.quantize_to_year(x);
std.out(z);

</code></pre>
<h3 id="quantize-to-month"><a class="header" href="#quantize-to-month">Quantize to Month</a></h3>
<pre><code class="language-jac">#take a standard python datetime string and extract the month out of it accordingly
x = '2021-12-12';
z = date.quantize_to_month(x);
std.out(z);

</code></pre>
<h3 id="quantive-to-week"><a class="header" href="#quantive-to-week">Quantive to Week</a></h3>
<pre><code class="language-jac">#take a standard python datetime string and extract the month out of it accordingly
x = '2021-12-12';
z = date.quantize_to_week(x)
std.out(z);
</code></pre>
<h3 id="quantize-to-day"><a class="header" href="#quantize-to-day">Quantize to day</a></h3>
<pre><code class="language-jac">#take a standard python datetime string and extract the day out of it accordingly

x = '2021-12-12';
z = date.quantize_to_day(x);
std.out(z);
</code></pre>
<h3 id="date-difference"><a class="header" href="#date-difference">Date Difference</a></h3>
<pre><code class="language-jac">#t akes two datetime string and returns an integer that is the number of days in between the two given dates.

z = date.date_day_diff('2021-12-12','2022-12-12');
std.out(z);
</code></pre>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-actions"><a class="header" href="#file-actions">File Actions</a></h1>
<h3 id="load-file-to-string"><a class="header" href="#load-file-to-string">Load file to string</a></h3>
<pre><code class="language-jac"># Converts file to string , max_chars is set to none by default
Testfile = file.load_str(test.txt, max_chars = 1000)
</code></pre>
<h3 id="load-json-file-to-dictionary"><a class="header" href="#load-json-file-to-dictionary">Load Json file to dictionary</a></h3>
<pre><code class="language-jac"># Loads json from file to dictionary format
TestJson = file.load_json(test.json)
</code></pre>
<h3 id="string-to-file"><a class="header" href="#string-to-file">String to file</a></h3>
<pre><code class="language-jac"># dumps string in to file
test = &quot;This is a test of the dump_str method
Testfile = file.dump_str(&quot;text.txt&quot;,test)
</code></pre>
<h3 id="append-string-to-a-file"><a class="header" href="#append-string-to-a-file">Append string to a file</a></h3>
<pre><code class="language-jac"># appending a string to a file.
test = &quot;This is a another test but with  the append_str method
Testfile = file.append_str(str, max_chars = 1000)
</code></pre>
<h3 id="create-json-file"><a class="header" href="#create-json-file">Create Json File</a></h3>
<pre><code class="language-jac"># dump dictionary in to json file
test = {
    &quot;name&quot;: &quot;test&quot;,
    &quot;method&quot; : &quot;dump_json&quot;,
    &quot;use&quot; : &quot;dumps dictionary to json file&quot;
}
Testfile = file.dump_json(&quot;text.json&quot;,test)
</code></pre>
<h3 id="delete-file"><a class="header" href="#delete-file">Delete file</a></h3>
<pre><code class="language-jac">#delete any file 
file.delete(&quot;text.txt&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="net-actions"><a class="header" href="#net-actions">Net Actions</a></h1>
<h3 id="max-anchor-value"><a class="header" href="#max-anchor-value">Max Anchor Value</a></h3>
<pre><code class="language-jac"># returns object (node,edge) with the highest  anchor value
node year {
    has_anchor year_num;
}

jacset  = [year1,year2,year3];
value = net.max(jac_set)
</code></pre>
<h3 id="minimum-anchor-value"><a class="header" href="#minimum-anchor-value">Minimum Anchor Value</a></h3>
<pre><code class="language-jac"># returns object (node,edges) with the lowest anchor value
node year {
  
    has_anchor year_num;
}

jacset  = [year1,year2,year3];
value = net.min(jac_set)
</code></pre>
<h3 id="get-node-root"><a class="header" href="#get-node-root">Get Node Root</a></h3>
<pre><code class="language-jac"># returns root node of a given graph 
node year {
    has_anchor year_num;
}

jacset  = [year1,year2,year3];
value = net.root(jac_set)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rand-actions"><a class="header" href="#rand-actions">Rand Actions</a></h1>
<h3 id="seeds-random-number-generator"><a class="header" href="#seeds-random-number-generator">Seeds random number generator</a></h3>
<pre><code class="language-jac"># seeds random num generator
rand.seed(4);

</code></pre>
<h3 id="generate-random-generator"><a class="header" href="#generate-random-generator">Generate random generator</a></h3>
<pre><code class="language-jac"># Generates random integer between range (0-10)
num = rand.integer(0, 10);
</code></pre>
<h3 id="random-selection"><a class="header" href="#random-selection">Random Selection</a></h3>
<pre><code class="language-jac">a_list = ['apple','mango','orange']
# Randomly selects and return item from list
num = rand.choice(a_list);
</code></pre>
<h3 id="generate-random-word"><a class="header" href="#generate-random-word">Generate Random Word</a></h3>
<pre><code class="language-jac"># generate a random word
 wrd = rand.word();
</code></pre>
<h3 id="generate-random-sentence"><a class="header" href="#generate-random-sentence">Generate Random Sentence</a></h3>
<pre><code class="language-jac"># generates a random sentence
# min_lenght - optional , minimum amount of words defaut is 4
# max_lenght - optional ,  maximum amount of words default is 10
# sen - optional
senetence  = rand.sentence();
</code></pre>
<h3 id="generate-random-paragraph"><a class="header" href="#generate-random-paragraph">Generate Random Paragraph</a></h3>
<pre><code class="language-jac"># generates a random paragraph
# min_lenght - optional , minimum amount of setences defaut is 4
# max_lenght - optional ,  maximum amount of sentences default is 8
# sen - optional
paragraph = rand.paragraph();
</code></pre>
<h3 id="generate-random-text"><a class="header" href="#generate-random-text">Generate Random Text</a></h3>
<pre><code class="language-jac"># generates a random text
# min_lenght - optional , minimum amount of paragraph ,defaut is 3
# max_lenght - optional ,  maximum amount of paragraph default is 6
# sen - optional
 test  = rand.text();
</code></pre>
<h3 id="generate-time"><a class="header" href="#generate-time">Generate time</a></h3>
<pre><code class="language-jac"># Generate a random datetime between range.

returned time = rand.time(&quot;2020-10-25&quot;, &quot;2020-11-26);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="request-actions"><a class="header" href="#request-actions">Request Actions</a></h1>
<p>Jaseci allows for in-code use of common request methods.</p>
<h3 id="get-request"><a class="header" href="#get-request">Get Request</a></h3>
<pre><code class="language-jac"># make get request 
# url : string  - url to where the request will be made 
# data : dictionary - data being sent that will be converetd to json.
# header : dicionary -  header data 
response = request.get(url ,data , headers)
</code></pre>
<h3 id="post-request"><a class="header" href="#post-request">Post Request</a></h3>
<pre><code class="language-jac"># make post request 
# url : string  - url to where the request will be made 
# data : dictionary - data being sent that will be converetd to json.
# header : dicionary -  header data 
response = request.post(url ,data , headers)
</code></pre>
<h3 id="put-request"><a class="header" href="#put-request">Put Request</a></h3>
<pre><code class="language-jac"># make put request 
# url : string  - url to where the request will be made 
# data : dictionary - data being sent that will be converetd to json.
# header : dicionary -  header data 
response = request.put(url ,data , headers)
</code></pre>
<h3 id="delete-request"><a class="header" href="#delete-request">Delete Request</a></h3>
<pre><code class="language-jac"># make delete request 
# url : string  - url to where the request will be made 
# data : dictionary - data being sent that will be converetd to json.
# header : dicionary -  header data 
response = request.delete(url ,data , headers)
</code></pre>
<h3 id="head-request"><a class="header" href="#head-request">Head Request</a></h3>
<pre><code class="language-jac"># make head request , returns header of  a get request alone
# url : string  - url to where the request will be made 
# data : dictionary - data being sent that will be converetd to json.
# header : dicionary -  header data 
response = request.head(url ,data , headers)
</code></pre>
<h3 id="option-request"><a class="header" href="#option-request">Option Request</a></h3>
<pre><code class="language-jac"># make options request , requests permitted communications options fror a given url or server.
# url : string  - url to where the request will be made 
# data : dictionary - data being sent that will be converetd to json.
# header : dicionary -  header data 
response = request.get(url ,data , headers)
</code></pre>
<h3 id="file-upload"><a class="header" href="#file-upload">File upload</a></h3>
<pre><code class="language-jac"># used to upload a file or files
# url : string  - url to where the request will be made 
# file : single base64 encoded file
# files : list of base64 encode files.
# header : dicionary -  header data 
response = request.multipart_base64(url ,file , headers)
</code></pre>
<h3 id="download-file"><a class="header" href="#download-file">Download File</a></h3>
<pre><code class="language-jac"># url : string  - url to where the request will be made 
# header : dicionary -  header data 
# encoding : strign - file format , default is utf-8
downloaded_file = request.file_download_base64(url,header,encoding)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-actions"><a class="header" href="#standard-actions">Standard Actions</a></h1>
<h3 id="logging-output"><a class="header" href="#logging-output">Logging output</a></h3>
<pre><code class="language-jac">
# printing output to log
data = {
    &quot;type&quot; : &quot;String&quot;,
    &quot;name&quot; : &quot;Jaseci&quot;
}
result  = std.log(data)

</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><code class="language-jac">data = {
    &quot;type&quot; : &quot;String&quot;,
    &quot;name&quot; : &quot;Jaseci&quot;
}

# print on to the termnial
std.out(data)

</code></pre>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<pre><code class="language-jac"># takes input from the terminal 
# any string passed will be printed on to the screen
std.input(&quot;&gt; &quot;)
</code></pre>
<h3 id="standar-error"><a class="header" href="#standar-error">Standar Error</a></h3>
<pre><code class="language-jac"># printing to standard error

std.eer()

</code></pre>
<h3 id="sort-columns"><a class="header" href="#sort-columns">Sort Columns</a></h3>
<pre><code class="language-jac"># Sorts in place list of lists by column
# Param 1 - list
# Param 2 - col number (optional)
# Param 3 - boolean as to whether things should be reversed (optional)
#Return - Sorted list
sorted_list = std.sort_by_col(param1,param2)

</code></pre>
<h3 id="utc-time"><a class="header" href="#utc-time">UTC time</a></h3>
<pre><code class="language-jac"># Get utc date time for now in iso format
time  = std.time_now()

</code></pre>
<h3 id="set-global-variable"><a class="header" href="#set-global-variable">Set Global Variable</a></h3>
<pre><code class="language-jac">
# set global varibale visible to all walker
# name : string
# value : value (must be json seriaziable)

global_variable = std.set_global(name,value);

</code></pre>
<h3 id="get-global-variable"><a class="header" href="#get-global-variable">Get Global Variable</a></h3>
<pre><code class="language-jac"># get global variable
# name : name of variable
global_variable = std.get_global(name);

</code></pre>
<h3 id="load-local-actions-to-jaseci"><a class="header" href="#load-local-actions-to-jaseci">Load local actions to Jaseci</a></h3>
<pre><code class="language-jac"># load local actions date to jaseci
action = std.actload_local(&quot;date.py&quot;);

</code></pre>
<h3 id="load-remote-actions-to-jaseci"><a class="header" href="#load-remote-actions-to-jaseci">Load remote actions to Jaseci</a></h3>
<pre><code class="language-jac">action = std.actload_remote(url)

</code></pre>
<h3 id="load-module-actions-to-jaseci"><a class="header" href="#load-module-actions-to-jaseci">Load module actions to Jaseci</a></h3>
<pre><code class="language-jac">#load use_qa model
action = std.actload_module('use_qa');
</code></pre>
<h3 id="destroy-global"><a class="header" href="#destroy-global">Destroy Global</a></h3>
<pre><code class="language-jac">global = std.destroy_global(name)
</code></pre>
<h3 id="set-object-permission"><a class="header" href="#set-object-permission">Set object Permission</a></h3>
<pre><code class="language-jac">element - target element
mode - valid permission (public, private, read_only)
object = std.set_perms(element,mode)
</code></pre>
<h3 id="get-object-permission"><a class="header" href="#get-object-permission">Get object Permission</a></h3>
<pre><code class="language-jac">#Returns object access mode for any Jaseci object
# object - target element
# Return - Sorted list

obj = std.get_perms(object);
</code></pre>
<h3 id="grant-object-permission"><a class="header" href="#grant-object-permission">Grant object Permission</a></h3>
<pre><code class="language-jac"># grants another user permission to access a jaseci object
# obj :target element
# element : master to be granted permission
# readonly : Boolean read-only flag
# Returns sorted list

object  = std.grant_perms(obj,element,readonly)
</code></pre>
<h3 id="revoke-permission"><a class="header" href="#revoke-permission">Revoke Permission</a></h3>
<pre><code class="language-jac"># Remove permission for user to access a jaseci object
# obj : target element
# element : master to be revoke permission
# return sorted list
objects = std.revoke_perms(obj,element);
</code></pre>
<h3 id="get-report"><a class="header" href="#get-report">Get Report</a></h3>
<pre><code class="language-jac"># Get current report so far from walker run

reprt = std.get_report();

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector-actions"><a class="header" href="#vector-actions">Vector Actions</a></h1>
<h3 id="cosine-similarity"><a class="header" href="#cosine-similarity">Cosine Similarity</a></h3>
<pre><code class="language-jac">#Calculate the Cosine similarity score between 2 vectors.
# return float betweeen  0 and 1 
# vectora :list
# vectorb : list 
similarity = vector.cosine_sim(vectora, vectorb);

</code></pre>
<h3 id="dot-product"><a class="header" href="#dot-product">Dot Product</a></h3>
<pre><code class="language-jac"># Calculate the dot product between 2 vectors.
# return float betweeen  0 and 1 
# vectora :list
# vectorb : list

dot_product = vector.dot_product(vectora,vectorb);
</code></pre>
<h3 id="centroid"><a class="header" href="#centroid">Centroid</a></h3>
<pre><code class="language-jac"># Calculate the centroid of the given list of vectors.
# list of vectors
# returns [centroid vectors , cluster tightness]

centroid  = vector.get_centroid(vectors);
</code></pre>
<h3 id="softmax"><a class="header" href="#softmax">Softmax</a></h3>
<pre><code class="language-jac"># calculate the softmax value 
# returns list 
# vectors : dictionary
values = vectors.softmax(vectors);

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jaseci-actions"><a class="header" href="#jaseci-actions">Jaseci Actions</a></h1>
<h2 id="alias"><a class="header" href="#alias">Alias</a></h2>
<p>Alias provides names  for long string like UUIDs.</p>
<h3 id="register-alias"><a class="header" href="#register-alias">Register Alias</a></h3>
<pre><code class="language-jac">#name (str): The name for the alias created by caller.
#value (str): The value for that name to map to (i.e., UUID)
response  = jaseci.alias_register(name,value);

</code></pre>
<h3 id="list-aliases"><a class="header" href="#list-aliases">List Aliases</a></h3>
<pre><code class="language-jac"># List all string to string alias that caller can use
jaseci.alias_list()

</code></pre>
<h3 id="delete-alias"><a class="header" href="#delete-alias">Delete Alias</a></h3>
<pre><code class="language-jac"># Delete an active string to string alias mapping
# name (str): The name for the alias to be removed from caller.
jaseci.alias_delete()
</code></pre>
<h3 id="clear-alias"><a class="header" href="#clear-alias">Clear Alias</a></h3>
<pre><code class="language-jac">#  Removes  all aliases.
jaseci.alias_clear()

</code></pre>
<h2 id="objects"><a class="header" href="#objects">Objects</a></h2>
<h3 id="get-global-variable-1"><a class="header" href="#get-global-variable-1">Get global Variable</a></h3>
<pre><code class="language-jac"># name: name of global variable
value = jaseci.global_get(name);

</code></pre>
<h3 id="object-details"><a class="header" href="#object-details">Object Details</a></h3>
<pre><code class="language-jac"># retuen detail of jaseci object
object : element - jaseci object
details = jaseci.object_get(object);
</code></pre>
<h3 id="object-access-mode"><a class="header" href="#object-access-mode">Object Access Mode</a></h3>
<pre><code class="language-jac"># Get the object access mode for any jaseci object.
# object : element - jaseci object
accessMode  = jaseci.object_perms_set(object)

</code></pre>
<h3 id="set-object-access-mode"><a class="header" href="#set-object-access-mode">Set Object access mode</a></h3>
<pre><code class="language-jac"># valid perms = [&quot;public&quot;, &quot;private&quot;, &quot;read_only&quot;]
# object : element - jaseci object
# perm : string 
jaseci.object_perms_set(element,perm);
</code></pre>
<h3 id="object-access-grant"><a class="header" href="#object-access-grant">Object access grant</a></h3>
<pre><code class="language-jac"># grants one object the acess to another object
# object : element - object to access
# master : element  - object to gain access

rent = jaseci.object_perms_grant(element, master);

</code></pre>
<h3 id="revoke-object-access"><a class="header" href="#revoke-object-access">Revoke object access</a></h3>
<pre><code class="language-jac">#Remove permissions for user to access a Jaseci object
# object : element - object that was  accessed
# master : element  - object that has access.
ret = jaseci.object_perms_revoke(element,master);

</code></pre>
<h2 id="graphs-1"><a class="header" href="#graphs-1">Graphs</a></h2>
<h3 id="create-graph"><a class="header" href="#create-graph">Create Graph</a></h3>
<pre><code class="language-jac"># Create a graph instance and return root node graph object
jaseci.graph_create()

</code></pre>
<h3 id="get-graph-content"><a class="header" href="#get-graph-content">Get Graph Content</a></h3>
<pre><code class="language-jac"># Return the content of the graph with mode
# Valid modes: {default, dot, }
# gph :graph - graph whose conten you need
# mode : string - &quot;deafult&quot; or &quot;dot&quot; , &quot;default&quot; by default
Contents = jaseci.graph_get(gph);

</code></pre>
<h3 id="list-graph-objects"><a class="header" href="#list-graph-objects">List Graph Objects</a></h3>
<pre><code class="language-jac">#  Provide complete list of all graph objects (list of root node objects)
# detailed : boolean - if eac graph details are wanted
graph_info = jaseci.graph_list(detailed);

</code></pre>
<h3 id="set-default-graph"><a class="header" href="#set-default-graph">Set Default Graph</a></h3>
<pre><code class="language-jac"># set the default graph master should use
# gph : graph - graph to be default.
message = jaseci.graph_active_set(gph);

</code></pre>
<h3 id="remove-default-graph"><a class="header" href="#remove-default-graph">Remove Default Graph</a></h3>
<pre><code class="language-jac"># Unsets the default sentinel master should use
jaseci.graph_active_unset();
</code></pre>
<h3 id="get-default-graph"><a class="header" href="#get-default-graph">Get Default Graph</a></h3>
<pre><code class="language-jac"># detailed : boolean - default false , true to return graph details (optional)
grph = jaseci.graph_active_get()
</code></pre>
<h3 id="delete-graph"><a class="header" href="#delete-graph">Delete Graph</a></h3>
<pre><code class="language-jac"># permantely  delete graph 
# grph : graph - graph to be deleted

message = jaseci.graph_delete(grph);
</code></pre>
<h3 id="return-node-value"><a class="header" href="#return-node-value">Return Node Value</a></h3>
<pre><code class="language-jac"># returns value of a given node
# nd : node : node whose value will be returned.
node_value =  jaseci.graph_node_get(nd);
</code></pre>
<h3 id="set-node-value"><a class="header" href="#set-node-value">Set Node Value</a></h3>
<pre><code class="language-jac"># Assigns values to member variables of a given node using ctx object
# nd : node : node to who a value will be assigned.
# ctx : dictionary - values to assign 

node_details = jaseci.graph_node_set(nd,ctx);
</code></pre>
<h2 id="sentinels-1"><a class="header" href="#sentinels-1">Sentinels</a></h2>
<h3 id="register-sentinel"><a class="header" href="#register-sentinel">Register Sentinel</a></h3>
<pre><code class="language-jac">#Create blank or code loaded sentinel and return object
# name: str -  &quot;default&quot; when not specified,
#encoded: bool 
#auto_run: Auto_run is the walker to execute on register (assumes active graph is selected), default is &quot;init&quot;
#ctx: dict = {},
#set_active: bool = True,

sentel = jaseci.sentinel_regsiter(name,encoded,auto_run,ctx,set_active);

</code></pre>
<h3 id="global-sentinel"><a class="header" href="#global-sentinel">Global Sentinel</a></h3>
<pre><code class="language-jac">#   Copies global sentinel to local master
#set_active : boolean - set sentinel to be active
# on_demand : boolean - 

sentl = jaseci.sentinel_pull(set_active);
</code></pre>
<h3 id="get-sentinel"><a class="header" href="#get-sentinel">Get Sentinel</a></h3>
<pre><code class="language-jac"># Get a sentinel rendered with specific mode
#Valid modes: {default, code, ir, }
#snt : sentinel : sentinel to be rendered in specific mode.
#mode : str - mode sentinel will be in 
snt  = jaseci.sentinel_get(snt,mode);
</code></pre>
<h3 id="set-sentinel-code"><a class="header" href="#set-sentinel-code">Set Sentinel Code</a></h3>
<pre><code class="language-jac"># Set code/ir for a sentinel, only replaces walkers/archs in sentinel
# Needs more clarity
jaseci.sentinel_set();
</code></pre>
<h3 id="sentinel-list"><a class="header" href="#sentinel-list">Sentinel List</a></h3>
<pre><code class="language-jac"># Provides Completed list of all sentinel objects 

#snt_list = jaseci.sentinel_list();
</code></pre>
<h3 id="sentinel-test"><a class="header" href="#sentinel-test">Sentinel Test</a></h3>
<pre><code class="language-jac"># Run battery of test cases within sentinel and provide result
#snt : sentinel - sentinel to be tested

snt_details = jaseci.sentinel_test(snt);
</code></pre>
<h3 id="default-sentinel"><a class="header" href="#default-sentinel">Default Sentinel</a></h3>
<pre><code class="language-jac"># Sets the default sentinel master should use
#snt :sentinel - sentinel to be made default

message = jaseci.sentinel_active_set(snt);
</code></pre>
<h3 id="remove-default-sentinel"><a class="header" href="#remove-default-sentinel">Remove Default Sentinel</a></h3>
<pre><code class="language-jac"># Unsets the default sentinel master should use
messsage = jaseci.sentinel_active_unset();
</code></pre>
<h3 id="set-global-sentinel"><a class="header" href="#set-global-sentinel">Set Global Sentinel</a></h3>
<pre><code class="language-jac"># Sets the default master sentinel to the global sentinel
response  = jaseci.sentinel_active_global();
</code></pre>
<h3 id="return-default-sentinel"><a class="header" href="#return-default-sentinel">Return default Sentinel</a></h3>
<pre><code class="language-jac">#  Returns the default sentinel master is using
response = jaseci.sentinel_active_get();
</code></pre>
<h3 id="delete-sentinel"><a class="header" href="#delete-sentinel">Delete Sentinel</a></h3>
<pre><code class="language-jac"># Permanently delete sentinel with given id
snt : sentinel - sentinel to be deleted

message = jaseci.sentinel_delete(snt);
</code></pre>
<h3 id="run-walker"><a class="header" href="#run-walker">Run Walker</a></h3>
<pre><code class="language-jac"># clarity needed
# Run a walker on a specific node
# wlk : walker - walker to be ran 
# nd : node -  node where walker will be placed
# ctx : dictionary  - context for walker
response  = jaseci.walker_summon()
</code></pre>
<h3 id="register-walker"><a class="header" href="#register-walker">Register Walker</a></h3>
<pre><code class="language-jac"># clarity needed
#  Create blank or code loaded walker and return object
walker_seralized = jaseci.walker_register();
</code></pre>
<h3 id="get-walker"><a class="header" href="#get-walker">Get Walker</a></h3>
<pre><code class="language-jac"># Get a walker rendered with specific mode
# wlk : walker - walker to be rendered 
# mode : str - mode to return walker
#  Valid modes: {default, code, ir, keys, }
wlk_response = jaseci.walker_get(wlk,mode);
</code></pre>
<h3 id="set-walker-code"><a class="header" href="#set-walker-code">Set Walker code</a></h3>
<pre><code class="language-jac">#  Set code/ir for a walker
# Valid modes: {code, ir, }
# wlk :walker - walker code/ir to be set
# code : str - &quot;code&quot; or  &quot;ir&quot; 
message = jaseci..walker_set(wlk,code);
</code></pre>
<h3 id="list-walkers"><a class="header" href="#list-walkers">List Walkers</a></h3>
<pre><code class="language-jac"># List walkers known to sentinel
snt :sentinel - active sentinel

walkers = jaseci.walker_list();

</code></pre>
<h3 id="delete-walker"><a class="header" href="#delete-walker">Delete Walker</a></h3>
<pre><code class="language-jac"># Permantely delete walker with given id 
# wlk : walker - walker to be deleted
# snt : sentinel - sentinel where walker resides
message = jaseci.walker_delete(wlk,snt);
</code></pre>
<h3 id="spawn-walker"><a class="header" href="#spawn-walker">Spawn Walker</a></h3>
<pre><code class="language-jac">#  Creates new instance of walker and returns new walker object
# name : str - name of walker
# snt : sentinel - sentinel the walker will be under
spawn_wlk = jaseci.walker_spawn_create(name,snt);
</code></pre>
<h3 id="delete-spawned-walker"><a class="header" href="#delete-spawned-walker">Delete spawned Walker</a></h3>
<pre><code class="language-jac">#Delete instance of walker 
# name : string - name of walker to be deleted
jaseci.walker_spawn_delete(name);
</code></pre>
<h3 id="list-spawned-walker"><a class="header" href="#list-spawned-walker">List Spawned walker</a></h3>
<pre><code class="language-jac"># List walkers spawned by master
# detailed : boolean - return details of walkers
walkers  = jaseci.walker_spawn_list(deatailed);
</code></pre>
<h3 id="assign-walker-to-node"><a class="header" href="#assign-walker-to-node">Assign walker to node</a></h3>
<pre><code class="language-jac">#  Assigns walker to a graph node and primes walker for execution 
# wlk : walker  - walker to be assigned
# nd : node - node walker will be assigned too
# ctx : dicionary  - context for node

message   = jaseci.walker_prime(wlk,nd,ctx);
</code></pre>
<h3 id="execute-walker"><a class="header" href="#execute-walker">Execute Walker</a></h3>
<pre><code class="language-jac"># execute walker assuming it is primed.
# wlk : walker -  walker to execute
# nd : node - node where execution will begin

response  = jaseci.walker_execute(wlk,nd);
</code></pre>
<h3 id="walker-run"><a class="header" href="#walker-run">Walker run</a></h3>
<pre><code class="language-jac"># Creates walker instance, primes walker on node, executes walker, reports results, and cleans up walker instance.
#name: str - name of the walker 
#nd: node = Node walker will be primed on 
#ctx: dict -  {} by default
#snt: sentinel - None  by default 
#profiling: bool - False by default

response =  jaseci.walker_run(name,nd,ctx,snt,profiling);
</code></pre>
<h3 id="walker-individual-apis"><a class="header" href="#walker-individual-apis">Walker Individual APIs</a></h3>
<pre><code class="language-jac">#name : string - name of walker
#nd :node - node walker will be primed on
# ctx : dictionary - dictionary for context information
# snt :  sentinel , none by default
# profiling : boolean , false by default
 response = jaseci.wapi(name,nd,ctx);
</code></pre>
<h2 id="architypes-1"><a class="header" href="#architypes-1">Architypes</a></h2>
<h3 id="create-architype"><a class="header" href="#create-architype">Create Architype</a></h3>
<pre><code class="language-jac"># code : string : the test or filename  for an architype jac code
#encoded : boolean : if code is encoded or not
# snt (uuid) : the uuid of the sentinel to be the owner of this architype

architype_response  = jaseci.architype_register(code,encoded,snt);

</code></pre>
<h3 id="get-architype"><a class="header" href="#get-architype">Get Architype</a></h3>
<pre><code class="language-jac"># Get an architype rendered with specific mode
# arch : architype - the architype being accessed
# mode : string - valid modes {default, code, ir}
# detailed : boolean - return detailed info also

architpe_serialized   = jaseci.architype_get(arch,mode,detailed);
</code></pre>
<h3 id="set-architype-code-or-ir"><a class="header" href="#set-architype-code-or-ir">Set Architype code or ir</a></h3>
<pre><code class="language-jac">#arch (uuid): The architype being set
#code (str): The text (or filename) for an architypes Jac code/ir
#mode (str): Valid modes: {default, code, ir, }

response  = jaseci.architype_set(arch,code,mode);
</code></pre>
<h3 id="list-architype"><a class="header" href="#list-architype">List Architype</a></h3>
<pre><code class="language-jac"># List architypes know to sentinel
#snt (uuid): The sentinel for which to list its architypes
# detailed (bool): Flag to give summary or complete set of fields

archs = jaseci.architype_list(snt,detailled);
</code></pre>
<h3 id="delete-architype"><a class="header" href="#delete-architype">Delete Architype</a></h3>
<pre><code class="language-jac"># Permanently delete sentinel with given id
#arch (uuid): The architype being set
#snt (uuid): The sentinel for which to list its architypes

response = jaseci.architype_delete(arch,snt);
</code></pre>
<h2 id="masters-1"><a class="header" href="#masters-1">Masters</a></h2>
<h3 id="create-master"><a class="header" href="#create-master">Create Master</a></h3>
<pre><code class="language-jac"># create a master instance and retrun root node master object 
# name  :str - name of master
# active : boolean 
# ctx : dictionary - additional feilds for overloaded interfaces

master_object  = jaseci.master_create(name,active,ctx);
</code></pre>
<h3 id="get-master-content"><a class="header" href="#get-master-content">Get Master Content</a></h3>
<pre><code class="language-jac"># return the content of the master with mode
# name : string - name of master to be returned
# mode : string - modes{'default',}

master_object = jaseci.master_get(name,mode);
</code></pre>
<h3 id="list-masters"><a class="header" href="#list-masters">List Masters</a></h3>
<pre><code class="language-jac">#  Provide complete list of all master objects (list of root node objects)
# detailed : boolean - detailed info wanted. 

masters  = jaseci.master_list(detailed);
</code></pre>
<h4 id="set-default-master"><a class="header" href="#set-default-master">Set Default Master</a></h4>
<pre><code class="language-jac">#  Sets the default sentinel  master should use
# name  : name of master to be set

response  = jaseci.master_active_set(name);
</code></pre>
<h3 id="unset-default-master"><a class="header" href="#unset-default-master">Unset Default Master</a></h3>
<pre><code class="language-jac"># unsets the default sentinel mastershould use
response  = jaseci.master_active_unset();
</code></pre>
<h3 id="get-default-master"><a class="header" href="#get-default-master">Get Default Master</a></h3>
<pre><code class="language-jac">#  Returns the default master master is using
# detailed : boolean  - return detailed information on the master

master_serialized = jaseci.master_active_get(detailed);
</code></pre>
<h3 id="get-master-object"><a class="header" href="#get-master-object">Get Master Object</a></h3>
<pre><code class="language-jac"># Returns the masters object

master_object = jaseci.master_self();
</code></pre>
<h3 id="delete-master"><a class="header" href="#delete-master">Delete Master</a></h3>
<pre><code class="language-jac">name : str - master to be deleted

response   = jaseci.master_delete(name);
</code></pre>
<h2 id="logger"><a class="header" href="#logger">Logger</a></h2>
<p>APIs for Jaseci Logging configuration</p>
<h3 id="connect-to-internal-logger"><a class="header" href="#connect-to-internal-logger">Connect to internal logger</a></h3>
<pre><code class="language-jac">#   Connects internal logging to http(s) (log msgs sent via POSTs)
#  Valid log params: {sys, app, all }
# host : string  - 
# port : string - 
# url : string - 
# log : string  - 
response = jaseci.logger_http_connect(host,port,url,log);
</code></pre>
<h3 id="remove-http-handler"><a class="header" href="#remove-http-handler">Remove HTTP Handler</a></h3>
<pre><code class="language-jac"># log  : string - default ,all

response  = jaseci.logger_http_clear(log);

</code></pre>
<h3 id="check-active-logger"><a class="header" href="#check-active-logger">Check Active logger</a></h3>
<pre><code class="language-jac">#  list active loggers

response = jaseci.logger_list();
</code></pre>
<h2 id="global-api"><a class="header" href="#global-api">Global API</a></h2>
<h3 id="set-global"><a class="header" href="#set-global">Set Global</a></h3>
<pre><code class="language-jac"># Set a global variable 
# name  : string - name of global
# value : string -  value of global
 response = jaseci.global_set(name,value);
</code></pre>
<h3 id="delete-global"><a class="header" href="#delete-global">Delete Global</a></h3>
<pre><code class="language-jac"># delete a global
# name : string - delete globals
response = jaseci.global_delete(name);
</code></pre>
<h3 id="set-global-sentinel-1"><a class="header" href="#set-global-sentinel-1">Set Global Sentinel</a></h3>
<pre><code class="language-jac"># set sentinel as  globally accessible
# snt : sentinel -  sentinel to be set globally accessible
response = jaseci.global_sentinel_set(snt);
</code></pre>
<h3 id="unset-global-sentinel"><a class="header" href="#unset-global-sentinel">Unset Global Sentinel</a></h3>
<pre><code class="language-jac">#unset globally accessible variable
# snt : sentinel - sentinel to be removed as globally acccessible 
response  = jaseci.sentinel_unset(snt);
</code></pre>
<h2 id="super-master"><a class="header" href="#super-master">Super Master</a></h2>
<h3 id="super-instance-of-master"><a class="header" href="#super-instance-of-master">Super Instance of Master</a></h3>
<pre><code class="language-jac">#   Create a super instance and return root node super object
# name : string - name of master
# set_active : boolean - set master to active
# other_fields : dictionary - used for additional feilds for overloaded interfaces (i.e., Dango interface)

master_object  = jaseci.master_createsuper(name,set_active,other_fields);
</code></pre>
<h3 id="masters-info"><a class="header" href="#masters-info">Masters info</a></h3>
<pre><code class="language-jac">#  Returns info on a set of users
# num : int -  specifies the number of users to return 
# start_idx :int -  specfies where to start

# in development 
</code></pre>
<h3 id="set-default-master-1"><a class="header" href="#set-default-master-1">Set Default Master</a></h3>
<pre><code class="language-jac"># Sets the default master master should use
# mast : master - master to be used
response  = jaseci.master_become(mast);
</code></pre>
<h3 id="unset--default-master"><a class="header" href="#unset--default-master">Unset  default Master</a></h3>
<pre><code class="language-jac"># Unsets the default master master should useS
response = jaseci.master_become();
</code></pre>
<h2 id="stripe"><a class="header" href="#stripe">Stripe</a></h2>
<p>Set of APIs to expose Stripe Management</p>
<h3 id="create-product"><a class="header" href="#create-product">Create Product</a></h3>
<pre><code class="language-jac"># name : string - default &quot;VIP Plan&quot;
# description : string - default &quot; Plan description&quot;

message = jaseci.stripe_product_create(name,desciption);
</code></pre>
<h3 id="modify-product-price"><a class="header" href="#modify-product-price">Modify Product Price</a></h3>
<pre><code class="language-jac"># productId : string - id of product to be modified 
# amount : float - amount for product ,default is 50
# interval : string - default  &quot;month&quot;

message = jaseci.stripe_product_price_set(productId,amount,interval);
</code></pre>
<h3 id="list-products"><a class="header" href="#list-products">List Products</a></h3>
<pre><code class="language-jac"># retrieve all products
# detailed : boolean - details of all products
 product_list = jaseci.stripe_product_list();
</code></pre>
<h3 id="create-customer"><a class="header" href="#create-customer">Create Customer</a></h3>
<pre><code class="language-jac"># paymentId : string - id of payment method
# name : string - name of customer 
# email : string - email of customer
# description : string  - description of customer

message =  jaseci.stripe_customer_create(paymentId,name,email,description);
</code></pre>
<h3 id="get-customer-information"><a class="header" href="#get-customer-information">Get Customer Information</a></h3>
<pre><code class="language-jac"># retrieve customer information
#customerId : string - id to identify customer

message = jaseci.stripe_customer_get(customerId);
</code></pre>
<h3 id="add-customer-payment-method"><a class="header" href="#add-customer-payment-method">Add Customer Payment Method</a></h3>
<pre><code class="language-jac"># paymentMethodId : string - id of payment method
# customerId  : string - id to uniquely identify customer 
message = jaseci.stripe_customer_payment_add(paymentId,customerId);
</code></pre>
<h3 id="remove-customer-payment-method"><a class="header" href="#remove-customer-payment-method">Remove Customer Payment method</a></h3>
<pre><code class="language-jac">
# paymentMethodId : string - id of payment method

message = jaseci.stripe_customer_payment_delete(paymentId);
</code></pre>
<h3 id="customers-list-of-payment-method"><a class="header" href="#customers-list-of-payment-method">Customer's List of payment Method</a></h3>
<pre><code class="language-jac"># get list of customer payment method
# customerId : string - id to uniquely identify customer

payment_methods = jaseci.stripe_customer_payment_get(customerId);
</code></pre>
<h3 id="update-customer-default-payment"><a class="header" href="#update-customer-default-payment">Update Customer default payment</a></h3>
<pre><code class="language-jac"># paymentMethodId : string - id of payment method
# customerId  : string - id to uniquely identify customer 

message = jaseci.stripe_customer_payment_default(customeId,paymentMethodId);
</code></pre>
<h3 id="create-customer-subscription"><a class="header" href="#create-customer-subscription">Create Customer Subscription</a></h3>
<pre><code class="language-jac"># create customer subscription
# paymentId : string - id pf payment method
# priceId : string - id for price 
# customerId: string - id to uniquely identify customer 

message = jaseci.stripe_subscription_create(paymentId,priceId,customerId);
</code></pre>
<h3 id="cancel-customer-subscription"><a class="header" href="#cancel-customer-subscription">Cancel Customer Subscription</a></h3>
<pre><code class="language-jac"># subscriptionId : string - id to uniquley identify subscription
message  = jaseci.stripe_subscription_delete(subscriptionId);
</code></pre>
<h3 id="get-customer-subscription"><a class="header" href="#get-customer-subscription">Get Customer Subscription</a></h3>
<pre><code class="language-jac"># retrieve customer subscription 
# customerId : string - id to uniquely identify customer

customer_subscription = jaseci.stripe_subscription_get(customerId);
</code></pre>
<h3 id="invoice-list"><a class="header" href="#invoice-list">Invoice List</a></h3>
<pre><code class="language-jac"># retrieve customer list of invoices
# customerId : string - id to uniquely identify customer`
# subscriptionId : string - id to uniquley identify subscription
# limit : int - max amount of invoices to return
# lastitem : string - id of item from where the return should start default is &quot; &quot; 

invoices = jaseci.stripe_invoice_list(customerId,subscriptionId,limit,lastitem);
</code></pre>
<h3 id="load-actions"><a class="header" href="#load-actions">Load actions</a></h3>
<h2 id="load-modules-locally"><a class="header" href="#load-modules-locally">Load modules locally</a></h2>
<pre><code class="language-jac"># hot load a python module and assimlate any jaseci action
# file  string - module to be loaded
success_message  = jaseci.actions_load_local(file);
</code></pre>
<h3 id="load-modules-remote"><a class="header" href="#load-modules-remote">Load modules remote</a></h3>
<pre><code class="language-jac">#  Hot load an actions set from live pod at URL
# url : string - link to module to be loaded
success_message = jaseci.actions_load_remote(url);
</code></pre>
<h3 id="load-modules-local"><a class="header" href="#load-modules-local">Load modules local</a></h3>
<pre><code class="language-jac">mod : string - name of module to be loaded

success_messsage = jaseci,actions_load_module(mod);
</code></pre>
<h3 id="list-actions"><a class="header" href="#list-actions">List actions</a></h3>
<pre><code class="language-jac">actions = jaseci.actions_list();
</code></pre>
<h2 id="configurations-apis"><a class="header" href="#configurations-apis">Configurations APIs</a></h2>
<h3 id="get-config"><a class="header" href="#get-config">Get config</a></h3>
<pre><code class="language-jac"># get a Connfig
# name : string - name of configurations
# do_check : boolean - deafult is True

confid_details = jaseci.config_get(name,do_check);
</code></pre>
<h3 id="set-config"><a class="header" href="#set-config">Set Config</a></h3>
<pre><code class="language-jac"># name :string - name of configuration
# value : string - value to set 
# do_check : boolean - deafult is True

config_details = jaseci.config_set(name,value,do_check);
</code></pre>
<h3 id="list-config"><a class="header" href="#list-config">List Config</a></h3>
<pre><code class="language-jac">
configs = jaseci.config_list();
</code></pre>
<h3 id="list-valid-config"><a class="header" href="#list-valid-config">List Valid Config</a></h3>
<pre><code class="language-jac">
valid_configs = jaseci.config_index();
</code></pre>
<h3 id="configuration-exits"><a class="header" href="#configuration-exits">Configuration exits</a></h3>
<pre><code class="language-jac"># name : string - name of configuration
config_exist = jaseci.config_exists(name);
</code></pre>
<h3 id="delete-configurations"><a class="header" href="#delete-configurations">Delete Configurations</a></h3>
<pre><code class="language-jac">#name : string
# do_check : boolean - deafult is True

message = jaseci.config_delete(name,do_check);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci"><a class="header" href="#build-a-conversational-ai-system-in-jaseci">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h1>
<h2 id="what-are-we-building"><a class="header" href="#what-are-we-building">What are we building?</a></h2>
<p>We are building a Conversational AI.</p>
<h3 id="what-is-a-conversational-ai-agent"><a class="header" href="#what-is-a-conversational-ai-agent">What is a Conversational AI agent?</a></h3>
<p>Conversational AI is a type of artificial intelligence that enables consumers to interact with computer applications the way they would with other humans.</p>
<h3 id="real-world-examples-of-conversational-ai"><a class="header" href="#real-world-examples-of-conversational-ai">Real world examples of conversational AI</a></h3>
<ul>
<li>Amazon Alexa (Voice) </li>
</ul>
<p><img src="https://imageio.forbes.com/specials-images/imageserve/6022e0a7644b9ab003f0dcb7/iPhone-screenshots-of-the-Alexa-app-s-new-Light-and-Dark-modes/960x0.jpg?format=jpg&amp;width=700" alt="Amazon Alexa (Voice) " /></p>
<ul>
<li>Example of a text-based chatbot ( Website )</li>
</ul>
<p><img src="https://cdn2.hubspot.net/hubfs/4056626/BotHomePage.png" alt="Example of a text-based chatbot" /></p>
<h2 id="what-ai-will-be-used"><a class="header" href="#what-ai-will-be-used">What AI will be used</a></h2>
<h3 id="we-will-use-the-following-ai-capabilities"><a class="header" href="#we-will-use-the-following-ai-capabilities">We will use the following AI capabilities:</a></h3>
<h3 id="intent-classification"><a class="header" href="#intent-classification">Intent Classification</a></h3>
<h4 id="what-is-intent-classification"><a class="header" href="#what-is-intent-classification">What is Intent Classification?</a></h4>
<p>Intent classification (Text classification) is the process of assigning tags or categories to text according to its content. It's one of the fundamental tasks in Natural Language Processing (NLP) with broad applications such as sentiment analysis, topic labeling, spam detection, and intent detection.</p>
<h4 id="a-simple-diagram-illustrating-the-input-and-output-of-intent-classification"><a class="header" href="#a-simple-diagram-illustrating-the-input-and-output-of-intent-classification">A (simple) diagram illustrating the input and output of Intent Classification</a></h4>
<p><img src="support/codelabs/canonicai/./images/intent_classification.png?raw=true" alt="Alt text" /></p>
<p>Explanation Of The Current Nodes:</p>
<ul>
<li><strong>Input</strong> Text: This is the text from the user. </li>
<li><strong>Classes</strong>: A groups of intent labels that helps an AI Model to make conversations.</li>
<li><strong>Output Class</strong>: A single intent label that makes the meaning of a user </li>
</ul>
<p>When a user inputs a query either via speech or text it goes to the intent classification AI model alongside with the classes of intent. These together when gets processed by the AI model it will generate an output class of one single intent. I promise you in the real example you will understand this flow and you will walk out knowing what this intent classification state actually do.</p>
<h4 id="a-new-version-of-the-diagram-with-the-real-example"><a class="header" href="#a-new-version-of-the-diagram-with-the-real-example">A new version of the diagram with the real example</a></h4>
<p><img src="support/codelabs/canonicai/./images/intent_classification_example.png?raw=true" alt="Alt text" title="Title" /></p>
<p>In this section, We will explain in real life how the flow works. Let's start with the current user. The user asked &quot;Is it cold outside?&quot; and keep in mind that a there will also be predefined classes that will also be fed to the Conversation AI and these classes of user intent are weather, fruits, music and greeting. What these classes are, its like, one word that would translate the meaning of an entire query a user may ask. So for example if the user asked &quot;These bananas look very green&quot;, this statement belongs to the intent class <strong>fruits</strong>, and the word fruit translated the entire meaning of that statement the user asked. So the goal of the intent classification model is to look at classes of predefined words and based on the user input, try to figure out which class belongs to, or would suit the meaning of the user input. So, when the user input and the classes of intent get passed to the intent classification model it will figure out based on probability which intent belongs to that user query in this real example case that would be <strong>weather</strong>.</p>
<h3 id="entity-extraction"><a class="header" href="#entity-extraction">Entity extraction</a></h3>
<h4 id="what-is-entity-extraction"><a class="header" href="#what-is-entity-extraction">What is Entity extraction?</a></h4>
<p>Entity extraction is a text analysis technique that uses Natural Language Processing (NLP) to automatically pull out specific data from unstructured text, and classifies it according to predefined categories. Entity extraction, also known as named entity extraction (NER), enables machines to automatically identify or extract entities, like product name, event, and location. It’s used by search engines to understand queries, chatbots to interact with humans, and teams to automate tedious tasks like data entry.</p>
<h4 id="a-simple-diagram-illustrating-the-input-and-output-of-entity-extraction"><a class="header" href="#a-simple-diagram-illustrating-the-input-and-output-of-entity-extraction">A (simple) diagram illustrating the input and output of Entity extraction</a></h4>
<p><img src="support/codelabs/canonicai/./images/entity_extraction.png?raw=true" alt="Alt text" title="Title" /></p>
<p>Explanation Of The Current Nodes:</p>
<ul>
<li><strong>Input Text</strong>: This is the text from the user. </li>
<li><strong>Feature Dataset</strong>: A lot of training data on where certain keywords would usually be located in a sentence.</li>
<li><strong>Extract Features</strong>: A process of picking out keywords and mapping a meaning to that keyword</li>
<li><strong>Output Feature Set</strong>: The result of defining the keyword and what class it belongs to.</li>
</ul>
<p>Let's disect this diagram. Let's start from the input text (user input), that's being passed directly to the entity extraction model to extract the features. There is also a feature dataset that hosts all the training data where keywords are usually located in a sentence alongside with the class attached to the keyword. These two nodes combined will allow the AI model to use certain algorithms to extract all the necessary information from the user input and as a result it will output the feature set. This might be a bit confusing but I promise you after the example below you will come out with extensive knowledge of what this entity extraction model is all about.</p>
<h4 id="a-new-version-of-the-diagram-with-the-real-example-1"><a class="header" href="#a-new-version-of-the-diagram-with-the-real-example-1">A new version of the diagram with the real example</a></h4>
<p><img src="support/codelabs/canonicai/./images/entity_extraction_example.png?raw=true" alt="Alt text" title="Title" /></p>
<p>Great, let's explain this. Let's say we are talking to a bot that interviews people and the bot asks &quot;tell me about your best friend next to you, what's his name, the company he worked at, and where does he reside&quot; and you proceed to answer like &quot;Jemmott from Guyana is a developer that works at V75 Inc&quot;. How can the bot use this information and find exactly where the name, company, location at and makes sense of it and how the hell would the bot know what are important in that statement you provided. That is where entity extraction comes into place. The bot beforehand would be taught where certain words would be located in a large dataset prior and what class it belongs to. So that's where the feature dataset comes in. This is a large training data of similar sentences that is trained to know what are the important keywords in a sentence and map a class to it. So when the user ask that question it will go the the extract feature node and based on the feature dataset extract relavant keywords from the user input. It would then output, Jemmott is a name, Guyana is a location, V75 is a company based on what it been taught. That's entity extraction. We as human go through the exact process in many conversation overtime when we request certain things from one another. Hopefully, you understand now what is entity extraction and how it works.</p>
<h4 id="real-example"><a class="header" href="#real-example">Real example</a></h4>
<p><img src="support/codelabs/canonicai/./images/real_example_er.png" alt="Real Example For Entity extraction" title="Title" /></p>
<p>This is another example of the AI figuring out based on the training data where certain keywords are located and mapping it to a class.</p>
<h3 id="sentence-encoding"><a class="header" href="#sentence-encoding">Sentence Encoding</a></h3>
<h4 id="what-is-sentence-encoding"><a class="header" href="#what-is-sentence-encoding">What is Sentence Encoding?</a></h4>
<p>The Sentence Encoder encodes text into high dimensional vectors that can be used for text classification, semantic similarity, clustering, and other natural language tasks. The sentence embeddings can then be trivially used to compute sentence-level meaning similarity as well as to enable better performance on downstream classification tasks using less supervised training data.</p>
<h4 id="a-simple-diagram-illustrating-the-input-and-output-of-sentence-encoding"><a class="header" href="#a-simple-diagram-illustrating-the-input-and-output-of-sentence-encoding">A (simple) diagram illustrating the input and output of Sentence Encoding</a></h4>
<p><img src="support/codelabs/canonicai/./images/sentence_encoding.png?raw=true" alt="Sentence Encoding Example" title="Title" /></p>
<p>Explanation Of The Current Nodes:</p>
<ul>
<li><strong>input</strong>: A string or body of text</li>
<li><strong>sentence encoding</strong>: An encoding of the body of text provided from the input.</li>
<li><strong>cosine similarity</strong>: From 0-1, based on the two body of text how similar it is in meaning.The number closer to 1 is very similar in meaning.</li>
</ul>
<p>Let's explain the flow, So in this model it requires two input. Each input is passed into a sentence encoding AI model which will use certain algorithm to encode a large body of text into vector which will then feed into the cosine similarity function which will compare the two vectors and find how similar the two input is from a score of 0-1. Take into consideration this score could be 0.002, 0.12, 0.08 and etc. The one closer to 1 is the highest in similarity. In the real example below you will understand it in more detail but keep this flow in mind.</p>
<h4 id="a-new-version-of-the-diagram-with-the-real-example-2"><a class="header" href="#a-new-version-of-the-diagram-with-the-real-example-2">A new version of the diagram with the real example</a></h4>
<p><img src="support/codelabs/canonicai/./images/sentence_encoding_example.png?raw=true" alt="Sentence Encoding Example" title="Title" /></p>
<p>From this example, we are using the sentence encoder to look at the user input &quot;Good morning&quot;
and see how similar it is to a class &quot;greeting&quot; so when we pass the both to seperate sentence encoder which it will then vectorize it and pass it to the cosine similarity function which is will look deeper into to the vectors and find a score from 0-1, to see how similar it is in meaning, 0 from lowest and 1 as the highest. So why would we use this, let's say we are building a classifier what if we had like greeting, bye, fruits, and we want to know what &quot;Good morning&quot; is closest to in meaning. We can use this sentence encoder to find the similarity in each of the words greetings bye and fruits and the one that have the highest score, is similar in meaning. Let's say the results in greeting is 0.9, fruits is 0.0023, and bye is 0.02. Therefore greetings is similar to the user input &quot;Good morning&quot; because it ranks high from the scale 0-1 and the bye class would rank second. We can use the sentence encoder in many other application but in this example we used the sentence encoder to build a intent classification model, we can build a whole lot of other applications using sentence encoder. With that said, enjoying showing off your knowledge to others who don't know about sentence encoder.</p>
<h4 id="real-example-1"><a class="header" href="#real-example-1">Real example</a></h4>
<p><img src="support/codelabs/canonicai/./images/real_example_se.png" alt="Real Example For Sentence Encoder" title="Title" /></p>
<p>This is a real life example where it applies from a day to day basis in our lives. Sentence encoder is widely used in many modern AI applications across the world.</p>
<h3 id="the-ai-models-we-will-use-in-this-tutorial"><a class="header" href="#the-ai-models-we-will-use-in-this-tutorial">The AI models we will use in this tutorial</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>AI Model</th><th>Links</th></tr></thead><tbody>
<tr><td>Intent classification</td><td>biencoder</td><td><a href="https://arxiv.org/abs/2103.06523">link</a></td></tr>
<tr><td>Entity extraction</td><td>Transformer-based token classification</td><td><a href="https://huggingface.co/docs/transformers/tasks/token_classification#token-classification">link</a></td></tr>
<tr><td>Sentence encoding</td><td>Universal Sentence Encoder (USE_ENC and USE_QA)</td><td><a href="https://arxiv.org/abs/1803.11175">link</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci-1"><a class="header" href="#build-a-conversational-ai-system-in-jaseci-1">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<h2 id="i-architecture-overview"><a class="header" href="#i-architecture-overview">i. Architecture overview</a></h2>
<p><img src="support/codelabs/canonicai/./images/architecture.png?raw=true" alt="Architecture" title="Title" /></p>
<h3 id="three-architecture-constituent-components-and-their-purpose"><a class="header" href="#three-architecture-constituent-components-and-their-purpose">Three Architecture constituent components and their purpose</a></h3>
<h4 id="ai-model-management"><a class="header" href="#ai-model-management">AI Model Management</a></h4>
<p>It’s a centralized area for all types of AI models that does specific functions such as NER, Classification, etc. Which can be accessed by the conversational states to perform certain actions.</p>
<p>The purpose are as follows:</p>
<ul>
<li>
<p><strong>Intent Classification</strong>: This will allow us to find the meaning of a particular user input. for e.g. &quot;How cold is it?&quot;, The AI Model once trained it will understand that the intent of that input is &quot;<strong>weather</strong>&quot;. The <strong>USE Encoder (use_enc)</strong> and <strong>Bi-encoder (bi_enc)</strong> are the two AI Model used in this architecture.</p>
</li>
<li>
<p><strong>Named Entity Recognition (NER)</strong>: This allows us to pick out specific objects from a user input, for e.g. I am 29 years old, this AI model will extract <strong>29</strong> and map it as an entity called &quot;<strong>age</strong>&quot;. The AI Model used in this architecture is called <strong>Transformer NER (tfm_ner)</strong>.</p>
</li>
<li>
<p><strong>Summarization</strong>: This allows us to shorten a large body of text while retaining the meaning of the entire document. This is used in the FAQ architecture. We will get into more detail into this later in this chapter. The AI Model used in this architecture is called <strong>Summarizer (cl_summer)</strong>.</p>
</li>
</ul>
<h4 id="faq-management-architecture"><a class="header" href="#faq-management-architecture">FAQ Management Architecture</a></h4>
<p>This state intakes a link from the user which is then read to scrape data from the website into a summarized fashion in order to be stored as a faq. Which can be later accessed through conversation from a user.</p>
<p>The purpose are as follows:</p>
<ul>
<li>store a large body of data which accurate summarized segments can be accessed through text-based conversational AI.</li>
<li>reduces the need of rebuilding the wheel or do addition work. What we mean by this, the FAQ state intake a link/pdf that navigate through a document or site that's already built, then proceed to process the information for later use.</li>
<li>any data from multiple sites and pdf can be stored and referenced for later use.</li>
</ul>
<h4 id="conversational-ai-model-architecture"><a class="header" href="#conversational-ai-model-architecture">Conversational AI Model Architecture</a></h4>
<p>This is where the user query goes to get processed and a response is returned back to the user.</p>
<p>The purpose are as follows:</p>
<ul>
<li>task oriented: Conversation AI are single-purpose programs that focus on performing one function. Using rules, NLP, and very little ML, they generate automated but conversational responses to user inquiries.</li>
<li>speed: It performs task relatively quicker than humans and more efficiently.</li>
<li>reliability: it work's 24/7 unlike like humans that works 9-5.</li>
</ul>
<h3 id="ii-conversation-ai-component"><a class="header" href="#ii-conversation-ai-component">ii. Conversation AI component</a></h3>
<p><img src="support/codelabs/canonicai/./images/convai.png?raw=true" alt="Conversation AI" title="Title" /></p>
<p>As we acknowledge, this is where the user query an utterance and gets a response from the application. In this section we will explain in more details how the diagram above works. Each nodes represents a conversational state and each of the edges represents the transition path between states. However, they are different type of edges, some are triggered by a certain intent which is tied to a conversational state as show above where state 1 and state 2 lies and some are triggered when they are fulfilled by the entities picked up from the user query. In this component, we leveraged the power of the intent classification using the bi-encoder AI model (bi_enc) and for entity extraction we utilized the Transformer NER Model (tsfm_ner). Each state nodes also have functions which can be shared between states for e.g. each state can have a function where it generates a response for the user and there can be another state function which deals with the business logics (extra processing of user input). So, what's the flow, The user query an utterance and is navigated to the conversational ai state which it goes through the intent classification model to grab the meaning of the query and based on the intent which are tied to a state it navigates the state through an edge and based on the states that's how it will traverse through the graph shown above.</p>
<h3 id="iii-zero-shot-faq"><a class="header" href="#iii-zero-shot-faq">iii. Zero-shot FAQ</a></h3>
<p><img src="support/codelabs/canonicai/./images/faq.png?raw=true" alt="Zero-shot FAQ" title="Title" /></p>
<p>In this section, we will explain how this works. Every node represents a faq state and the edges represent transition paths between states. In this component we are utilizing summarization AI model (cl_summer) and a sentence encoder (use_qa). Before anyone can query the FAQ state we have to first explain how data is stored in the FAQ states and how the FAQ answer states are generated. In the FAQ state, a link to a website or PDF have to be fed into the summarization model (cl_summer) and what this does it compute and scrape all the information from the website, summarize it and each summarized section is segmented and stored as new states in the faq section which will be later accessed through the AI. When a user queries and the input is sent to the FAQ state it will be intercepted by the sentence encoder (use_qa) which will look for the best possible faq answer state available, then returns it to the user as a response.</p>
<h3 id="iv-model-trainer"><a class="header" href="#iv-model-trainer">iv. Model trainer</a></h3>
<p><img src="support/codelabs/canonicai/./images/trainer.png?raw=true" alt="Model trainer" title="Title" /></p>
<p>We utilize 4 AI models in which each have a different method of training. The four models includes the bi-encoder (bi_enc), sentence encoder (use_enc), entity extraction (tsfm_ner) and summarization model (cl_summer). From the root node each AI model states are created which they all can be trained through the walkers. Each nodes have specific function for specific task and it can all be classified in this order load, train, save, set pretrained and infer model function.</p>
<ul>
<li><strong>Load_model</strong>: load an ai model that was already trained</li>
<li><strong>Train_model</strong>: teaches an ai model</li>
<li><strong>Save_model</strong>: save the existing model</li>
<li><strong>Set_pretrained_model</strong>: switch between models that was already created and saved</li>
<li><strong>Infer</strong>: test out the model</li>
</ul>
<h3 id="v-tieing-all-components-together"><a class="header" href="#v-tieing-all-components-together">v. Tieing all components together</a></h3>
<p>The first architecture we have to take into consideration is the AI model management state. This is where we map out the types of questions a user may ask alongside with the user intent. We also have to ask ourselves if there are entities that we have to capture in a conversation, like for example where is the location, name, amount of apples in the user question and from there we begin to build out and train the model before we could build any logic on top of that to connect the application. After the AI model management then we have to move on to the conversational state where we will focus on what we will do with the user intent and the entities extracted from it and from there generate a specific response where applicable. The faq architecture is like a cherry on top of the conversation AI state, how this feature works we first have to feed a website link to the conversational AI and it will take out the appropriate information from the site and maps a summarization form of it which will be fed into the faq state for later processing. We can then ask questions based on the link provided and the model will give you the best answer from what it has learned from the site. Now you should be able to understand how they are all tied together in a generalized fashion.</p>
<h3 id="vi-tesla-use-case-example"><a class="header" href="#vi-tesla-use-case-example">vi. Tesla use case example</a></h3>
<p><img src="support/codelabs/canonicai/./images/tesla.png?raw=true" alt="Tesla Use Case" title="Title" />
In this section, we will guide you how the entire architecture work with a real example. First, we will walk you through its design for the conversation AI component and then walk you through the FAQ component.</p>
<ul>
<li>
<p><strong>Conversation AI Component</strong>: Imagine we are interacting with a tesla sales person but it's not human its a chatbot. As a user, we will ask a question and as we ask the question it will first go to the Top Level Classification State where it will decide whether to go to the FAQ state or the Conversation AI state using the sentence encoder (use_enc) AI Model, In this case we ask a question about wanting to test drive a tesla. The AI model will analyse then know we are asking a question that is not related to anything in the FAQ section so it will navigate us to the Conversation AI State where it will use the bi-encoder AI model to find the intent of the initial question and extract the entity if any from the user query. In this case we ask the tesla sales person if we can test drive the tesla. The tesla bot will navigate to the collect information state where it will ask for your name and address and when those slots are fulfilled, the edge will trigger to move to the next state (confirmation state) to confirm that the information is correct and based on your next response you can either cancel the entire process which will trigger the edge ,which will navigate you to the cancel state or you can confirm that all the information is accurate and get navigated to the confirmed state or you can update the information which will carry you back to the collect information state. The navigation from state to state is triggered either from intent classification or through entity extraction. That's how that process works.</p>
</li>
<li>
<p><strong>FAQ Component</strong>: Imagine you are asking a question &quot;when do you guys open&quot;. In the Top Level Classification state, where it uses the sentence encoder to decide whether to navigate to the conversation AI state or the FAQ state. In this case the AI when processing this utterance it will navigate it to the FAQ state. Where it use a difference sentence encoder (use_qa) which is specialist for FAQ models. The edge will get triggered to the best appropriate faq answer state that is related to the query the user asked and display it to the user.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci-2"><a class="header" href="#build-a-conversational-ai-system-in-jaseci-2">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<h3 id="cai_state-node"><a class="header" href="#cai_state-node"><strong>cai_state node</strong></a></h3>
<h3 id="two-main-stages-in-handling-a-conversational-ai-request"><a class="header" href="#two-main-stages-in-handling-a-conversational-ai-request">Two main stages in handling a conversational AI request</a></h3>
<p><img src="support/codelabs/canonicai/./images/nlu_nlg.png?raw=true" alt="Two Stages" title="Title" /></p>
<p>There are two stages which handles the conversational aspect of the AI and they are NLU (Natural Language Understand) and NLG (Natural Language Generation).</p>
<ul>
<li>
<p><strong>NLU (Natural Language Understand)</strong>: Natural language understanding is a branch of artificial intelligence that uses computer software to understand input in the form of sentences using text or speech. <strong>What does NLU do?</strong> If you look at the diagram above it intakes the user query and the NLU uses two component: intent classification (understanding the meaning of the utterance) and entity extraction (collects important words from the utterance) and this process gives the conversational AI the understanding of what the user is actually trying to say.</p>
</li>
<li>
<p><strong>NLG (Natural Language Generation)</strong>: Natural language generation (NLG) is the use of artificial intelligence (AI) programming to produce written or spoken narratives from a data set. <strong>What does NLG do?</strong> If you look above at the diagram, you would see after the AI understand what the user is trying to say using NLU it will then take those results and auto generate a suitable response to forward to the user and that is the purpose of the NLG.</p>
</li>
</ul>
<h3 id="what-do-each-node-abilities-do"><a class="header" href="#what-do-each-node-abilities-do"><strong>What do each node abilities do?</strong></a></h3>
<ul>
<li><strong>classifiy_intent</strong>: Figures out the user intention in any given question.</li>
<li><strong>extract_entities</strong>: Extract words of interests from the question</li>
<li><strong>gen_response</strong>: Generate a suitable response for the user.</li>
<li><strong>nlu</strong>: Process incoming request through NLU engines using intent classification or entity extraction AI models.</li>
<li><strong>nlg</strong>: Construct natural language response</li>
</ul>
<h3 id="inheritance"><a class="header" href="#inheritance"><strong>Inheritance</strong></a></h3>
<p><strong>What is inheritance?</strong>
It is a mechanism where you can to derive a class from another class for a hierarchy of classes that share a set of attributes and methods.</p>
<p><strong>Node Inheritance</strong></p>
<pre><code>node vehicle {
    has plate_number;
    
    can drive {
        report 'yes';
    }
}

node car:vehicle {
    has plate_number = &quot;RAC001&quot;;
}

node bus:vehicle {
    has plate_number = &quot;SUB002&quot;;
}
</code></pre>
<p>In the above code snippet. This is a very basic example of inheritance. We created a node named car and bus but since they are related and simply share the same property and node ability we created a node named vehicle and inherit its attributes. Imagine life without inheritance, the code will look like this.</p>
<pre><code>node car {
    has plate_number = &quot;RAC001&quot;;
    
    can drive {
        report 'yes';
    }
}

node bus {
    has plate_number = &quot;SUB002&quot;;
    
    can drive {
        report 'yes';
    }
}
</code></pre>
<p>In this case it will seem that writing it this way will be more effient, however what if each vehicles have more functions like blow_horn, accelerate, breaks, park and etc or they are more vehicles like truck, scooter, and etc you can imagine how big this code base will be and that's why it's important to have inheritance in our code base and in this program we use inheritance to increase the efficiency of the entire application.</p>
<p>So, lets use what's in the code base and see how we implemented it. <code>Do not worry about what each nodes and state works, that will be explained in detailed in the next section, just look at how it is implemented.</code></p>
<pre><code>node cai_state {
    has name;
    has prepared_entities = {
            &quot;name&quot;: &quot;Tony Stark&quot;,
            &quot;address&quot;: &quot;10880 Malibu Point&quot;
    };

    # Classify the intent of the question
    can classify_intent {
        # NOTE: Hardcode intent for now
        visitor.predicted_intent = visitor.intent_override;
    }

    # Extract words of interests from the question
    can extract_entities {
        # NOTE: Hardcode entities for now
        for ent in visitor.entity_override {
            visitor.extracted_entities[ent] = prepared_entities[ent];
        }
    }

    # Generate response
    can gen_response {
        # Default response
        visitor.response =
            &quot;Sorry I can't handle that just yet! Anything else I can help you with&quot;;
    }

    # Process incoming request through NLU engines
    can nlu {
        ::classify_intent;
        ::extract_entities;
    }

    # Construct natural language response
    can nlg {
        ::gen_response;
    }
}
</code></pre>
<p>Above, this is a conversational state node. We use inheritance here, because we will have multiple conversational state nodes like a confirm state, cancel state, collect information state and etc, that have the same functionality but does have different node abilities.</p>
<pre><code>node collect_info:cai_state {
    has name = &quot;collect_info&quot;;
    can gen_response {
        if (&quot;name&quot; in visitor.extracted_entities and
                &quot;address&quot; not in visitor.extracted_entities):
            visitor.response = &quot;What is your address?&quot;
        elif (&quot;address&quot; in visitor.extracted_entities and
                &quot;name&quot; not in visitor.extracted_entities):
            visitor.response = &quot;What is your name?&quot;
        else:
            visitor.response =
                &quot;To set you up with a test drive, we will need your name and address.&quot;;
    }
}

node confirmation:cai_state {
    has name = &quot;confirmation&quot;;
    can gen_response {
        visitor.response =
            &quot;Can you confirm your name to be &quot; + visitor.extracted_entities[&quot;name&quot;] + &quot; and your address as &quot; + visitor.extracted_entities[&quot;address&quot;] + &quot; ?&quot;;
    }
}

node confirmed:cai_state {
    has name = &quot;confirmed&quot;;
    can gen_response {
        visitor.response = &quot;You are all set for a Tesla test drive!&quot;;
    }
}

node canceled:cai_state {
    has name = &quot;canceled&quot;;
    can gen_response {
        visitor.response = &quot;No worries. We look forward to hear from you in the future!&quot;;
    }
}
</code></pre>
<p>As you can see here, all of the conversational state node have something in common, that's why it is very important to use inheritance, because this code instead of being 200 lines of code it can be over 1000+ lines of code and it could be very hard to manage and read.</p>
<p>You can go to <a href="https://docs.jaseci.org/docs/Developing_with_JAC/Language_Features/OOP">jaseci docs</a> for more information on inheritance. If you are still confused about inheritance and how it works.</p>
<h3 id="nodes-states"><a class="header" href="#nodes-states"><strong>Nodes (States)</strong></a></h3>
<h3 id="collect_info-state"><a class="header" href="#collect_info-state">collect_info state</a></h3>
<p>This state collects the address and name of the user from the user utterance. If the user only provides their address the AI will ask the user for their name and vice versa. It will ask the user for those information until it is fulfilled before moving on to the next state which is the <strong>confirmation</strong> state, this process is done using entity extraction. The user can also cancel the entire process and this will move them to the <strong>cancel</strong> state, this is triggered by intent classification. Below shows how the node is created. </p>
<pre><code>node collect_info:cai_state {
    has name = &quot;collect_info&quot;;
    can gen_response {
        if (&quot;name&quot; in visitor.extracted_entities and
                &quot;address&quot; not in visitor.extracted_entities):
            visitor.response = &quot;What is your address?&quot;
        elif (&quot;address&quot; in visitor.extracted_entities and
                &quot;name&quot; not in visitor.extracted_entities):
            visitor.response = &quot;What is your name?&quot;
        else:
            visitor.response =
                &quot;To set you up with a test drive, we will need your name and address.&quot;;
    }
}
</code></pre>
<h4 id="confirmation-state"><a class="header" href="#confirmation-state">confirmation state</a></h4>
<p>This state confirms whether or not the information provided by the user is completely correct. If there is any mistake made, the AI will revert to the <strong>collect_info</strong> state where it will repeat the process, if all the data provided is confirmed by the user it will them move to the next state which is the <strong>confirmed</strong> state. Below shows how the node is created. </p>
<pre><code>node confirmation:cai_state {
    has name = &quot;confirmation&quot;;
    can gen_response {
        visitor.response =
            &quot;Can you confirm your name to be &quot; + visitor.extracted_entities[&quot;name&quot;] + &quot; and your address as &quot; + visitor.extracted_entities[&quot;address&quot;] + &quot; ?&quot;;
    }
}
</code></pre>
<h3 id="confirmed-state"><a class="header" href="#confirmed-state">confirmed state</a></h3>
<p>This state is triggered after the user have positively agreed that all the data provided is correct and based on the information provided the company will makes it decision afterwards. In this case the sales person will tell the user &quot;You are all set for a tesla test drive&quot;. Below shows how the node is created. </p>
<pre><code>node confirmed:cai_state {
    has name = &quot;confirmed&quot;;
    can gen_response {
        visitor.response = &quot;You are all set for a Tesla test drive!&quot;;
    }
}
</code></pre>
<h3 id="canceled-state"><a class="header" href="#canceled-state">canceled state</a></h3>
<p>This state is triggered when the user wants to hop out of the entire conversation and it's done through intent classification. </p>
<pre><code>node canceled:cai_state {
    has name = &quot;canceled&quot;;
    can gen_response {
        visitor.response = &quot;No worries. We look forward to hear from you in the future!&quot;;
    }
}
</code></pre>
<h3 id="edges-2"><a class="header" href="#edges-2"><strong>Edges</strong></a></h3>
<h3 id="intent_transition-edge"><a class="header" href="#intent_transition-edge">intent_transition edge</a></h3>
<p>This edge allows you to transition from state to state (node to node) when provided an intent which is passed as a parameter. For e.g. when the user ask &quot;Can I test drive the tesla&quot; it will go through the bi-encoder AI model which is used for intent classification and find the intent and through the edge it will pass the intent to the intent_transition edge which will search for which node to travel to, to move to the next state. In this case it will be the collect_info state.</p>
<pre><code>edge intent_transition {
    has intent;
}
</code></pre>
<h3 id="entity_transition-edge"><a class="header" href="#entity_transition-edge">entity_transition edge</a></h3>
<p>This edge allows you to transition from state to state (node to node) when provided all the entities needed which is passed as a parameter. For e.g. when the user have to provide information in the collect_info state &quot;My name is Jemmott I live in lot 1 pineapple street&quot; it will go through the entity extraction AI model, extract &quot;Jemmott&quot; as the name and &quot;lot 1 pineapple street&quot; as the address and it will passed these information into the entity_transition edge and move you on to the next state, in this case it will be the confirmed state. If all the information is not provided it will not transition to the next state until all the entities are fulfilled. </p>
<pre><code>edge entity_transition {
    has entities;
} 
</code></pre>
<h3 id="graph-definition"><a class="header" href="#graph-definition"><strong>Graph Definition</strong></a></h3>
<h3 id="spawning-nodes"><a class="header" href="#spawning-nodes">spawning nodes</a></h3>
<p>Nodes are the states we used to build out the conversation AI experiences. Below, shows how to create states (nodes) using jac.</p>
<pre><code>spawn {
    state_cai_root = spawn node::cai_root;
    state_collect_info  = spawn node::collect_info;
    state_confirmation = spawn node::confirmation;
    state_confirmed = spawn node::confirmed;
    state_canceled = spawn node::canceled;
}
</code></pre>
<h3 id="connecting-the-nodes-with-the-two-types-of-edges"><a class="header" href="#connecting-the-nodes-with-the-two-types-of-edges">connecting the nodes with the two types of edges</a></h3>
<p>There are two types of edges: intent_transition edge and entity_transition edge and we will use these to connect states (nodes) to each other. </p>
<p>Intent Transition Example:</p>
<pre><code>    state_cai_root -[intent_transition(
            intent = &quot;I would like to test drive&quot;
        )]-&gt; state_collect_info;
</code></pre>
<p>Here we have a intent transition going from the cai_root state to the collect_info state. This intent transition has its intent variable set to &quot;&quot;I would like to test drive&quot;&quot;, which will be checked later in the walker &quot;talk&quot; to evaluate whether or not this transition should be triggered or not.</p>
<p>Entity Transition Example:</p>
<pre><code>        state_collect_info -[entity_transition(
            entities = [&quot;name&quot;, &quot;address&quot;]
        )]-&gt; state_confirmation;
</code></pre>
<p>Here we have an entity transiton going from the collect_info state to the confirm state. This entity transition has its entities variable set as &quot;name&quot; and &quot;address&quot;, which will be checked later in the talk walker to evaluate if this transition should be triggered or not.</p>
<h3 id="the-anchor-node"><a class="header" href="#the-anchor-node">the anchor node</a></h3>
<p>The anchor node is the main node or the starting node for the conversational AI state. This node is mandatory for the application. </p>
<pre><code>graph tesla_sales_rep {
    has anchor state_cai_root;
}
</code></pre>
<h3 id="describe-the-talk-walker"><a class="header" href="#describe-the-talk-walker"><strong>Describe the talk walker</strong></a></h3>
<h3 id="the-parameters-it-takes"><a class="header" href="#the-parameters-it-takes">The parameters it takes</a></h3>
<ul>
<li><strong>question</strong>: This intakes the user utterance.</li>
<li><strong>intent_override</strong>: Allows you to override the intent produced by the intent classification model from the NLU.</li>
<li><strong>entity_override</strong>: Allows you to override the entities extracted from the entity extraction model from the NLU.</li>
<li><strong>predicted_intent</strong>: This is the variable that holds the intent predicted from the intent classification model. </li>
<li><strong>extracted_entities</strong>: This is the variable that holds the extracted entities that produced from the entity extraction model from the NLU.</li>
<li><strong>traveled</strong>: This variable tells you whether or not we moved on to the next state.</li>
<li><strong>response</strong>: This holds the response generated from the NLG.</li>
</ul>
<h3 id="the-traveled-boolean-flag"><a class="header" href="#the-traveled-boolean-flag">The &quot;traveled&quot; boolean flag</a></h3>
<p>This boolean flag variable tells you whether or not we moved on to the next state. If its flagged as &quot;false&quot; it will execute all the logic from the NLU until it have the information to move on to the next state if not it will execute the NLG which will generate a reponse and go to the next state.</p>
<h3 id="the-traversal-logic"><a class="header" href="#the-traversal-logic">The traversal logic</a></h3>
<p>In this section I will explain how this code snippet works for the traversal logic.
From entity transition &gt;&gt; intent transition</p>
<pre><code>take -[entity_transition(entities=extracted_entities.d::keys)]-&gt; node::cai_state else {
    take -[intent_transition(intent=predicted_intent)]-&gt; node::cai_state else {
        # Fall back to stay at current state if no valid transitions can be taken
        take here;
    }
</code></pre>
<p>If all the keys in the array of extracted_entities matches any edge in the entity_transition that is attached to a node it will transition you to the appropriate conversation AI state if not it will check if the predicted intent matches any record in the edge of the intent_transition and move you to that state. If both of the requirements was not met it will continue at the current state and ask you the same question until it gets the information it wants from you.</p>
<h3 id="the-take-statement"><a class="header" href="#the-take-statement">The take statement</a></h3>
<p><strong>How does it work?</strong> <br />
The take statement allows you to transition from node to node (state to state). If the requirements are met it will transition you to the node you specified. If you see the code snippet below, once the parameters are met the take statement will transfer you to the appropriate node that matched the cai_state. But if the parameters are not met it will throw an error and that is where the else comes into place. That will be explained in the next section.</p>
<pre><code>take -[intent_transition(intent=predicted_intent)]-&gt; node::cai_state;
</code></pre>
<p><br />
<strong>How does take, else work?</strong>
The take, else works just like the if, else statement in any other programming language. If the node from the take statement does not exist it will activate the else statement and execute what is in the else block. </p>
<pre><code>take -[intent_transition(intent=predicted_intent)]-&gt; node::cai_state else {
        # execute code in here
    }
</code></pre>
<p>For more information about what the take statement and take, else statement works. Reference the <a href="https://docs.jaseci.org/docs/getting-started/JAC-Language-Overview/take">Jaseci Documentation</a> </p>
<h3 id="the-flow"><a class="header" href="#the-flow">The Flow</a></h3>
<p>NLU ➝ traversal ➝ NLG ➝ return response
<br />
We know already that the NLU is responsible for understanding the context of the user query using the intent classification model and the entity extraction model. The traversal is essentially the state of the graph that collects information and if the information is not met it will ask the user until it understands and get all the user information required in order to move to the next state. The NLG is responsible for the natural generation of the response based on the current state, entities and intent and based on the response generated from the NLG it will return this information to the user. That's basically the rundown of how the flow works in this application.</p>
<h3 id="init-walker-to-initiate-the-graph"><a class="header" href="#init-walker-to-initiate-the-graph"><strong>init walker to initiate the graph</strong></a></h3>
<pre><code>walker init {
    root {
        spawn here --&gt; graph::tesla_sales_rep;
    }
} 
</code></pre>
<p>The above code snippet shows how we utilize generating the graph using the init walker using jac. Note: the graph spawn statement returns the anchor node defined in the graph block. Therefore, the anchor node is a return statement. The init walker is also the first block of code that will be runned in the entire application and that will look for the graph we created for the tesla sales rep and generate all the nodes and edges of the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci-3"><a class="header" href="#build-a-conversational-ai-system-in-jaseci-3">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-4"><a class="header" href="#chapter-4">Chapter 4</a></h1>
<h2 id="what-are-we-building-1"><a class="header" href="#what-are-we-building-1">What are we building?</a></h2>
<p>We are building a Conversational AI.</p>
<h3 id="explaining-stdinput-and-stdout"><a class="header" href="#explaining-stdinput-and-stdout">Explaining std.input and std.out</a></h3>
<p>Let's start with std.input, std meaning &quot;standard&quot; and input meaning &quot;what is put in&quot;. std.input is a function that intakes, what a user put in only from the terminal and can be stored in a variable. It pauses the program to intake data from the user. The function accepts an optional string to display to the terminal. It acts like a prompt so user know what to input to the terminal.  This function cannot be used to intake any data from api or anything external. That is what std.input is all about. </p>
<pre><code>name = std.input('what is your name');
</code></pre>
<p>Let's now talk about std.out. std in jac means &quot;standard&quot; and out meaning &quot;output&quot;. std.out is a function in jac when called it display data to a terminal or server and it intake a string parameter which is used to display. </p>
<pre><code>std.out('Display TEXT here');
</code></pre>
<h3 id="how-to-run-the-program-interactively-via-jsctl"><a class="header" href="#how-to-run-the-program-interactively-via-jsctl">How to run the program interactively via jsctl</a></h3>
<p>In this section we will be running you through how to run a program interactively via jsctl. Let's start from the first step. You need to install jaseci if you have not. Run the command below in the terminal.</p>
<pre><code>pip install jaseci 
</code></pre>
<p>After, installing jaseci we have to run the command jsctl meaning &quot;jaseci control&quot;. Run the command below in the terminal.</p>
<pre><code>jsctl
</code></pre>
<p>After running jaseci control (jsctl) you should see an active cursor. Now you can run any jac program by using the jac command. For e.g. We have a file named hello.py that runs &quot;hello world!&quot;.
Run the command below in the terminal.</p>
<pre><code>jac run hello.py
</code></pre>
<p>That's how to run the program interactively via jsctl.</p>
<h3 id="the-journey-of-a-dialogue-session"><a class="header" href="#the-journey-of-a-dialogue-session">The journey of a dialogue session</a></h3>
<p>First before we get started, let's run the code below in jsctl. What this does it will allow us to go through the dialogue in jsctl.</p>
<pre><code>jac run main.jac -walk interactive
</code></pre>
<p>In this section, I will walk you through the journey of a dialogue session. We will go through several queries and explain what happens with each query, including what intent and entities came from that query and  which node it starts at and how it transitions from that node to another node. Let's get started.</p>
<pre><code>&gt; I want to test drive
To set you up with a test drive, we will need your name and address.
</code></pre>
<p><strong>I want to test drive</strong>: When the user respond with that query it first go through the conversational AI root state (node) for intent classification. Based on the intent extracted it will do an intent transition (edge) to the next state (node) in this case it will transition to collect information state (node).</p>
<pre><code>&gt; My  name is Tony Stark
What is your address?
</code></pre>
<p><strong>My  name is Tony Stark</strong>: After coming from the conversation AI root state from the first query above and it get's transitioned to the collect information state, it will prompt the user for their name and address information, Then the user respond with this query and it will go to the entity extraction model and pulls out the features from the user utterance in this case it will pull out the name because only the name was provided. Since the entity transition required two keys, one is the name and one is the address, since only one of the data was provided it will re-transition to the current state (node) &quot;collect information&quot; while keeping the context of the last query provided alongside with the features.</p>
<pre><code>&gt; My address is at 10880 Malibu Point
Can you confirm your name to be Tony Stark and your address as 10880 Malibu Point?
</code></pre>
<p><strong>My address is at 10880 Malibu Point</strong>: Coming from the last query, when get re-transitioned to the collect information state and the bot prompt the user for data and the user responds with the current query. The entity extraction model will extract the feature address and map  <strong>10880 Malibu Point</strong> to address, alongside with the last features extracted from the last query and with both information provided it will do an entity transition and move to the next state (node) called confirmation state.</p>
<pre><code>&gt; Yes that looks correct
You are all set for a Tesla test drive!
</code></pre>
<p><strong>Yes that looks correct</strong>: When transitioned to confirmation state, it will be prompted by the bot for confirmation and when the user responds with the current query, it will go through the intent classification model to know whether or not they confirmed or not, based on the current query the user agreed and it will do an intent transition to move to confirmed state (node) which the bot will prompt the user with the information required based on the user data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci-4"><a class="header" href="#build-a-conversational-ai-system-in-jaseci-4">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-5"><a class="header" href="#chapter-5">Chapter 5</a></h1>
<h2 id="what-are-we-building-2"><a class="header" href="#what-are-we-building-2">What are we building?</a></h2>
<p>We are building a Conversational AI.</p>
<h3 id="the-updated-inheritance-structure"><a class="header" href="#the-updated-inheritance-structure">The Updated Inheritance Structure</a></h3>
<p>Before:</p>
<pre><code>node cai_state {
    has name;
    has example_entities = {
            &quot;name&quot;: &quot;Tony Stark&quot;,
            &quot;address&quot;: &quot;10880 Malibu Point&quot;
    };

    # Classify the intent of the question
    can classify_intent {
        # Note: a simple hardcoded &quot;classifier&quot;
        # To be replaced with an AI model in a later chapter
        if (&quot;test drive&quot; in visitor.question.str::lower):
            visitor.predicted_intent = &quot;test drive&quot;;
        elif (&quot;yes&quot; in visitor.question.str::lower):
            visitor.predicted_intent = &quot;yes&quot;;
        elif (&quot;no&quot; in visitor.question.str::lower):
            visitor.predicted_intent = &quot;no&quot;;
        elif (&quot;cancel&quot; in visitor.question.str::lower):
            visitor.predicted_intent = &quot;cancel&quot;;
        else:
            visitor.predicted_intent = &quot;out of scope&quot;;
    }

    # Extract words of interests from the question
    can extract_entities {
        # Note: a simple hardcoded entity extraction model
        # To be replaced with an AI model in a later chapter
        if (&quot;name&quot; in visitor.question.str::lower):
            visitor.extracted_entities[&quot;name&quot;] = example_entities[&quot;name&quot;];

        if (&quot;address&quot; in visitor.question.str::lower):
            visitor.extracted_entities[&quot;address&quot;] = example_entities[&quot;address&quot;];
    }

    # Generate response
    can gen_response {
        # Default response
        visitor.response =
            &quot;Sorry I can't handle that just yet! Anything else I can help you with&quot;;
    }

    # Process incoming request through NLU engines
    can nlu {
        ::classify_intent;
        ::extract_entities;
    }

    # Construct natural language response
    can nlg {
        ::gen_response;
    }
}
</code></pre>
<p>Before, we had classify_intent, extract_entities, gen_response functionality in the cai_state for specifically virtual assistance. However, since we have added the FAQ model (faq node) to the conversation AI state we needed to centralize the functionality, they have completely different functionality when it comes to the NLU (Natural Language Understanding) where we used it for intent classification and entity extraction. Likewise, the FAQ model uses the NLU to find the faq node which matches the appropriate user query, and for the NLG (Natural Language Generation) they generates different responses based on the NLU.</p>
<p>After: </p>
<pre><code>node cai_state {
    has name;
    can nlu {
        std.err(&quot;Node ability invoked for cai_state node: nlu&quot;);
        disengage;
    }
    can nlg {
        std.err(&quot;Node ability invoked for cai_state node: nlg&quot;);
        disengage;
    }
}
</code></pre>
<p>So, what is happening here, since the cai_states are centralize, we can now inherit this node for the faq node (frequently asked question) and va node (virtual assistance) and just override the NLU and NLG. So, let's elborate on the new changes and explain the logics for specific abilities and etc.</p>
<h3 id="the-general-pattern-of-nlu---nlg"><a class="header" href="#the-general-pattern-of-nlu---nlg">The general pattern of NLU -&gt; NLG</a></h3>
<p><strong>NLU logic for va_state which inherits cai_state</strong></p>
<pre><code>can nlu {
        ::classify_intent;
        ::extract_entities;
    }
</code></pre>
<p>For the NLU here, intent classification and extract entities function have been called and it override the nlu logic from the cai_state. </p>
<p><strong>NLG logic for va_state which inherits cai_state</strong></p>
<pre><code># Construct natural language response
    can nlg {
        ::gen_response;
    }
</code></pre>
<p>For the NLG logic it calls the gen response function in order to give the response to the user. Each va_state have unique responses and they all are overwritten using nlg node ability.</p>
<p><strong>There are 4 va_state (va nodes):</strong></p>
<p><strong>cai_va_root</strong>
As you can see since this is the root node for the conversation we do not need any unique responses.</p>
<pre><code>node cai_va_root:va_state {
    has name = &quot;cai_va_root&quot;;
}
</code></pre>
<p><strong>collect_info</strong>
If you see below the the gen response is unique to the slots extracted from the user query. If a user was at this state based on the root query if no slots was provided it would respond with &quot;To set you up with a test drive, we will need your name and address.&quot;, if you have provided only an address however, it would have responded with &quot;What is your name?&quot; and vice versa.</p>
<pre><code>node collect_info:va_state {
    has name = &quot;collect_info&quot;;
    can gen_response {
        if (&quot;name&quot; in visitor.extracted_entities and
                &quot;address&quot; not in visitor.extracted_entities):
            visitor.response = &quot;What is your address?&quot;;
        elif (&quot;address&quot; in visitor.extracted_entities and
                &quot;name&quot; not in visitor.extracted_entities):
            visitor.response = &quot;What is your name?&quot;;
        else:
            visitor.response =
                &quot;To set you up with a test drive, we will need your name and address.&quot;;
    }
}
</code></pre>
<p><strong>confirmation_state</strong>
If you were at this state after providing all the information it will respond unique based on your data you provided like &quot;Can you confirm your name to be Yiping and your address as 913 Mandela Avenue?&quot;</p>
<pre><code>node confirmation:va_state {
    has name = &quot;confirmation&quot;;
    can gen_response {
        visitor.response =
            &quot;Can you confirm your name to be &quot; + visitor.extracted_entities[&quot;name&quot;] + &quot; and your address as &quot; + visitor.extracted_entities[&quot;address&quot;] + &quot; ?&quot;;
    }
}
</code></pre>
<p><strong>confirmed_state</strong>
When you confirm it will respond &quot;You are all set for a Tesla test drive!&quot;</p>
<pre><code>node confirmed:va_state {
    has name = &quot;confirmed&quot;;
    can gen_response {
        visitor.response = &quot;You are all set for a Tesla test drive!&quot;;
    }
}
</code></pre>
<p><strong>cancelled_state</strong>
If you were at this state and you cancelled it will respond with &quot;No worries. We look forward to hear from you in the future!&quot;.</p>
<pre><code>node canceled:va_state {
    has name = &quot;canceled&quot;;
    can gen_response {
        visitor.response = &quot;No worries. We look forward to hear from you in the future!&quot;;
    }
}
</code></pre>
<p>So as you can see the NLG logic is unique to each conversational state.</p>
<p><strong>NLU logic for faq_state which inherits cai_state</strong></p>
<pre><code>can nlu {
        answers = [];
        for a in -[faq_transition]-&gt;.edge: answers += [a.answer];
        if (answers) {
            res = use.qa_classify(
                text = visitor.question,
                classes = answers
            );
            visitor.matched_answer = res[&quot;match&quot;];
        }
    }
</code></pre>
<p>For the NLU here it iterates the edges in faq_transition as answer and it use the user query (question) and using an AI model it uses the user query to find the most appropriate answer for the user.</p>
<p><strong>NLG logic for faq_state which inherits cai_state</strong></p>
<p>For the NLG logic here it takes the answer provided by the NLU to provide to the user.</p>
<pre><code>can nlg {
        visitor.response = here.answer;
    }
</code></pre>
<p>If you were to interact with the faq state it would use the zero-shot technique to find the appropriate response and if you were to test it based on the information provided in the application it would have respond as follows:</p>
<pre><code>&gt; How do I order a Tesla?
Visit our Design Studio to explore our latest options and place your order. The purchase price and estimated delivery date will change based on your configuration.
</code></pre>
<h3 id="how-to-load-actions"><a class="header" href="#how-to-load-actions">How to load actions</a></h3>
<p>In this section, we will discuss how to load actions in jsctl. There are three ways to load actions in jsctl. They are remote (server), local (custom) , builtin (jaseci built in actions)  The commands to loading actions are as follows:</p>
<p>We first will run the jsctl command in the terminal for jaseci to run it's own shell.</p>
<pre><code>jsctl
</code></pre>
<p>The command below is used for local modules built by the developer. For example if you want to build a custom AI module in python you can use jaseci actions to create the module and use the command below to load it.</p>
<pre><code>jsctl load local PATH_TO_PYTHON_FILE
</code></pre>
<p>The command below is used to load module from a remote jaseci server. For example if there is a bi-enc jaseci module on a server that you want to load into jaseci you can run it using the command below.</p>
<pre><code>jsctl load remote https://bi-enc.org
</code></pre>
<p>This is the command use to run builtin jaseci kit modules that can be accessed anytime as long as you have jaseci installed on your system.</p>
<pre><code>jsctl load module JASECI_KIT_MODULE
</code></pre>
<h3 id="tutorial-on-use_qa"><a class="header" href="#tutorial-on-use_qa">Tutorial on USE_QA</a></h3>
<p><strong>What is the USE_QA model?</strong>
It's a sentence level embeddings which is used to calculate best match between question and available answers via cosine similarity and/or dist_score.</p>
<p><strong>What does it do?</strong>
It is used for text classification. It requires no training data. However it requires you to have the labels (classes) as prerequisite in order for you to match between the user query. </p>
<p><strong>How to load it as an action?</strong>
Above, we showed you how to load actions and now in this section we will show you how to implememt it by loading the use_qa actions. Once you run the command sucessfully you should be able to use all of it's functionality. The command for loading the actions is as follows:</p>
<ul>
<li><code>jsctl</code></li>
<li><code>actions load module jaseci_kit.use_qa</code></li>
</ul>
<p><strong>What does the qa_classify action do?</strong>
qa_classify is a built in function or api used in use_qa module in jaseci kit. It takes in two parameters: text (user input) and classes (list of string) and in returns it gives you the best matching class from the list of classes and this is what we are using for intent classification.</p>
<p>If you look at the code below you will see where it's being implemented.</p>
<pre><code>node faq_state:cai_state {
    has answer;
    can use.qa_classify;
    can nlu {
        answers = [];
        for a in -[faq_transition]-&gt;.edge: answers += [a.answer];
        if (answers) {
            res = use.qa_classify(
                text = visitor.question,
                classes = answers
            );
            visitor.matched_answer = res[&quot;match&quot;];
        }
    }

    can nlg {
        visitor.response = here.answer;
    }
} 
</code></pre>
<p><strong>How is it useful in this FAQ chatbot?</strong>
Let's explain why would this be useful in the FAQ chatbot. Let's say you have a website that have all the information answering questions people would usually asked. In the faq module, what it would do is take all the answers from the website and store it as faq nodes. When a user query it will use that query and based on a cosine similarity algorithm using the use_qa model it will match that query to all the answers in the db and find the most appropriate answer and that's what makes it useful to be used in the FAQ chatbot.</p>
<h3 id="the-faq_state-node-code"><a class="header" href="#the-faq_state-node-code">The faq_state node code</a></h3>
<p>In this section, we will be explaining the code below.</p>
<pre><code>node faq_state:cai_state {
    has answer;
    can use.qa_classify;
    can nlu {
        answers = [];
        for a in -[faq_transition]-&gt;.edge: answers += [a.answer];
        if (answers) {
            res = use.qa_classify(
                text = visitor.question,
                classes = answers
            );
            visitor.matched_answer = res[&quot;match&quot;];
        }
    }

    can nlg {
        visitor.response = here.answer;
    }
} 
</code></pre>
<p>Let's begin. The faq state inherits the cai_state node because it's a part of the conversational state. It accepts <strong>answer</strong> as a parameter and that's all the faq answer node generated from the FAQ. The faq state also inherits a function from the use_qa module called <strong>use.qa_classify</strong> this will be used to find the mathing answer to be returned to the user. use_qa_classify function as discussed in a recent section, intakes two paramters: text (which is the question the user provided) and classes (the answers extracted from the faq_transition edges which is used to store all the answers) and these functions will be called when faq_state calls the nlu node ability and the nlg node ability when executed will return the answer.</p>
<h3 id="the-new-type-of-edge-answer_transition"><a class="header" href="#the-new-type-of-edge-answer_transition">The new type of edge (answer_transition)</a></h3>
<p><strong>What is the answer transition?</strong>
This is a edge transition created for user query to navigate to node with the answer from the FAQ section. It intakes answer as the parameter which is being generated from the nlu.</p>
<pre><code>edge answer_transition {
    has answer;
} 
</code></pre>
<h3 id="the-updated-talk-walker-logic"><a class="header" href="#the-updated-talk-walker-logic">The updated talk walker logic</a></h3>
<p>Take a look carefully at the code below. We will explain step by step of the changes made and why we made it.</p>
<pre><code>walker talk {
    has question=&quot;&quot;;
    has if_nlu=false;
    has predicted_intent = null, extracted_entities = {}, matched_answer = null;
    has response;

    root {
        take --&gt; node::cai_state;
    }

    cai_state {
        if (question == &quot;&quot;) {
            question = std.input(&quot;&gt; &quot;);
            if_nlu = false;
        }

        if (!if_nlu) {
            predicted_intent = null;
            here::nlu;
            if_nlu = true;
        } else {
            # Clear the predicted intent if a NLU based transition has happened
            # This is to prevent infinite loop in certain situation
            predicted_intent = null;
        }

        take -[entity_transition(entities==extracted_entities.d::keys)]-&gt; node::cai_state else {
            take -[intent_transition(intent==predicted_intent)]-&gt; node::cai_state else {
                take -[answer_transition(answer==matched_answer)]-&gt; node::cai_state else {
                    here::nlg;
                    std.out(response);
                    question = &quot;&quot;;
                    take --&gt; node::cai_root else: take here;
                }
            }
        }
    }
}
</code></pre>
<p>Below is the first changes you saw.</p>
<pre><code>matched_answer = null;
</code></pre>
<p>This was created for the FAQ node. This house the answer for the user query passed when it goes through the faq_state nlu node ability. Which will be later used for transition.</p>
<p>Last change you saw is as follows.</p>
<pre><code>take -[answer_transition(answer==matched_answer)]-&gt; node::cai_state else { ... }
</code></pre>
<p>This was created for the faq state node. If all of the rest of transition failed it will take the matched_answer generated from the nlu from the faq_state node match it against the answer_transition and if it gets a response it will trigger the nlg functionality which in return will give the user a response. Thanks to inheritance we were able to share majority of the logic of the talk walker between the VA side and FAQ side because we inherit everything from cai_state. If we didn't inherit the functionalities from cai_state we would have multiple talk walker to do all of the transitions.</p>
<h3 id="the-ingest_faq-walker"><a class="header" href="#the-ingest_faq-walker">The ingest_faq walker</a></h3>
<pre><code>walker ingest_faq {
    has kb_file;
    root: take --&gt; node::faq_state;
    faq_state {
        kb = file.load_json(kb_file);
        for faq in kb {
            answer = faq[&quot;answer&quot;];
            spawn here -[answer_transition(answer=answer)]-&gt; node::faq_state(answer=answer);
        }
    }
}
</code></pre>
<p>So, let's explain what this walker does. Essentially, it takes a kb_file (knowledge base file) in the form of json that have a key of question and a key of answer. Then loop is created in the faq state to spawn answers nodes with answer transition edge from the answers from the knowledge based. This walker just intakes a file and generate faq answer nodes with edges.</p>
<h3 id="interacting-with-the-faq-side-using-the-interactive_faq-walker"><a class="header" href="#interacting-with-the-faq-side-using-the-interactive_faq-walker">Interacting with the FAQ side using the interactive_faq walker</a></h3>
<p>In this section, we will walk you through a session interacting with the faq side. So let's get started.</p>
<p>Let's run jaseci control in the terminal.</p>
<pre><code>jsctl
</code></pre>
<p>Let's run the interactive_faq walker in jsctl.</p>
<pre><code>jac run main.jac -walk interactive_faq
</code></pre>
<p>Let's run a query and see if we get a response.</p>
<pre><code>&gt; how do I configure my order?
To configure your order, log into your Tesla Account and select manage on your existing reservation to configure your Tesla. Your original USD deposit has now been converted to SGD.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci-5"><a class="header" href="#build-a-conversational-ai-system-in-jaseci-5">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-6"><a class="header" href="#chapter-6">Chapter 6</a></h1>
<h2 id="bringing-your-application-to-production"><a class="header" href="#bringing-your-application-to-production">Bringing your application to production</a></h2>
<h3 id="register-and-update-your-jac-code-on-a-remote-instance"><a class="header" href="#register-and-update-your-jac-code-on-a-remote-instance">Register and update your jac code on a remote instance</a></h3>
<p>In this section, we will walk you through on how to register and update your jac code on a remote instance. The steps are as follows:</p>
<h4 id="register-jac-code-on-a-remote-instance"><a class="header" href="#register-jac-code-on-a-remote-instance">Register jac code on a remote instance</a></h4>
<p>First you have to login to jaseci control from the terminal.</p>
<pre><code>jsctl -m
</code></pre>
<p>Then you will login into your remote instance by using the following. It will require you to pass in the username and password.</p>
<pre><code>login [link here]
</code></pre>
<p>Terminal View</p>
<pre><code>&gt; Username: 
test
&gt; Password:
password
</code></pre>
<p>Next step is to load all jaseci actions that the application requires. One of the earlier chapter we explained the ways of loading the actions and how to.</p>
<pre><code>actions load remote [link to jaseci actions on remote]
</code></pre>
<p>We move on to registering the sentinel.</p>
<pre><code>sentinel register -set_active true -mode ir [jir main file of the jaseci application]
</code></pre>
<p>After registering the sentinel we will have to create the graph for application and this goes as follows.</p>
<pre><code>graph create -set_active true
</code></pre>
<p>If you have to delete the graph however, incase of a mistake you can do that using the following command and then you can recreate.</p>
<pre><code>graph delete active:graph
</code></pre>
<p>Next step, you will have to run the init walker</p>
<pre><code>walker run init
</code></pre>
<p>Great, and that's how you register jac code on a remote instance.</p>
<h4 id="updating-jac-code-on-a-remote-instance"><a class="header" href="#updating-jac-code-on-a-remote-instance">Updating jac code on a remote instance</a></h4>
<p>Let us walk you through on how to update jac code on the remote instance. After you make your edits to the main jac file and build it. Run the following command each time you make an update to the jac code.</p>
<pre><code>sentinel set -snt active:sentinel -mode ir [main jir file of the application]
</code></pre>
<h3 id="interact-with-your-jac-application-through-restful-api-endpoints"><a class="header" href="#interact-with-your-jac-application-through-restful-api-endpoints">Interact with your jac application through restful API endpoints</a></h3>
<p>In this section, we will be walking you through on how to interact with your jac application through restful API endpoints, if you notice we have been running all the walker commands on the terminal, let's run it through the API. The steps to interact through the API is as follows:</p>
<pre><code>pip install jaseci-serv
</code></pre>
<p>We will be using jaseci serve to run the application on the webserver</p>
<pre><code>jsserv makemigrations base
</code></pre>
<p>Here we will be making the migrations for the default base module in our jaseci program. This will create a database that will be used to run a jaseci instance of our application. It creates a mydatabase file in your working directory.</p>
<pre><code>jsserv migrate
</code></pre>
<p>This will install the schema and database.</p>
<pre><code>jsserv createsuperuser
</code></pre>
<p>This will allow you to create the account for the server and you will be prompted to enter an email and password.</p>
<pre><code>jsserv runserver 0.0.0.0:8000
</code></pre>
<p>This will start your Jaseci Server to run your application. Visit localhost:8000/docs to check if the webserver is up and running.</p>
<pre><code>REQUEST [POST]: http://localhost:8000/user/token/

PAYLOAD: {
&quot;email&quot; : &quot;email@gmail&quot;,
&quot;password&quot; : &quot;passsword&quot;
}

RESPONSE: {
&quot;expiry&quot;: null, 
&quot;token&quot;: &quot;2b4824cd3136616aa5380580578b2f5d1fccd3cad669f78029911e239300d3c0&quot;
}
</code></pre>
<p>We will send a POST request to /user/token and get a token response now you can now make API calls to your JAC program once you copy token returned. Add it to the authorization header with the word &quot;token&quot; before sending any request. </p>
<pre><code>REQUEST [POST]: http://localhost:8000/js/sentinel_register

PAYLOAD: {
    &quot;name&quot;: &quot;some string&quot;,
    &quot;code&quot;: &quot;some string&quot;,
    &quot;code_dir&quot;: &quot;some string&quot;,
    &quot;mode&quot;: &quot;some string&quot;,
    &quot;encoded&quot;: false,
    &quot;auto_run&quot;: &quot;some string&quot;,
    &quot;auto_run_ctx&quot;: {},
    &quot;auto_create_graph&quot;: false,
    &quot;set_active&quot;: false
}
</code></pre>
<p>This will allow you to register the sentinel for the application.</p>
<pre><code>REQUEST [POST]: http://localhost:8000/js/graph_create

PAYLOAD: {
    &quot;set_active&quot;: false
}
</code></pre>
<p>This will allow you to create a graph instance and return root node graph object</p>
<pre><code>REQUEST [POST]: http://localhost:8000/js/walker_run

PAYLOAD: {
    &quot;name&quot;: &quot;init&quot;,
    &quot;ctx&quot;: {},
    &quot;snt&quot;: &quot;urn:uuid:d32de620-27cd-4920-a31e-2e2f41bc2a9d&quot;,
    &quot;detailed&quot;: false
}
</code></pre>
<p>This request will run the init walker which will spawn the graph and the AI models in the application.</p>
<pre><code>REQUEST [POST]: http://localhost:8000/js/walker_run

PAYLOAD: {
    &quot;name&quot;: &quot;talk&quot;,
    &quot;ctx&quot;: {
        &quot;question&quot;: &quot;i would like to test drive.&quot;
    },
    &quot;snt&quot;: &quot;urn:uuid:d32de620-27cd-4920-a31e-2e2f41bc2a9d&quot;,
    &quot;detailed&quot;: false
}
</code></pre>
<p>For the payload sent to the /js/walker_run, the name (name of walker to be called), ctx (information sent to the walker), snt (sentinel ID  of the program ), detailed (returns additional information for the walker), nd (node walker will be set to, if not included will go to the root node). This is how we interact with jac application through restful API endpoints. In this example we ran the talk walker.</p>
<h2 id="bringing-in-the-ai-models-for-the-dialogue"><a class="header" href="#bringing-in-the-ai-models-for-the-dialogue">Bringing in the AI models for the dialogue</a></h2>
<p>In this section, we will explain how we added the AI model into this application. We have added two AI models the bi-encoder and tfm ner model. Before we explain the code implementation for both models, we will explain the top inheritance AI model they inherit.</p>
<p><strong>Explanation of the ai_model node</strong></p>
<pre><code>    can train with train entry {}
</code></pre>
<p>This allows you to train the ai model and it also inherits the train walker which accepts certain parameters.</p>
<pre><code>    can test_model with test_model entry {}
</code></pre>
<p>This allow you to test the ai model, it inherits the test_model walker.</p>
<pre><code>    can eval with eval entry {
        ::train;
        ::test_model;
    }
</code></pre>
<p>this node ability enables you to evaluate the ai model by training it and testing it when the eval walker is called.</p>
<pre><code>    can infer with infer entry {}
</code></pre>
<p>This node ability allows you to pass query and get a response.</p>
<pre><code>walker train {
    has train_file, num_train_epochs, from_scratch;
    has batch_size, learning_rate;
}
</code></pre>
<p>This walker takes in a few parameters: <strong>train_file</strong> (where the training file is located in the repository). <strong>num_train_epochs</strong> (amount of time you want the ai model to learn from the dataset), <strong>from_scratch</strong> (if you want to train the model from scratch or not), <strong>batch_size</strong> (the number of training examples utilized in one iteration) and <strong>learning_rate</strong> (The amount that the weights are updated during training).</p>
<pre><code>walker test_model {
    has eval_file;
}
</code></pre>
<p>This walker allows you to test the model using the file location you provided in it's parameter.</p>
<pre><code>walker eval {
    has train_file, eval_file, num_train_epochs, from_scratch;
}
</code></pre>
<p>Allows you to evaluate the model.</p>
<pre><code>walker infer {
    has input;
}
</code></pre>
<p>This walker allows you to pass an input (user query) to the parameter and receive the necessary information for that ai model based on the input.</p>
<p><strong>Explanation of the bi_enc node</strong>
In the last section we explained the ai_model node and in this section we integrated the ai_model node into the bi-encoder ai model which is called bi_enc. The explanation of each code input is as follows: </p>
<pre><code>can bi_enc.train, bi_enc.infer, bi_enc.save_model;
</code></pre>
<p>This logic enables you to import functions from the jaseci kit modules imported from actions.</p>
<pre><code>can train {
        train_data = file.load_json(visitor.train_file);
        bi_enc.train(
            dataset=train_data,
            from_scratch=visitor.train_from_scratch,
            training_parameters={
                &quot;num_train_epochs&quot;: visitor.num_train_epochs
            }
        );
        if (visitor.model_name):
            bi_enc.save_model(model_path=visitor.model_name);
    }
</code></pre>
<p>This node ability allows you to train the bi_encoder (bi_enc) model, as you can see it overrides the train function from ai_mode node and it also requires some parameter and these parameter are presented from the walker.</p>
<pre><code>can infer {
        res = bi_enc.infer(
            contexts=[visitor.query],
            candidates=here.candidates,
            context_type=&quot;text&quot;,
            candidate_type=&quot;text&quot;
        )[0];

        max_score = 0;
        max_intent = &quot;&quot;;
        for i=0 to i&lt;res[&quot;candidate&quot;].length by i+=1 {
            if (res[&quot;score&quot;][i] &gt; max_score){
                max_intent = res[&quot;candidate&quot;][i];
                max_score = res[&quot;score&quot;][i];
            }
        }
        report [max_intent, max_score];
    }
</code></pre>
<p>The infer function in the bi_enc module allows you to query the model and receive the intent of the user utterance.</p>
<pre><code>can test_model {
        eval_set = file.load_json(visitor.eval_file);
        candidates = eval_set.dict::keys;

        correct = [];
        failure = [];
        for intent in candidates {
            preds = bi_enc.infer(
                contexts=eval_set[intent],
                candidates=candidates,
                context_type=&quot;text&quot;,
                candidate_type=&quot;text&quot;
            );
            for i=0 to i&lt;preds.length by i+=1 {
                pred = preds[i];
                max_score = 0;
                max_intent = &quot;&quot;;
                for j=0 to j&lt;pred[&quot;candidate&quot;].length by j+=1 {
                    if (pred[&quot;score&quot;][j] &gt; max_score){
                        max_intent = pred[&quot;candidate&quot;][j];
                        max_score = pred[&quot;score&quot;][j];
                    }
                }
                if (intent == max_intent): correct.l::append(eval_set[intent][i]);
                else {
                    failure.l::append({
                        &quot;sent&quot;: eval_set[intent][i],
                        &quot;ground truth&quot;: intent,
                        &quot;prediction&quot;: max_intent
                    });
                }
            }
        }
        report {
            &quot;accuracy&quot;: correct.length/(correct.length+failure.length),
            &quot;correct&quot;: correct.length,
            &quot;failure&quot;: failure.length,
            &quot;failed_sents&quot;: failure
        };
    }
</code></pre>
<p>This node ability allows you to test the model for the bi-encoder.</p>
<p><strong>Explanation of the ent_ext node</strong>
In this section we will explain each functions for the entity extraction model for ent_ext node. The explanation goes as follows:</p>
<pre><code>can ent_ext.entity_detection, ent_ext.train, ent_ext.save_model, ent_ext.load_model;
</code></pre>
<p>This is how we import all the functionalities for the jaseci kit module called ent_ext.</p>
<pre><code>can train {
        train_data = file.load_json(visitor.train_file);

        if(visitor.from_scratch) {
            ent_ext.load_model({&quot;default&quot;: true});
            here.labels = [];
        }
        for item in train_data {
            for ent in item[&quot;entities&quot;] {
                ent_label = ent[&quot;entity_type&quot;];
                if (ent_label not in here.labels): here.labels.l::append(ent_label);
            }
        }
        ent_ext.train(
            train_data=train_data,
            val_data=val_data,
            test_data=test_data,
            train_params={
                &quot;num_epoch&quot;: (visitor.num_train_epochs).int,
                &quot;batch_size&quot;: (visitor.batch_size).int,
                &quot;LR&quot;: (visitor.learning_rate).float
            }
        );
        if (visitor.model_name):
            ent_ext.save_model(model_path=visitor.model_name);
    }
</code></pre>
<p>This is how we train the model, it requires training data, test data, val data, the number of train epochs, batch size and learning rate which was briefly explained in a earlier section.</p>
<pre><code>can infer {
        report ent_ext.entity_detection(
            text=input[&quot;text&quot;],
            ner_labels=input[&quot;labels&quot;]
        );
    }
</code></pre>
<p>This is the node ability which allows you to query (user input) and get back the entity extracted from the user.</p>
<p><strong>Updates to the va_state node</strong>
In this section we will explain the changes made to the va state.</p>
<pre><code>can classify_intent {

        train_data = file.load_json(&quot;data/clf_train.json&quot;);
        candidates = train_data.d::keys;

        res = bi_enc.infer(
            contexts=[visitor.question],
            candidates= candidates,
            context_type=&quot;text&quot;,
            candidate_type=&quot;text&quot;
        );

        for pred in res.list{
            # Sort result
            max_score = 0;
            max_intent = &quot;&quot;;
        
            for i=0 to i &lt; pred[&quot;candidate&quot;].length by i+=1 {
                if (pred[&quot;score&quot;][i] &gt; max_score){
                    max_intent = pred[&quot;candidate&quot;][i];
                    max_score = pred[&quot;score&quot;][i];
                }
            }
        }
        
        visitor.predicted_intent = max_intent;
    }
</code></pre>
<p>At first we had hardcoded data here but it was changed after we brought in the ai models. For the classify intent node we use the bi encoder to do our intent classification. Based on the training data it will generate candidates (intent in this case) and the user query will be passed to the bi encoder model which will return the predicted intent.</p>
<pre><code>can extract_entities {
        labels = [];

        train_data = file.load_json(&quot;data/flair_ner.json&quot;);

        for item in train_data {
            for ent in item[&quot;entities&quot;] {
                ent_label = ent[&quot;entity_type&quot;];
                if (ent_label not in labels): labels.l::append(ent_label);
            }
        }

        entity_result = ent_ext.entity_detection(
            text=visitor.question.str,
            ner_labels=labels.list
        );

        for ent in entity_result['entities'] {
            if (ent[&quot;conf_score&quot;] &gt; 0.4){
                entity_label = ent[&quot;entity_value&quot;];
                entity_text = ent[&quot;entity_text&quot;];
                if (entity_text not in visitor.extracted_entities ) {
                    visitor.extracted_entities[entity_label] = [];
                }
                    visitor.extracted_entities[entity_label] += [entity_text];
            }
            std.out(visitor.extracted_entities);
        }
    }
</code></pre>
<p>This also had hardcoded data however we drafted the ent_ext model into the extract_entities node ability. Which will extract all the required slot data based on the training data provided. When users query it will extract all the features and will be presented for the rest of application to work on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-in-jaseci-6"><a class="header" href="#build-a-conversational-ai-system-in-jaseci-6">Build a conversational AI system in Jaseci</a></h1>
<h1 id="chapter-7"><a class="header" href="#chapter-7">Chapter 7</a></h1>
<h3 id="creating-test-cases"><a class="header" href="#creating-test-cases">Creating Test Cases</a></h3>
<p>In this section we will explain to you the steps required to create test cases in the jac application for this application.</p>
<p>There are multiple ways in creating test in jac and we will explore two ways and each is as follows:</p>
<h4 id="test-1"><a class="header" href="#test-1">Test 1</a></h4>
<p>In the <code>test.jac file</code> we will test the VA and FAQ flow from the file <code>tests.json</code> in the data folder.</p>
<pre><code>walker empty {}
</code></pre>
<p>An empty walker was created to host the loading of the test suite json file. So we can run multiple walker based on the file on top of this walker.</p>
<pre><code>test &quot;testing faq and va flows&quot;
</code></pre>
<p>This is how we label a test. This must go on top on of an unit test.</p>
<pre><code>with graph::tesla_sales_rep by walker::empty {}
</code></pre>
<p>Here we referenced the graph we will be running the test on and which walker will run on top of this graph. This is how we start to create the test.</p>
<pre><code>std.get_report();
</code></pre>
<p>This line of code returns the data returned from a report statement in a walker. This will be very important statement to use in testing.</p>
<pre><code>assert(value_1, value_2);
</code></pre>
<p>In test in jac we mainly use the key <code>assert</code> which checks two values and see whether it's true or false, if it's false the test will fail and if true the test will pass. In this case we us it to match against the response of the current query from the flow file to the response that comes back when data is being reported.</p>
<pre><code>test &quot;testing faq and va flows&quot;
with graph::tesla_sales_rep by walker::empty {
    flows = file.load_json(&quot;data/tests.json&quot;);
    
    for flow in flows {

        for step in flow[&quot;flow&quot;] {

            spawn here walker::talk(
                question=step[&quot;query&quot;]
            );

            res = std.get_report();

            assert(res[-1] == step[&quot;response&quot;]);
        }
    }
}
</code></pre>
<p>Here is the entire test. Essentially, the purpose of this test is to load the test suite with all the flow in a json file and pass each query from the test suite to the walker <code>talk</code> and from the response check if it matched the data from the test suite. If it matches the test will pass if not it will fail.</p>
<h4 id="test-2"><a class="header" href="#test-2">Test 2</a></h4>
<pre><code>test &quot;testing a single query&quot;
with graph::tesla_sales_rep by walker::talk(question=&quot;Hey I would like to go on a test drive&quot;)
{
    res = std.get_report();
    assert(res[-1] == &quot;To set you up with a test drive, we will need your name and address.&quot;);
}
</code></pre>
<p>In this test the only difference from the test above is that we are utilizing a walker that have parameters. This test allow us to test for a single query.</p>
<h4 id="how-to-run-test"><a class="header" href="#how-to-run-test">How to run test</a></h4>
<p>This section will teach you how to run test. To run test use the following command below.</p>
<pre><code>jac test test.jac
</code></pre>
<h3 id="using-yield"><a class="header" href="#using-yield">Using Yield</a></h3>
<p>In this section, we will show you how we utilize yield in this program.</p>
<h4 id="what-is-yield"><a class="header" href="#what-is-yield">What is Yield?</a></h4>
<p>Yield is a way to temporarily suspend the walker and return/report to the user. When the same user calls the same walker, the walker context from previous call is retained and the walker will resume on the node it was going to go to next.</p>
<h4 id="how-is-it-being-utilized-in-this-application"><a class="header" href="#how-is-it-being-utilized-in-this-application">How is it being utilized in this application</a></h4>
<pre><code>if (interactive): std.out(response);
else: yield report response;
</code></pre>
<p>In the <code>main.jac</code> file you see that yield is being implemented. Let's explain this bit of code. If interactive is true everytime you send a query it will print the response to terminal and if it's false it would temporarily suspend the walker and report to the user the response for the query. Below you will see an example.</p>
<pre><code>&gt; I would like to test drive?
To set you up with a test drive, we will need your name and address.
</code></pre>
<p>When interactive is true (this is in the terminal). If you exited out and return to the program it will lose context and will restart from the beginning.</p>
<pre><code>I would like to test drive?

{
  &quot;success&quot;: true,
  &quot;report&quot;: [
    &quot;To set you up with a test drive, we will need your name and address.&quot;
  ],
  &quot;final_node&quot;: &quot;urn:uuid:50baeba7-b14a-4033-8c08-c0389f27bd53&quot;,
  &quot;yielded&quot;: true
}
</code></pre>
<p>When interactive is false, yield comes into place. So if we had to pass another query it will remember the last state it was at and will act accordingly.</p>
<h3 id="global-root_node"><a class="header" href="#global-root_node">Global root_node</a></h3>
<p>In this section, we will explain the architecture of the global root node and how it works in this application. The global root node in this case is the cai_root, it utilizes the use_enc (Universal Sentence Encoder) AI module.</p>
<h4 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h4>
<pre><code>node cai_root {
    has name = &quot;cai_root&quot;;
    can use.text_classify;
    can categorize {
        res = use.text_classify(
            text=visitor.question,
            classes=[
                &quot;i want to test drive&quot;,
                &quot;I have a Model 3 reservation, how do I configure my order&quot;,
                &quot;How do I order a tesla&quot;,
                &quot;Can I request a Test Drive&quot;
            ]
        );
        if (res[&quot;match_idx&quot;] == 0):
            visitor.question_type = &quot;va&quot;;

        else:
            visitor.question_type = &quot;faq&quot;;
    }
}
</code></pre>
<p>As you can see here it uses the sentence encoding model (use.text_classify) function which intakes a query from the user and classes (in this case the questions from the FAQ), this enables it to check match ID and if match ID is equal to zero it will then set the question type to va (virtual assistance) and if it's not equal to zero it will set the question type to faq (frequent asked question) and this will be used for further used for processing, which will be explained next. Simple right, this is how it the categorizing of user query is done.</p>
<pre><code>cai_root {
    if (question_type == &quot;va&quot;):
        take --&gt; node::va_state;
    elif (question_type == &quot;faq&quot;):
        take --&gt; node::faq_state;
}
</code></pre>
<p>In the <code>main.jac</code> file. It will utilize the question type variable to transition to the next node. As you can see if the question type is <code>va</code> it will transition to the va_state and if the question type is <code>faq</code> it will transition the to the faq state.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-conversational-ai-system-with-jaseci"><a class="header" href="#build-a-conversational-ai-system-with-jaseci">Build a Conversational AI System with Jaseci</a></h1>
<p>In this tutorial, you are going to learn how to build a state-of-the-art conversational AI system with Jaseci and the Jac language.
You will learn the basics of Jaseci, training state-of-the-art AI models, and everything in between, in order to create an end-to-end fully-functional conversational AI system.</p>
<p>Excited? Hell yeah! Let's jump in.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>To install jaseci, run this in your development environment:</p>
<pre><code>pip install jaseci
</code></pre>
<p>To test the installation is successful, run:</p>
<pre><code>jsctl --help
</code></pre>
<p><code>jacctl</code> stands for the Jaseci Command Line Interface.
If the command above displays the help menu for <code>jacctl</code>, then you have successfully installed jaseci.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Take a look and get familiarized with these commands while you are at it. <code>jacctl</code> will be frequently used throughout this journey.</p>
</blockquote>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>A few essential concepts to get familiar with.</p>
<h3 id="graph-nodes-edges"><a class="header" href="#graph-nodes-edges">Graph, nodes, edges</a></h3>
<p>Refer to relevant sections of the Jaseci Bible.</p>
<h3 id="walker"><a class="header" href="#walker">Walker</a></h3>
<p>Refer to relevant sections of the Jaseci Bible.</p>
<h1 id="automated-faq-answering-chatbot"><a class="header" href="#automated-faq-answering-chatbot">Automated FAQ answering chatbot</a></h1>
<p>Our conversational AI system will consist of multiple components.
To start, we are going to build a chatbot that can answer FAQ questions without any custom training, using zeroshot NLP models.
At the end of this section, you will have a chatbot that, when given a question, searches in its knowledge base for the most relevant answer and returns that answer.</p>
<p>The use case here is a Tesla FAQ chatbot.
We will be using the list of FAQs from https://www.tesla.com/en_SG/support/faq.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This architecture works for any FAQ topics and use cases. Feel free to pick another product/website/company's FAQ if you'd like!</p>
</blockquote>
<h2 id="define-the-nodes"><a class="header" href="#define-the-nodes">Define the Nodes</a></h2>
<p>We have 3 different types of nodes:</p>
<ul>
<li><code>root</code>: This is the root node of the graph. It is a built-in node type and each graph has one root node only.</li>
<li><code>faq_root</code>: This is the entry point of the FAQ handler. We will make the decision on the most relevant answer at this node.</li>
<li><code>faq_state</code>: This node represents a FAQ entry. It contains a candidate answer from the knowledge base.</li>
</ul>
<p>Now let's define the custom node types.</p>
<pre><code class="language-jac">node faq_root;
node faq_state {
    has question;
    has answer;
}
</code></pre>
<p>The <code>has</code> keyword defines a node's variables. In this case, each <code>faq_state</code> has a <code>question</code> and <code>answer</code>.</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>The <code>root</code> node does not need explicit definition. It is a built-in node type. Avoid using <code>root</code> as a custom node type.</p>
</blockquote>
<h2 id="build-the-graph"><a class="header" href="#build-the-graph">Build the Graph</a></h2>
<p>For this FAQ chatbot, we will build a graph as illustrated here:</p>
<p><img src="examples/CanoniCAI/images/faq_1.png" alt="Architecture of FAQ Bot" /></p>
<p>The idea here is that we will decide which FAQ entry is the most relevant to the incoming question at the <code>faq_root</code> node and then we will traverse to that node to fetch the corresponding answer.</p>
<p>To define this graph architecture:</p>
<pre><code class="language-jac">// Static graph definition
graph faq {
    has anchor faq_root;
    spawn {
        // Spawning the nodes
        faq_root = spawn node::faq_root;
        faq_answer_1 = spawn node::faq_state(
            question=&quot;How do I configure my order?&quot;,
            answer=&quot;To configure your order, log into your Tesla account.&quot;
        );
        faq_answer_2 = spawn node::faq_state(
            question=&quot;How do I order a tesla&quot;,
            answer=&quot;Visit our design studio to place your order.&quot;
        );
        faq_answer_3 = spawn node::faq_state(
            question=&quot;Can I request a test drive&quot;,
            answer=&quot;Yes. You must be a minimum of 25 years of age.&quot;
        );

        // Connecting the nodes together
        faq_root --&gt; faq_answer_1;
        faq_root --&gt; faq_answer_2;
        faq_root --&gt; faq_answer_3;
    }
}
</code></pre>
<p>Let's break down this piece of code.</p>
<p>We observe two uses of the <code>spawn</code> keyword. To spawn a node of a specific type, use the <code>spawn</code> keyword for:</p>
<pre><code class="language-jac">faq_answer_1 = spawn node::faq_state(
    question=&quot;How do I configure my order?&quot;,
    answer=&quot;To configure your order, log into your Tesla account.&quot;,
);
</code></pre>
<p>In the above example, we just spawned a <code>faq_state</code> node called <code>faq_answer_1</code> and initialized its <code>question</code> and <code>answer</code> variables.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>The <code>spawn</code> keyword can be used in this style to spawn many different jaseci objects, such as nodes, graphs and walkers.</p>
</blockquote>
<p>The second usage of <code>spawn</code> is with the graph:</p>
<pre><code class="language-jac">graph faq {
    has anchor faq_root;
    spawn {
       ...
    }
}
</code></pre>
<p>In this context, the <code>spawn</code> designates a code block with programmatic functionality to spawn a subgraph for which the root node of that spawned graph will be the <code>has anchor faq_root</code>.</p>
<p>In this block:</p>
<ul>
<li>We spawn 4 nodes, one of the type <code>faq_root</code> and three of the type <code>faq_state</code>.</li>
<li>We connect each of the faq answer states to the faq root with <code>faq_root --&gt; faq_answer_*</code>.</li>
<li>We set the <code>faq_root</code> as the anchor node of the graph. As we will later see, spawning a graph will return its anchor node.</li>
</ul>
<blockquote>
<p><strong>Warning</strong></p>
<p>An anchor node is required for every graph block. It must be assigned inside the spawn block of the graph definition.</p>
</blockquote>
<h2 id="initialize-the-graph"><a class="header" href="#initialize-the-graph">Initialize the Graph</a></h2>
<p>Similar to nodes, in order to create the graph, we will use the <code>spawn</code> keyword.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::faq;
    }
}
</code></pre>
<p>This is the first walker we have introduced, so let's break it down.</p>
<ul>
<li>The walker is called <code>init</code>.</li>
<li>It contains logic specifically for the <code>root</code> node, meaning that the code inside the <code>root {}</code> block will run <strong>only</strong> on the <code>root</code> node. This syntax applies for any node types, as you will see very soon. Every Jac program starts with a single root node, but as you will later learn, a walker can be executed on any node, though the root is used by default if none is specified.</li>
<li><code>spawn here --&gt; graph::faq</code> creates an instance of the <code>faq</code> graph and connects its anchor node to <code>here</code>, which is the node the walker is currently on.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p><code>init</code> can be viewed as similar to <code>main</code> in Python. It is the default walker to run when no specific walkers are specified for a <code>jac run</code> command.</p>
<p><code>here</code> is a very powerful keyword. It always evaluates to the specific node the walker is currently on. You will be using <code>here</code> a lot throughout this tutorial.</p>
</blockquote>
<h2 id="run-the-init-walker"><a class="header" href="#run-the-init-walker">Run the <code>init</code> Walker</a></h2>
<p>Now, let's run the init walker to initialize the graph.
First put all of the above code snippet into a single jac file and name it <code>main.jac</code>, including</p>
<ul>
<li>nodes definition</li>
<li>graph definition</li>
<li>init walker</li>
</ul>
<p>Run <code>jacctl</code> to get into the jaseci shell environment:</p>
<pre><code class="language-bash">jsctl
</code></pre>
<p>Inside the <code>jacctl</code> shell,</p>
<pre><code class="language-bash">jaseci &gt; jac dot main.jac
</code></pre>
<p>This command runs the <code>init</code> walker of the <code>main.jac</code> program and prints the state of its graph in DOT format after the walker has finished.
<a href="https://graphviz.org/doc/info/lang.html">The DOT language</a> is a popular graph description language widely used for representing complex graphs.</p>
<p>The output should look something like this</p>
<p><img src="examples/CanoniCAI/images/dot_1.png" alt="Dot output for Faq graph" /></p>
<pre><code class="language-dot">strict digraph root {
    &quot;n0&quot; [ id=&quot;0955c04e4ff945b4b836748ef2bbd98a&quot;, label=&quot;n0:root&quot;  ]
    &quot;n1&quot; [ id=&quot;c1240d79110941c1bc2feb18581951bd&quot;, label=&quot;n1:faq_root&quot;  ]
    &quot;n2&quot; [ id=&quot;55333be285c246db88181ac34d16cd20&quot;, label=&quot;n2:faq_state&quot;  ]
    &quot;n3&quot; [ id=&quot;d4fa8f2c46ca463f9237ef818e086a29&quot;, label=&quot;n3:faq_state&quot;  ]
    &quot;n4&quot; [ id=&quot;f7b1c8ae82af4063ad53646adc5544e9&quot;, label=&quot;n4:faq_state&quot;  ]
    &quot;n0&quot; -&gt; &quot;n1&quot; [ id=&quot;a718fd6c938149269d3ade2af2eb023c&quot;, label=&quot;e0&quot; ]
    &quot;n1&quot; -&gt; &quot;n2&quot; [ id=&quot;3757cb15851249b4b6083d7cb3c34f8e&quot;, label=&quot;e1&quot; ]
    &quot;n1&quot; -&gt; &quot;n4&quot; [ id=&quot;626ce784a8f5423cae5d5d5ca857fc5c&quot;, label=&quot;e2&quot; ]
    &quot;n1&quot; -&gt; &quot;n3&quot; [ id=&quot;a609e7b54bde4a6a9c9711afdb123241&quot;, label=&quot;e3&quot; ]
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>We are not going to cover the DOT syntax. There are many resources online if you are interested, e.g., https://graphviz.org/doc/info/lang.html</p>
</blockquote>
<blockquote>
<p><strong>Note</strong></p>
<p>There are tools available to render a graph in DOT format. For example, https://dreampuf.github.io/GraphvizOnline has a WSIWYG editor to render dot graph in real time.</p>
</blockquote>
<p>Congratulations! You have just created your first functional jac program!</p>
<h2 id="ask-the-question"><a class="header" href="#ask-the-question">Ask the Question</a></h2>
<p>Alright, we have initialized the graph.
Now it's time to create the code for the question-answering.
We will start with a simple string matching for the answer selection algorithm.
For this, we will create a new walker called <code>ask</code>.</p>
<pre><code class="language-jac">walker ask {
    has question;
    root {
        question = std.input(&quot;AMA &gt; &quot;);
        take --&gt; node::faq_root;
    }
    faq_root {
        take --&gt; node::faq_state(question==question);
    }
    faq_state {:
        std.out(here.answer);
    }
}
</code></pre>
<p>This walker is more complex than the <code>init</code> one and introduces a few new concepts so let's break it down!</p>
<ul>
<li>Similar to nodes, walkers can also contain <code>has</code> variables. They define variables of the walker. They can also be passed as parameters when calling the walker.</li>
<li><code>std.input</code> and <code>std.out</code> read and write to the command line respectively.</li>
<li>This walker has logic for three types of node: <code>root</code>, <code>faq_root</code> and <code>faq_state</code>.
<ul>
<li><code>root</code>: It simply traverses to the <code>faq_root</code> node.</li>
<li><code>faq_root</code>: This is where the answer selection algorithm is. We will find the most relevant <code>faq_state</code> and then traverse to that node via a <code>take</code> statement. In this code snippet, we are using a very simple (and limited) string matching approach to try to match the predefined FAQ question with the user question.</li>
<li><code>faq_state</code>: Print the answer to the terminal.</li>
</ul>
</li>
</ul>
<p>Before we run this walker, we are going to update the <code>init</code> walker to speed up our development process</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::faq;
        spawn here walker::ask;
    }
}
</code></pre>
<p>This serves as a shorthand so that we can initialize the graph and ask a question in one command.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This demonstrates how one walker can spawn another walker using the <code>spawn</code> keyword.</p>
</blockquote>
<p>Time to run the walker!</p>
<pre><code class="language-bash">jaseci &gt; jac run main.jac
</code></pre>
<p><code>jac run</code> functions very similarly to <code>jac dot</code>, with the only difference being that it doesn't return the graph in DOT format.
Try giving it one of the three questions we have predefined and it should respond with the corresponding answer.</p>
<h2 id="introducing-universal-sentence-encoder"><a class="header" href="#introducing-universal-sentence-encoder">Introducing Universal Sentence Encoder</a></h2>
<p>Now, obviously, what we have now is not very &quot;AI&quot; and we need to fix that.
We are going to use the Universal Sentence Encoder QA model as the answer selection algorithm.
Universal Sentence Encoder is a language encoder model that is pre-trained on a large corpus of natural language data and has been shown to be effective in many NLP tasks.
In our application, we are using it for zero-shot question-answering, i.e. no custom training required.</p>
<p>Jaseci has a set of built-in libraries or packages that are called Jaseci actions.
These actions cover a wide-range of state-of-the-art AI models across many different NLP tasks.
These actions are packaged in a Python module called <code>jaseci_kit</code>.</p>
<p>To install <code>jaseci_kit</code>:</p>
<pre><code class="language-bash">pip install jaseci_kit
</code></pre>
<p>Now we load the action we need into our jaseci environment</p>
<pre><code class="language-bash">jaseci &gt; actions load module jaseci_kit.use_qa
</code></pre>
<p>Let's update our walker logic to use the USE QA model:</p>
<pre><code class="language-jac">walker ask {
    can use.qa_classify;
    has question;
    root {
        question = std.input(&quot;&gt;&quot;);
        take --&gt; node::faq_root;
    }
    faq_root {
        answers = --&gt;.answer;
        best_answer = use.qa_classify(
            text = question,
            classes = answers
        );
        take --&gt; node::faq_state(answer==best_answer[&quot;match&quot;]);
    }
    faq_state {
        std.out(here.answer);
    }
}
</code></pre>
<p>Even though there are only 5 lines of new code, there are many interesting aspects, so let's break it down!</p>
<ul>
<li><code>--&gt;.answer</code> collects the <code>answer</code> variable of all of the nodes that are connected to <code>here</code>/<code>faq_root</code> with a <code>--&gt;</code> connection.</li>
<li><code>use.qa_classify</code> is one of the action supported by the USE QA action set. It takes in a question and a list of candidate answers and return the most relevant one.</li>
</ul>
<p>Now let's run this new updated walker and you can now ask questions that are relevant to the answers beyond just the predefined ones.</p>
<h2 id="scale-it-out"><a class="header" href="#scale-it-out">Scale it Out</a></h2>
<p>So far we have created a FAQ bot that is capable of providing answer in three topics.
To make this useful beyond just a prototype, we are now going to expand its database of answers.
Instead of manually spawning and connecting a node for each FAQ entry, we are going to write a walker that automatically expands our graph:</p>
<pre><code class="language-jac">walker ingest_faq {
    has kb_file;
    root: take --&gt; node::faq_root;
    faq_root {
        kb = file.load_json(kb_file);
        for faq in kb {
            answer = faq[&quot;answer&quot;];
            spawn here --&gt; node::faq_state(answer=answer);
        }
    }
}
</code></pre>
<p>An example knowledge base file look like this</p>
<pre><code class="language-jacon">[
  {
    &quot;question&quot;: &quot;I have a Model 3 reservation, how do I configure my order?&quot;,
    &quot;answer&quot;: &quot;To configure your order, log into your Tesla Account and select manage on your existing reservation to configure your Tesla. Your original USD deposit has now been converted to SGD.&quot;
  },
  {
    &quot;question&quot;: &quot;How do I order a Tesla?&quot;,
    &quot;answer&quot;: &quot;Visit our Design Studio to explore our latest options and place your order. The purchase price and estimated delivery date will change based on your configuration.&quot;
  },
  {
    &quot;question&quot;: &quot;Can I request a Test Drive?&quot;,
    &quot;answer&quot;: &quot;Yes, you can request for a test drive. Please note that drivers must be a minimum of 25 years of age and not exceeding 65 years of age, hold a full driving license with over 2 years of driving experience. Insurance conditions relating to your specific status must be reviewed and accepted prior to the test drive.&quot;
  }
]
</code></pre>
<p>Save the above json in a file named <code>tesla_faq.json</code> and make sure it is in the same location as <code>main.jac</code>.
Let's now update the <code>init</code> walker.
Because we are going to use the <code>ingest_faq</code> walker to generate the graph, we won't need the static graph definition.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; node::faq_root;
        spawn here walker::ingest_faq(kb_file=&quot;tesla_faq.json&quot;);
        spawn here walker::ask;
    }
}
</code></pre>
<p>What we are doing here is</p>
<ul>
<li>Spawning a <code>faq_root</code> node</li>
<li>Running the <code>ingest_faq</code> walker to create the neccessary <code>faq_state</code> nodes based on the question-answer entries in the <code>tesla_faq.json</code> file.</li>
<li>Launching the <code>ask</code> walker</li>
</ul>
<p>Let's run the program one more time and test it out!</p>
<pre><code class="language-bash">jaseci &gt; jac run main.jac
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Try more varied questions. Now we have a longer answer with more rich information, it has a higher coverage of information that will be able to answer more questions.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong></p>
<p>If you are feeling adventurous, try downloading the complete list of entires on the Tesla FAQ page and use it to create a production-level FAQ bot. See if you can push the model to its limit!</p>
</blockquote>
<h1 id="next-up"><a class="header" href="#next-up">Next up!</a></h1>
<p><img src="examples/CanoniCAI/images/arch.png" alt="Full architecture of Tesla AI" /></p>
<p>Here is a preview on what's next to come in this journey!</p>
<p>On the right is the architecture diagram of the complete system we are going to build. Here are the major components:</p>
<ul>
<li>Zero-shot FAQ (what we have built so far).</li>
<li>Action-oriented Multi-turn Dialogue System.</li>
<li>Training and inference with an intent classification model.</li>
<li>Training and inference with an entity extraction model.</li>
<li>Testing.</li>
<li>Deploying your Jac application to a production environment.</li>
<li>Training data collection and curation.</li>
</ul>
<h1 id="a-multi-turn-action-oriented-dialogue-system"><a class="header" href="#a-multi-turn-action-oriented-dialogue-system">A Multi-turn Action-oriented Dialogue System</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In the previous section, we built a FAQ chabot.
It can search in a knowledge base of answers and find the most relevant one to a user's question.
While ths covers many diverse topics, certain user request can not be satisfied by a single answer.
For example, you might be looking to open a new bank account which requires mulitple different pieces of information about you.
Or, you might be making a reservation at a restaurant which requires information such as date, time and size of your group.
We refer to these as action-oriented conversational AI requests, as they often lead to a certain action or objective.</p>
<p>When interacting with a real human agent to accomplish this type of action-oriented requests, the interaction can get messy and unscripted and it also varies from person to person.
Again, use the restaurant reservation as an example, one migh prefer to follow the guidance of the agent and provide one piece of information at a time, while others might prefer to provide all the neccessary information in one sentence at the beginning of the interaction.</p>
<p>Therefore, in order to build a robust and flexible conversational AI to mimic a real human agent to support these types of messy action-oriented requests, we are going to need an architecture that is different than the single-turn FAQ.</p>
<p>And that is what we are going to build in this section -- a multi-turn action-oriented dialogue system.</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>Start a new jac file (<code>dialogue.jac</code>) before moving fowrard. We will keep this program separate from the FAQ one we built. But, KEEP the FAQ jac file around, we will integrate these two systems into one unified conversational AI system later.</p>
</blockquote>
<h2 id="state-graph"><a class="header" href="#state-graph">State Graph</a></h2>
<p>Let's first go over the graph architecture for the dialogue system.
We will be building a state graph.
In a state graph, each node is a conversational state, which represent a possible user state during a dialgoue.
The state nodes are connected with transition edges, which encode the condition required to hop from one state to another state.
The conditions are often based on the user's input.</p>
<h2 id="define-the-state-nodes"><a class="header" href="#define-the-state-nodes">Define the State Nodes</a></h2>
<p>We will start by defining the node types.</p>
<pre><code class="language-jac">node dialogue_root;

node dialogue_state {
    has name;
    has response;
}
</code></pre>
<p>Here we have a <code>dialogue_root</code> as the entry point to the dialogue system and multiple <code>dialogue_state</code> nodes representing the conversational states.
These nodes will be connected with a new type of edge <code>intent_transition</code>.</p>
<h2 id="custom-edges"><a class="header" href="#custom-edges">Custom Edges</a></h2>
<pre><code class="language-jac">edge intent_transition {
    has intent;
}
</code></pre>
<p>This is the first custom edge we have introduced.
In jac, just like nodes, you can define custom edge type and edges can also have <code>has</code> variables.</p>
<p>In this case, we created an edge for intent transition. This is a state transition that will be triggered conditioned on its intent being detected from the user's input question.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Custom edge type and variables enable us to encode information into edges in addition to nodes. This is crucial for building a robust and flexible graph.</p>
</blockquote>
<h2 id="build-the-graph-1"><a class="header" href="#build-the-graph-1">Build the graph</a></h2>
<p>Let's build the first graph for the dialogue system.</p>
<pre><code class="language-jac">graph dialogue_system {
    has anchor dialogue_root;
    spawn {
        dialogue_root = spawn node::dialogue_root;
        test_drive_state = spawn node::dialogue_state(
            name = &quot;test_drive&quot;,
            response = &quot;Your test drive is scheduled for Jan 1st, 2023.&quot;
        );
        how_to_order_state = spawn node::dialogue_state (
            name = &quot;how_to_order&quot;,
            response = &quot;You can order a Tesla through our design studio.&quot;
        );

        dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;
        dialogue_root -[intent_transition(intent=&quot;order a tesla&quot;)]-&gt; how_to_order_state;
    }
}
</code></pre>
<p>We have already covered the syntax for graph definition, such as the <code>anchor</code> node and the <code>spawn</code> block in the previous section.
Refer to the FAQ graph definition step if you need a refresher.</p>
<p>We have a new language syntax here <code>dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;</code>.
Let's break this down!</p>
<ul>
<li>If you recall, we have used a similar but simpler syntax to connect two nodes with an edge <code>faq_root --&gt; faq_state;</code>. This connect <code>faq_root</code> to <code>faq_state</code> with a <strong>generic</strong> edge pointing to <code>faq_state</code>;</li>
<li>In <code>dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;</code>, we are connecting the two states with a <strong>custom</strong> edge of the type <code>intent_transition</code>.</li>
<li>In addition, we are initializing the variable <code>intent</code> of the edge to be <code>test drive</code>.</li>
</ul>
<p>To summarize, with this graph, a user will start at the dialogue root state when they first start the conversation.
Then based on the user's question and its intent, we will</p>
<h2 id="initialize-the-graph-1"><a class="header" href="#initialize-the-graph-1">Initialize the graph</a></h2>
<p>Let's create an <code>init</code> walker to for this new jac program.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::dialogue_system;
    }
}
</code></pre>
<p>Put all the code so far in a new file and name it <code>dialogue.jac</code>.</p>
<p>Let's initialize the graph and visualize it.</p>
<pre><code class="language-bash">jaseci &gt; jac dot dialogue.jac
</code></pre>
<pre><code class="language-dot">strict digraph root {
    &quot;n0&quot; [ id=&quot;7b4ee7198c5b4dcd8acfcf739d6971fe&quot;, label=&quot;n0:root&quot;  ]
    &quot;n1&quot; [ id=&quot;7caf939cfbce40d4968d904052368f30&quot;, label=&quot;n1:dialogue_root&quot;  ]
    &quot;n2&quot; [ id=&quot;2e06be95aed449b59056e07f2077d854&quot;, label=&quot;n2:dialogue_state&quot;  ]
    &quot;n3&quot; [ id=&quot;4aa3e21e13eb4fb99926a465528ae753&quot;, label=&quot;n3:dialogue_state&quot;  ]
    &quot;n1&quot; -&gt; &quot;n3&quot; [ id=&quot;6589c6d0dd67425ead843031c013d0fc&quot;, label=&quot;e0:intent_transition&quot; ]
    &quot;n1&quot; -&gt; &quot;n2&quot; [ id=&quot;f4c9981031a7446b855ec91b89aaa5ee&quot;, label=&quot;e1:intent_transition&quot; ]
    &quot;n0&quot; -&gt; &quot;n1&quot; [ id=&quot;bec764e7ee4048898799c2a4f01b9edb&quot;, label=&quot;e2&quot; ]
}
</code></pre>
<p><img src="examples/CanoniCAI/images/dialogue/dot_1.png" alt="DOT of the dialogue system" /></p>
<h2 id="build-the-walker-logic"><a class="header" href="#build-the-walker-logic">Build the Walker Logic</a></h2>
<p>Let's now start building the walker to interact with this dialogue system.</p>
<pre><code class="language-jac">walker talk {
    has question;
    root {
        question = std.input(&quot;&gt; &quot;);
        take --&gt; node::dialogue_root;
    }
    dialogue_root {
        take -[intent_transition(intent==question)]-&gt; node::dialogue_state;
    }
    dialogue_state {
        std.out(here.response);
    }
}
</code></pre>
<p>Similar to the first walker we built for the FAQ system, we are starting with a simple string matching algorithm.
Let's update the init walker to include this walker.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::dialogue_system;
        spawn here walker::talk;
    }
}
</code></pre>
<p>Try out the following interactions</p>
<pre><code class="language-bash">$ jsctl jac run dialogue.jac
&gt; test drive
Your test drive is scheduled for Jan 1st, 2023.
{
  &quot;success&quot;: true,
  &quot;report&quot;: [],
  &quot;final_node&quot;: &quot;urn:uuid:9b8d9e1e-d7fb-4e6e-ae86-7ef7c7ad28a7&quot;,
  &quot;yielded&quot;: false
}
</code></pre>
<p>and</p>
<pre><code class="language-bash">$ jsctl jac run dialogue.jac
&gt; order a tesla
You can order a Tesla through our design studio.
{
  &quot;success&quot;: true,
  &quot;report&quot;: [],
  &quot;final_node&quot;: &quot;urn:uuid:168590aa-d579-4f22-afe7-da75ab7eefa3&quot;,
  &quot;yielded&quot;: false
}
</code></pre>
<p>What is happening here is based on the user's question, we are traversing the corresponding dialogue state and then return the response of that state.
For now, we are just matching the incoming question with the intent label as a simple algorithm, which we will now replace with an AI model.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Notice we are running <code>jacctl</code> commands directly from the terminal without first entering the jaseci shell? Any <code>jacctl</code> commands can be launched directly from the terminal by just prepending it with <code>jacctl</code>. Try it with the other <code>jacctl</code> comamnds we have encountered so far, such as <code>jac dot</code>.</p>
</blockquote>
<h2 id="intent-classificaiton-with-bi-encoder"><a class="header" href="#intent-classificaiton-with-bi-encoder">Intent classificaiton with Bi-encoder</a></h2>
<p>Let's introduce an intent classification AI model.
Intent Classification is the task of detecting and assigning one of a list of pre-defined intents to a given piece of text, to summarize what the text is conveying or asking.
It's one of the fundamental tasks in Natural Language Processing (NLP) with broad applications in many areas.</p>
<p>There are many models that have been proposed and applied to intent classification.
For this tutorial, we are going to use a Bi-Encoder model.
A Bi-encoder model has two transformer-based encoders that each encodes the input text and candidate intent labels into embedding vectors and then the model compare the similarity between the embedding vectors to find the most relevant/fitting intent label.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>If you don't fully understand the Bi-encoder model yet, do not worry! We will provide the neccessary code and tooling for you to wield this model as a black box. But, if you are interested, here is a paper for you to read up on it https://arxiv.org/pdf/1908.10084.pdf!</p>
</blockquote>
<p>Now let's train the model.
We have created a jac program and sample training data for this.
They are in the <code>code</code> directory next to this tutorial.
Copy <code>bi_enc.jac</code> and <code>clf_train_1.json</code> to your working directory.</p>
<p>You will find the Files <a href="https://github.com/Jaseci-Labs/jaseci/tree/main/examples/CanoniCAI/code">here</a></p>
<p>Let's first load the Bi-encoder action library into Jaseci.</p>
<pre><code class="language-bash">$ jsctl
jaseci &gt; actions load module jaseci_kit.bi_enc
</code></pre>
<p>We have provided an example training file that contains some starting point training data for the two intents, <code>test drive</code> and <code>order a tesla</code>.</p>
<pre><code class="language-jac">jaseci &gt; jac run bi_enc.jac -walk train -ctx &quot;{\&quot;train_file\&quot;: \&quot;clf_train_1.json\&quot;}&quot;
</code></pre>
<p>We are still using <code>jac run</code> but as you have noticied, this time we are using some new arguments. So let's break it down.</p>
<ul>
<li><code>-walk</code> specifies the name of the walker to run. By default, it runs the <code>init</code> walker.</li>
<li><code>-ctx</code> stands for <code>context</code>. This lets us provide input parameters to the walker. The input parameters are defined as <code>has</code> variables in the walker.</li>
</ul>
<blockquote>
<p><strong>Warning</strong></p>
<p><code>-ctx</code> expects a json string that contains a dictionary of parameters and their value. Since we are running this on the command line, you will need to escape the quotation marks <code>&quot;</code> properly for it to be a valid json string. Pay close attention to the example here <code>-ctx &quot;{\&quot;train_file\&quot;: \&quot;clf_train_1.json\&quot;}&quot;</code> and uses this as a reference.</p>
</blockquote>
<p>You should see an output block that looks like the following repeating many times on your screen:</p>
<pre><code class="language-bash">...
Epoch : 5
loss : 0.10562849541505177
LR : 0.0009854014598540146
...
</code></pre>
<p>Each training epoch, the above output will print with the training loss and learning rate at that epoch.
By default, the model is trained for 50 epochs.</p>
<p>If the training successfully finishes, you should see <code>&quot;success&quot;: true</code> at the end.</p>
<p>Now that the model has finished training, let's try it out!
You can use the <code>infer</code> walker to play with the model and test it out! <code>infer</code> is short for inference, which means using a trained model to run prediction on a given input.</p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk infer -ctx &quot;{\&quot;labels\&quot;: [\&quot;test drive\&quot;, \&quot;order a tesla\&quot;]}&quot;
</code></pre>
<p>Similar to training, we are using <code>jac run</code> to specifically invoke the <code>infer</code> walker and providing it with custom parameters.
The custom paremeter is the list of candidate intent labels, which are <code>test drive</code> and <code>order a tesla</code> in this case, as these were the intents the model was trained on.</p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk infer -ctx &quot;{\&quot;labels\&quot;: [\&quot;test drive\&quot;, \&quot;order a tesla\&quot;]}&quot;
Enter input text (Ctrl-C to exit)&gt; i want to order a tesla
{&quot;label&quot;: &quot;order a tesla&quot;, &quot;score&quot;: 9.812651595405981}
Enter input text (Ctrl-C to exit)&gt; i want to test drive
{&quot;label&quot;: &quot;test drive&quot;, &quot;score&quot;: 6.931458692617463}
Enter input text (Ctrl-C to exit)&gt;
</code></pre>
<p>In the output here, <code>label</code> is the predicted intent label and <code>score</code> is the score assigned by the model to that intent.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>One of the advantage of the bi-encoder model is that candidate intent labels can be dynamically defined at inference time, post training. This enables us to create custom contextual classifiers situationally from a single trained model. We will leverage this later as our dialogue system becomes more complex.</p>
</blockquote>
<p>Congratulations! You just trained your first intent classifier, easy as that.</p>
<p>The trained model is kept in memory and active until they are explicitly saved with <code>save_model</code>. To save the trained model to a location of your choosing, run</p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk save_model -ctx &quot;{\&quot;model_path\&quot;: \&quot;dialogue_intent_model\&quot;}&quot;
</code></pre>
<p>Similarly, you can load a saved model with <code>load_model</code></p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk load_model -ctx &quot;{\&quot;model_path\&quot;: \&quot;dialogue_intent_model\&quot;}&quot;
</code></pre>
<p>Always remember to save your trained models!</p>
<blockquote>
<p><strong>Warning</strong></p>
<p><code>save_model</code> works with relative path. When a relative model path is specified, it will save the model at the location relative to <strong>location of where you run jsctl</strong>. Note that until the model is saved, the trained weights will stay in memory, which means that it will not persisit between <code>jacctl</code> session. So once you have a trained model you like, make sure to save them so you can load them back in the next jsctl session.</p>
</blockquote>
<h2 id="integrate-the-intent-classifier"><a class="header" href="#integrate-the-intent-classifier">Integrate the Intent Classifier</a></h2>
<p>Now let's update our walker to use the trained intent classifier.</p>
<pre><code class="language-jac">walker talk {
    has question;
    can bi_enc.infer;
    root {
        question = std.input(&quot;&gt; &quot;);
        take --&gt; node::dialogue_root;
    }
    dialogue_root {
        intent_labels = -[intent_transition]-&gt;.edge.intent;
        predicted_intent = bi_enc.infer(
            contexts = [question],
            candidates = intent_labels,
            context_type = &quot;text&quot;,
            candidate_type = &quot;text&quot;
        )[0][&quot;predicted&quot;][&quot;label&quot;];
        take -[intent_transition(intent==predicted_intent)]-&gt; node::dialogue_state;
    }
    dialogue_state {
        std.out(here.response);
    }
}
</code></pre>
<p><code>intent_labels = -[intent_transition]-&gt;.edge.intent</code> collects the <code>intent</code> variables of all the outgoing <code>intent_transition</code> edges. This represents the list of candidate intent labels for this state.</p>
<p>Try playing with different questions, such as</p>
<pre><code class="language-bash">$ jsctl
jaseci &gt; jac run dialogue.jac
&gt; hey yo, I heard tesla cars are great, how do i get one?
You can order a Tesla through our design studio.
{
  &quot;success&quot;: true,
  &quot;report&quot;: [],
  &quot;final_node&quot;: &quot;urn:uuid:af667fdf-c2b0-4443-9ccd-7312bc4c66c4&quot;,
  &quot;yielded&quot;: false
}
</code></pre>
<h2 id="making-our-dialogue-system-multi-turn"><a class="header" href="#making-our-dialogue-system-multi-turn">Making Our Dialogue System Multi-turn</a></h2>
<p>Dialogues in real life have many turn of interaction.
Our dialogue system should also support that to provide a human-like conversational experinece.
In this section, we are going to take the dialogue system to the next level and create a multi-turn dialogue experience.</p>
<p>Before we do that we need to introduce two new concepts in Jac: node abilities and inheritance.</p>
<h3 id="node-abilities"><a class="header" href="#node-abilities">Node Abilities</a></h3>
<p>Node abilities are code that encoded as part of each node type.
They often contain logic that read, write and generally manipulate the variables and states of the nodes.
Node abilities are defined with the <code>can</code> keyword inside the definition of nodes, for example, in the code below, <code>get_plate_number</code> is an ability of the <code>vehicle</code> node.</p>
<pre><code class="language-jac">node vehicle {
    has plate_numer;
    can get_plate_numer {
        report here.plate_number;
    }
}
</code></pre>
<p>To learn more about node abilities, refer to the relevant sections of the Jaseci Bible.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Node abilities look and function similarly to member functions in object-oriented programming (OOP). However, there is a key difference in the concepts. Node abilities are the key concept in data-spatial programming, where the logic should stay close to its working set data in terms of the programming syntax.</p>
</blockquote>
<h3 id="inheritance-1"><a class="header" href="#inheritance-1">Inheritance</a></h3>
<p>Jac supports inheritance for nodes and edges.
Node variables (defined with <code>has</code>) and node abilities (defined with <code>can</code>) are inherited and can be overwritten by children nodes.</p>
<p>Here is an example:</p>
<pre><code class="language-jac">node vehicle {
    has plate_number;
    can get_plate_number {
        report here.plate_number;
    }
}

node car:vehicle {
    has plate_number = &quot;RAC001&quot;;
}

node bus:vehicle {
    has plate_number = &quot;SUB002&quot;;
}
</code></pre>
<p>To learn more about inheritance in Jac, refer to the relevant sections of the Jaseci Bible.</p>
<h2 id="build-the-multi-turn-dialogue-graph"><a class="header" href="#build-the-multi-turn-dialogue-graph">Build the Multi-turn Dialogue Graph</a></h2>
<p>Now that we have learnt about node abilities and node inheritance, let's put these new concepts to use to build a new graph for the multi-turn dialogue system</p>
<p>There are multiple parts to this so let's break it down one by one</p>
<h3 id="dialogue-state-specific-logic"><a class="header" href="#dialogue-state-specific-logic">Dialogue State Specific Logic</a></h3>
<p>With the node abilities and node inheritance, we will now introduce state specific logic.
Take a look at how the <code>dialogue_root</code> node definition has changed.</p>
<pre><code class="language-jac">node dialogue_state {
    can bi_enc.infer;
    can tfm_ner.extract_entity;

    can classify_intent {
        intent_labels = -[intent_transition]-&gt;.edge.intent;
        visitor.wlk_ctx[&quot;intent&quot;] = bi_enc.infer(
            contexts = [visitor.question],
            candidates = intent_labels,
            context_type = &quot;text&quot;,
            candidate_type = &quot;text&quot;
        )[0][&quot;predicted&quot;][&quot;label&quot;];
    }

    can extract_entities {
        // Entity extraction logic will be added a bit later on.
    }

    can init_wlk_ctx {
        new_wlk_ctx = {
            &quot;intent&quot;: null,
            &quot;entities&quot;: {},
            &quot;prev_state&quot;: null,
            &quot;next_state&quot;: null,
            &quot;respond&quot;: false
        };
        if (&quot;entities&quot; in visitor.wlk_ctx) {
            // Carry over extracted entities from previous interaction
            new_wlk_ctx[&quot;entities&quot;] = visitor.wlk_ctx[&quot;entities&quot;];
        }
        visitor.wlk_ctx = new_wlk_ctx;
    }
    can nlu {}
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = net.root();
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {}
}

node dialogue_root:dialogue_state {
    has name = &quot;dialogue_root&quot;;
    can nlu {
        ::classify_intent;
    }
    can process {
        visitor.wlk_ctx[&quot;next_state&quot;] = (-[intent_transition(intent==visitor.wlk_ctx[&quot;intent&quot;])]-&gt;)[0];
    }
    can nlg {
        visitor.response = &quot;Sorry I can't handle that just yet. Anything else I can help you with?&quot;;
    }
}
</code></pre>
<p>There are many interesting things going on in these ~30 lines of code so let's break it down!</p>
<ul>
<li>The <code>dialogue_state</code> node is the parent node and it is similar to a virtual class in OOP. It defines the variables and abilities of the nodes but the details of the abilities will be specified in the inheriting children nodes.</li>
<li>In this case, <code>dialogue_state</code> has 4 node abilities:
<ul>
<li><code>can nlu</code>: NLU stands for Natural Language Understanding. This ability will analyze user's incoming requset and apply AI models.</li>
<li><code>can process</code>: This ability uses the NLU results and figure out the next dialogue state the walker should go to.</li>
<li><code>can nlg</code>: NLG stands for Natural Language Generation. This abilitiy will compose response to the user, often based on the results from <code>nlu</code>.</li>
<li><code>can classify_intent</code>: an ability to handle intent classification. This is the same intent classification logic that has been copied over from the walker.</li>
<li><code>can extract_entities</code>: a new ability with a new AI model -- entity extraction. We will cover that just in a little bit (read on!).</li>
</ul>
</li>
<li>Between these four node abilities, <code>classify_intent</code> and <code>extract_entities</code> have concrete logic defined while <code>nlu</code> and <code>nlg</code> are &quot;virtual node abilities&quot;, which will be specified in each of the inheriting children.</li>
<li>For example, <code>dialogue_root</code> inherit from <code>dialogue_state</code> and overwrites <code>nlu</code> and <code>nlg</code>:
<ul>
<li>for <code>nlu</code>, it invokes intent classification because it needs to decide what's the intent of the user (test drive vs order a tesla).</li>
<li>for <code>nlg</code>, it just has a general fall-back response in case the system can't handle user's ask.</li>
</ul>
</li>
<li><strong>New Syntax</strong>: <code>visitor</code> is the walker that is &quot;visiting&quot; the node. And through <code>visitor.*</code>, the node abilities can access and update the context of the walker. In this case, the node abilities are updating the <code>response</code> variable in the walker's context so that the walker can return the response to its caller, as well as the <code>wlk_ctx</code> variable that will contain various walker context as the walker traverse the graph.
<ul>
<li>the <code>init_wlk_ctx</code> ability initializes the <code>wlk_ctx</code> variable for each new question.</li>
</ul>
</li>
</ul>
<p>In this new node architecture, each dialogue state will have its own node type, specifying their state-specific logic in <code>nlu</code>, <code>nlg</code> and <code>process</code>.
Let's take a look!</p>
<pre><code class="language-jac">node how_to_order_state:dialogue_state {
    has name = &quot;how_to_order&quot;;
    can nlg {
        visitor.response = &quot;You can order a Telsa through our design studio&quot;;
    }
}

node test_drive_state:dialogue_state {
    has name = &quot;test_drive&quot;;
    can nlu {
        if (!visitor.wlk_ctx[&quot;intent&quot;]): ::classify_intent;
        ::extract_entities;
    }
    can process {
        // Check entity transition
        required_entities = -[entity_transition]-&gt;.edge[0].context[&quot;entities&quot;];
        if (vector.sort_by_key(visitor.wlk_ctx[&quot;entities&quot;].d::keys) == vector.sort_by_key(required_entities)) {
            visitor.wlk_ctx[&quot;next_state&quot;] = -[entity_transition]-&gt;[0];
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        } elif (visitor.wlk_ctx[&quot;prev_state&quot;] and !visitor.wlk_ctx[&quot;prev_state&quot;].context[&quot;name&quot;] in [&quot;test_drive&quot;, &quot;td_confirmation&quot;]){
            next_state = -[intent_transition(intent==visitor.wlk_ctx[&quot;intent&quot;])]-&gt;;
            if (next_state.length &gt; 0 and visitor.wlk_ctx[&quot;intent&quot;] != &quot;no&quot;) {
                visitor.wlk_ctx[&quot;next_state&quot;] = next_state[0];
                visitor.wlk_ctx[&quot;prev_state&quot;] = here;
            } else {
                visitor.wlk_ctx[&quot;respond&quot;] = true;
            }
        } else {
            visitor.wlk_ctx[&quot;respond&quot;] = true;
        }
    }
    can nlg {
        if (&quot;name&quot; in visitor.wlk_ctx[&quot;entities&quot;] and &quot;address&quot; not in visitor.wlk_ctx[&quot;entities&quot;]):
            visitor.response = &quot;What is your address?&quot;;
        elif (&quot;address&quot; in visitor.wlk_ctx[&quot;entities&quot;] and &quot;name&quot; not in visitor.wlk_ctx[&quot;entities&quot;]):
            visitor.response = &quot;What is your name?&quot;;
        else:
            visitor.response = &quot;To set you up with a test drive, we will need your name and address.&quot;;
    }
}

node td_confirmation:dialogue_state {
    has name = &quot;test_drive_confirmation&quot;;
    can nlu {
        if (!visitor.wlk_ctx[&quot;intent&quot;]): ::classify_intent;
    }
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = -[intent_transition(intent==visitor.wlk_ctx[&quot;intent&quot;])]-&gt;[0];
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {
        visitor.response =
            &quot;Can you confirm your name to be &quot; + visitor.wlk_ctx[&quot;entities&quot;][&quot;name&quot;][0] + &quot; and your address as &quot; + visitor.wlk_ctx[&quot;entities&quot;][&quot;address&quot;][0] + &quot;?&quot;;
    }
}

node td_confirmed:dialogue_state {
    has name = &quot;test_drive_confirmed&quot;;
    can nlg {
        visitor.response = &quot;You are all set for a Tesla test drive!&quot;;
    }
}

node td_canceled:dialogue_state {
    has name = &quot;test_drive_canceled&quot;;
    can nlg {
        visitor.response = &quot;No worries. We look forward to hearing from you in the future!&quot;;
    }
}
</code></pre>
<ul>
<li>
<p>Each dialogue state now has its own node type, all inheriting from the same generic <code>dialogue_state</code> node type.</p>
</li>
<li>
<p>We have 4 dialogue states here for the test drive capability:</p>
<ul>
<li><code>test_drive</code>: This is the main state of the test drive intent. It is responsible for collecting the neccessary information from the user.</li>
<li><code>test_drive_confirmation</code>: Ths is the state for user to confirm the information they have provided are correct and is ready to actually schedule the test drive.</li>
<li><code>test_drive_confirmed</code>: This is the state after the user has confirmed.</li>
<li><code>test_drive_canceled</code>: User has decided, in the middle of the dialogue, to cancel their request to schedule a test drive.</li>
</ul>
</li>
<li>
<p>The <code>process</code> ability contains the logic that defines the conversational flow of the dialogue system. It uses the data in <code>wlk_ctx</code> and assign a <code>next_state</code> which will be used by the walker in a <code>take</code> statement, as you will see in a just a little bit.</p>
</li>
<li>
<p><strong>New Syntax</strong>: The code in <code>test_drive_state</code>'s ability demonstrates jac support for list and dictionary. To access the list and dictionary-specific functions, first cast the variable with <code>.l</code>/<code>.list</code> for list and <code>.d</code>/<code>.dict</code> for dictionaries, then proceed with <code>:</code> to access the built-in functions for list and dictioinaries. For more on jac's built-in types, refer to the relevant sections of the Jaseci Bible.</p>
<ul>
<li>Specifically in this case, we are comparing the list of entities of the <code>entity_transition</code> edge with the list of entities that have been extracted by the walker and the AI model (stored in <code>wlk_ctx[&quot;entities]</code>). Since there can be multiple entities required and they can be extracted in arbitrary order, we are sorting and then comparing here.</li>
</ul>
</li>
<li>
<p><strong>New Syntax</strong>: <code>-[entity_transition]-&gt;.edge</code> shows how to access the edge variable. Consider <code>-[entity_transition]-&gt;</code> as a filter. It returns all valid nodes that are connected to the implicit <code>here</code> via an <code>entity_transition</code>. On its own, it will return all the qualified nodes. When followed by <code>.edge</code>, it will return the set of edges that are connected to the qualified nodes.</p>
</li>
</ul>
<p>You might notice that some states do not have a <code>process</code> ability.
These are states that do not have any outgoing transitions, which we refer to as leaf nodes.
If these nodes are reached, they indicate that a dialogue has been completed end to end.
The next state for these node will be returning to the root node so that the next dialogue can start fresh.
To facilitate this, we will add the following logic to the <code>process</code> ability of the <strong>parent <code>dialogue_state</code> node</strong> so that by default, any nodes inheriting it will follow this rule.</p>
<pre><code class="language-jac">node dialogue_state {
...
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = net.root();
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
...
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Pay attention to the 4 dialogue states here. This pattern of <code>main</code> -&gt; <code>confirmation</code> -&gt; <code>confirmed</code> -&gt; <code>canceled</code> is a very common conversational state graph design pattern and can apply to many topics, e.g., make a restaurant reservation and opening a new bank account. Essentially, almost any action-oriented requests can leverage this conversational pattern. Keep this in mind!</p>
</blockquote>
<h3 id="entity-extraction-1"><a class="header" href="#entity-extraction-1">Entity Extraction</a></h3>
<p>Previously, we have introduced intent classification and how it helps to build a dialogue system.
We now introduce the second key AI models, that is specifically important for a multi-turn dialogue system, that is entity/slot extraction.</p>
<p>Entity extraction is a NLP task that focuses on extracting words or phrases of interests, or entities, from a given piece of text.
Entity extraction, sometimes also referred to as Named Entity Recognition (NER), is useful in many domains, including information retrieval and conversational AI.
We are going to use a transformer-based entity extraction model for this exercise.</p>
<p>Let's first take a look at how we are going to use an entity model in our program.
Then we will work on training an entity model.</p>
<p>First, we introduce a new type of transition:</p>
<pre><code class="language-jac">edge entity_transition {
    has entities;
}
</code></pre>
<p>Recall the <code>intent_transition</code> that will trigger if the intent is the one that is being predicted.
Similarly, the idea behind an <code>entity_transition</code> is that we will traverse this transition if all the specified entities have been fulfilled, i.e., they have been extracted from user's inputs.</p>
<p>With the <code>entity_transition</code>, let's update our graph</p>
<pre><code class="language-jac">graph dialogue_system {
    has anchor dialogue_root;
    spawn {
        dialogue_root = spawn node::dialogue_root;
        test_drive_state = spawn node::test_drive_state;
        td_confirmation = spawn node::td_confirmation;
        td_confirmed = spawn node::td_confirmed;
        td_canceled = spawn node::td_canceled;

        how_to_order_state = spawn node::how_to_order_state;

        dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;
        test_drive_state -[intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;
        test_drive_state -[entity_transition(entities=[&quot;name&quot;, &quot;address&quot;])]-&gt; td_confirmation;
        test_drive_state -[intent_transition(intent=&quot;provide name or address&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;yes&quot;)]-&gt; td_confirmed;
        td_confirmation - [intent_transition(intent=&quot;no&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;

        dialogue_root -[intent_transition(intent=&quot;order a tesla&quot;)]-&gt; how_to_order_state;
    }
}
</code></pre>
<p>Your graph should look something like this!</p>
<p><img src="examples/CanoniCAI/images/dialogue/multi-turn.png" alt="Multi-turn Dialogue Graph" /></p>
<h2 id="update-the-walker-for-multi-turn-dialogue"><a class="header" href="#update-the-walker-for-multi-turn-dialogue">Update the Walker for Multi-turn Dialogue</a></h2>
<p>Let's now turn our focus to the walker logic</p>
<pre><code class="language-jac">walker talk {
    has question;
    has wlk_ctx = {};
    has response;
    root {
        take --&gt; node::dialogue_root;
    }
    dialogue_state {
        if (!question) {
            question = std.input(&quot;Question (Ctrl-C to exit)&gt; &quot;);
            here::init_wlk_ctx;
        }
        here::nlu;
        here::process;
        if (visitor.wlk_ctx[&quot;respond&quot;]) {
            here::nlg;
            std.out(response);
            question = null;
            take here;
        } else {
            take visitor.wlk_ctx[&quot;next_state&quot;] else: take here;
        }
    }
}
</code></pre>
<p>The walker logic looks very different now. Let's break it down!</p>
<ul>
<li>First off, because the intent classification logic is now a node ability, the walker logic has become simpler and, more importantly, more focused on graph traversal logic without the detailed (and occasionally convoluted) logic required to process to interact with an AI model.</li>
<li><strong>New Syntax</strong>: <code>here::nlu</code> and <code>here::nlg</code> invokes the node abilities. <code>here</code> can be subtitied with any node variables, not just the one the walker is currently on.</li>
</ul>
<p>Now that we have explained some of the new language syntax here, let's go over the overall logic of this walker.
For a new question from the user, the walker will</p>
<ol>
<li>analyze the question (<code>here:nlu</code>) to identify its intent (<code>predicted_intent</code>) and/or extract its entities (<code>extracted_entities</code>).</li>
<li>based on the NLU results, it will traverse the dialogue state graph (the two <code>take</code> statements) to a new dialogue state</li>
<li>at this new dialogue state, it will perform NLU, specific to that state (recall that <code>nlu</code> is a node ability that varies from node to node) and repeat step 2</li>
<li>if the walker can not make any state traversal anymore (<code>take ... else {}</code>), it will construct a response (<code>here::nlg</code>) using the information it has gathered so far (the walker's context) and return that response to the user.</li>
</ol>
<p>If this still sounds fuzzy, don't worry! Let's use a real dialogue as an example to illustrate this.</p>
<pre><code class="language-bash">Turn #1:
    User: hey i want to schedule a test drive
    Tesla AI: To set you up with a test drive, we will need your name and address.

Turn #2:
    User: my name is Elon and I live at 123 Main Street
    Tesla AI: Can you confirm your name to be Elon and your address as 123 Main Street?

Turn #3:
    User: Yup! that is correct
    Tesla AI: You are all set for a Tesla test drive!
</code></pre>
<p>At turn #1,</p>
<ul>
<li>The walker starts at <code>dialogue_root</code>.</li>
<li>The <code>nlu</code> at <code>dialogue_root</code> is called and classify the intent to be <code>test drive</code>.</li>
<li>There is an <code>intent_transition(test_drive)</code> connecting <code>dialogue_root</code> to <code>test_drive_state</code> so the walker <code>takes</code> itself to <code>test_drive_state</code> .</li>
<li>We are now at <code>test_drive_state</code>, its <code>nlu</code> requires <code>entity_extraction</code> which will look for <code>name</code> and <code>address</code> entities. In this case, neither is provided by the user.</li>
<li>As a result, the walker can no longer traverse based on the <code>take</code> rules and thus construct a response based on the <code>nlg</code> logic at the <code>test_drive_state</code>.</li>
</ul>
<p>At turn #2,</p>
<ul>
<li>The walker starts at <code>test_drive_state</code>, picking up where it left off.</li>
<li><code>nlu</code> at <code>test_drive_state</code> perform intent classification and entity extractions. This time it will pick up both name and address.</li>
<li>As a result, the first <code>take</code> statement finds a qualified path and take that path to the <code>td_confirmation</code> node.</li>
<li>At <code>td_confirmation</code>, no valid take path exists so a response is returned.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>Turn #3 works similiarly as turn #1. See if you can figure out how the walker reacts at turn #3 yourself!</p>
</blockquote>
<h2 id="train-an-entity-extraction-model"><a class="header" href="#train-an-entity-extraction-model">Train an Entity Extraction Model</a></h2>
<p>Let's now train an entity extraction model!
We are using a transformer-based token classification model.</p>
<p>First, we need to load the actions. The action set is called <code>tfm_ner</code> (<code>tfm</code> stands for transformer).</p>
<pre><code class="language-bash">jaseci &gt; actions load module jaseci_kit.tfm_ner
</code></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p>If you installed <code>jaseci_kit</code> prior to September 5th, 2022, please upgrade via <code>pip install --upgrade jaseci_kit</code>. There has been an update to the module that you will need for remainder of this exercise. You can check your installed version via <code>pip show jaseci_kit</code>. You need to be on version 1.3.4.6 or higher.</p>
</blockquote>
<p>Similar to Bi-encoder, we have provided a jac program to train and inference with this model, as well as an example training dataset.
Go into the <code>code/</code> directory and copy <code>tfm_ner.jac</code> and <code>ner_train.json</code> to your working directory.
We are training the model to detect two entities, <code>name</code> and <code>address</code>, for the test drive use case.</p>
<p>Let's quickly go over the training data format.</p>
<pre><code class="language-jacon">[
    &quot;sure my name is [tony stark](name) and i live at [10880 malibu point california](address)&quot;,
    &quot;my name is [jason](name)&quot;
]
</code></pre>
<p>The training data is a json list of strings, each of which is a training example.
<code>[]</code> indicate the entitiy text while the <code>()</code> following it defines the entity type.
So in the example above, we have two entities, <code>name:tony stark</code> and <code>address: 10880 malibu point california</code>.</p>
<p>To train the model, run</p>
<pre><code class="language-bash">jaseci &gt; jac run tfm_ner.jac -walk train -ctx &quot;{\&quot;train_file\&quot;: \&quot;ner_train.json\&quot;}&quot;
</code></pre>
<p>After the model is finished training, you can play with the model using the <code>infer</code> walker</p>
<pre><code class="language-jac">jaseci &gt; jac run ner.jac -walk infer
</code></pre>
<p>For example,</p>
<pre><code class="language-bash">jaseci &gt; jac run tfm_ner.jac -walk infer
Enter input text (Ctrl-C to exit)&gt; my name is jason
[{&quot;entity_text&quot;: &quot;jason&quot;, &quot;entity_value&quot;: &quot;name&quot;, &quot;conf_score&quot;: 0.5514775514602661, &quot;start_pos&quot;: 11, &quot;end_pos&quot;: 16}]
</code></pre>
<p>The output of this model is a list of dictionaries, each of which is one detected entitiy.
For each detected entity, <code>entity_value</code> is the type of entity, so in this case either <code>name</code> or <code>address</code>;
and <code>entity_text</code> is the detected text from the input for this entity, so in this case the user's name or their address.</p>
<p>Let's now update the node ability to use the entity model.</p>
<pre><code class="language-jac">node dialogue_state {
    ...
    can extract_entities {
        res = tfm_ner.extract_entity(visitor.question);
        for ent in res {
            ent_type = ent[&quot;entity_value&quot;];
            ent_text = ent[&quot;entity_text&quot;];
            if (!(ent_type in visitor.wlk_ctx[&quot;entities&quot;])){
                visitor.wlk_ctx[&quot;entities&quot;][ent_type] = [];
            }
            visitor.wlk_ctx[&quot;entities&quot;][ent_type].l::append(ent_text);
        }
    }
    ...
}
</code></pre>
<p>There is one last update we need to do before this is fully functional.
Because we have more dialogue states and a more complex graph, we need to update our classifier to include the new intents.
We have provided an example training dataset at <code>code/clf_train_2.json</code>.
Re-train the bi-encoder model with this dataset.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Refer to previous code snippets if you need a reminder on how to train the bi-encoder classifier model.</p>
</blockquote>
<p>Now try running the walker again with <code>jac run dialogue.jac</code>!</p>
<p>Congratulations! You now have a fully functional multi-turn dialogue system that can handle test drive requests!</p>
<h1 id="unify-the-dialogue-and-faq-systems"><a class="header" href="#unify-the-dialogue-and-faq-systems">Unify the Dialogue and FAQ Systems</a></h1>
<p>So far, we have built two separate conversational AI systems, a FAQ system that automatically scales with the available question-answer pairs and a multi-turn action-oriented dialogue system that can handle complex requests.
These two systems serve different use cases and can be combined to a single system to provide a flexible and robust conversational AI experience.
In this section, we are going to unify these two systems into one coherent conversational AI system.</p>
<p>While these two systems rely on different AI models, they share many of the same logic flow.
They both follow the general steps of first analyizing user's question with NLU AI models, make decision on the next conversational state to be and then construct and return a response to the user.
Leveraging this shared pattern, we will first unify the node architecture of the two systems with a single parent node type, <code>cai_state</code> (<code>cai</code> is short of conversational AI).</p>
<pre><code class="language-jac">node cai_state {
    has name;
    can init_wlk_ctx {
        new_wlk_ctx = {
            &quot;intent&quot;: null,
            &quot;entities&quot;: {},
            &quot;prev_state&quot;: null,
            &quot;next_state&quot;: null,
            &quot;respond&quot;: false
        };
        if (&quot;entities&quot; in visitor.wlk_ctx) {
            // Carry over extracted entities from previous interaction
            new_wlk_ctx[&quot;entities&quot;] = visitor.wlk_ctx[&quot;entities&quot;];
        }
        visitor.wlk_ctx = new_wlk_ctx;
    }
    can nlu {}
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = net.root();
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {}
}
</code></pre>
<p>Note that the logic for <code>init_wlk_ctx</code> and the default <code>process</code> logic have been hoisted up into <code>cai_state</code> as they are shared by the dialogue system and FAQ system.
You can remove these two abilities from <code>dialogue_state</code> node, as it will be inheriting them from <code>cai_state</code> now.</p>
<p>We then update the defintion of <code>dialogue_state</code> in <code>dialogue.jac</code> to inherit from <code>cai_state</code>:</p>
<pre><code class="language-jac">node dialogue_state:cai_state{
    // Rest of dialogue_state code remain the same
}
</code></pre>
<p>Before we move on, we will take a quick detour to introduce multi-file jac program and how import works in jac.</p>
<h2 id="multi-file-jac-program-and-import"><a class="header" href="#multi-file-jac-program-and-import">Multi-file Jac Program and Import</a></h2>
<p>Jac's support for multi-file is quite simple.
You can import object definitions from one jac file to another with the <code>import</code> keyword.
With <code>import {*} with &quot;./code.jac&quot;</code>, everything from <code>code.jac</code> will be imported, which can include nodes, edges, graph and walker definition.
Alternaitvely, you can import specific objects with <code>import {node::state} with &quot;./code.jac&quot;</code>.</p>
<p>To compile a multi-file Jac program, you will need one jac file that serves as the entry point of the program.
This file need to import all the neccessary components of the program.
Chained importing is supported.</p>
<p>Once you have the main jac file (let's call it <code>main.jac</code>), you will need to compile it and its imports into a single <code>.jir</code> file.
<code>jir</code> here stands for Jac Intermediate Representation.
To compile a jac file, use the <code>jac build</code> command</p>
<pre><code class="language-jac">jaseci &gt; jac build main.jac
</code></pre>
<p>If the compilation is successful, a <code>.jir</code> file with the same name will be generated (in this case, <code>main.jir</code>).
<code>jir</code> file can be used with <code>jac run</code> or <code>jac dot</code> the same way as the <code>jac</code> source code file.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>The <code>jir</code> format is what you will use to deploy your jac program to a production jaseci instance.</p>
</blockquote>
<h2 id="unify-faq--dialogue-code"><a class="header" href="#unify-faq--dialogue-code">Unify FAQ + Dialogue Code</a></h2>
<p>For <code>faq_state</code>, we need to now define the <code>nlu</code> and <code>nlg</code> node abilities for FAQ.
So let's update the following in <code>faq.jac</code>
First, <code>faq_root</code></p>
<pre><code class="language-jac">node faq_root:cai_state {
    can use.qa_classify;
    can nlu {
        if (!visitor.wlk_ctx[&quot;prev_state&quot;]) {
            answers = --&gt;.answer;
            best_answer = use.qa_classify(
                text = visitor.question,
                classes = answers
            );
            visitor.wlk_ctx[&quot;intent&quot;] = best_answer[&quot;match&quot;];
        }
    }
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            for n in --&gt; {
                if (n.context[&quot;answer&quot;] == visitor.wlk_ctx[&quot;intent&quot;]){
                    visitor.wlk_ctx[&quot;next_state&quot;] = n;
                    break;
                }
            }
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {
        visitor.response = &quot;I can answer a variety of FAQs related to Tesla. What can I help you with?&quot;;
    }
}
</code></pre>
<p>At this point, if you have been following this journey along, this code should be relatively easy to understand.
Let's quickly break it down.</p>
<ul>
<li>For FAQ, the <code>nlu</code> logic uses the USE QA model to find the most relevant answer. Here we are re-using the <code>intent</code> field in the walker context to save the matched answer. You can also opt to create another field dedicated to FAQ NLU result.</li>
<li>For the traversal logic, this is very similar to the previous FAQ logic, i.e. find the <code>faq_state</code> node connected to here that contains the most relevant answer.</li>
<li><code>for n in --&gt;</code> iterates through all the nodes connected with an outgoing edge from the current node. You can use <code>.context</code> on any node variables to access its variables.</li>
</ul>
<p>And the logic for the <code>faq_state</code> that contains the answer is relatively simple;</p>
<pre><code class="language-jac">node faq_state:cai_state {
    has question;
    has answer;
    can nlg {
        visitor.response = here.answer;
    }
}
</code></pre>
<p>With these new nodes created, let's update our graph definition.
We have renamed our graph to be <code>tesla_ai</code> and the <code>dialogue.jac</code> file to <code>tesla_ai.jac</code>.</p>
<pre><code class="language-jac">graph tesla_ai {
    has anchor dialogue_root;
    spawn {
        dialogue_root = spawn node::dialogue_root;
        test_drive_state = spawn node::test_drive_state;
        td_confirmation = spawn node::td_confirmation;
        td_confirmed = spawn node::td_confirmed;
        td_canceled = spawn node::td_canceled;

        dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;
        test_drive_state -[intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;
        test_drive_state -[entity_transition(entities=[&quot;name&quot;, &quot;address&quot;])]-&gt; td_confirmation;
        test_drive_state -[intent_transition(intent=&quot;provide name or address&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;yes&quot;)]-&gt; td_confirmed;
        td_confirmation - [intent_transition(intent=&quot;no&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;

        faq_root = spawn graph::faq;
        dialogue_root -[intent_transition(intent=&quot;i have a question&quot;)]-&gt; faq_root;
    }
}
</code></pre>
<p>One thing worth pointing out here is that we are spawning a graph inside a graph spawn block.</p>
<p>Our graph should now looks like this!</p>
<p><img src="examples/CanoniCAI/images/complete.png" alt="" /></p>
<p>Here comes the biggest benefit of our unified node architecture -- the exact same walker logic can be shared to traverse both systems.
The only change we need to make is to change from <code>dialogue_state</code> to <code>cai_state</code> to apply the walker logic to a more generalized set of nodes.</p>
<pre><code class="language-jac">walker talk {
    ...
    root {
        take --&gt; node::dialogue_root;
    }
    cai_state {
        if (!question) {
            question = std.input(&quot;Question (Ctrl-C to exit)&gt; &quot;);
            here::init_wlk_ctx;
        }
        ...
    }
}
</code></pre>
<p>Update the graph name in the <code>init</code> walker as well.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::tesla_ai;
        spawn here walker::talk;
    }
}
</code></pre>
<p>To compile the program,</p>
<pre><code class="language-jac">jaseci &gt; jac build tesla_ai.jac
</code></pre>
<p>As mentioned before, if the compiliation succeedd, a <code>tesla_ai.jir</code> will be generated.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Run into issues at this build step? First check if all the imports are set up correctly.</p>
</blockquote>
<p>Running a <code>jir</code> is just like running a <code>jac</code> file</p>
<pre><code class="language-jac">jaseci &gt; jac run tesla_ai.jir
</code></pre>
<p>One last step, since we introduce a new intent <code>i have a questions</code>, we need to update our classifier model again.
This time, use the <code>clf_train_3.json</code> example training data.</p>
<p>The model is trained? Great! Now run the jir and try questions like &quot;I have some telsa related questions&quot; then following with FAQ questioins!</p>
<p>Congratulations! You have created a single conversational AI system that is capable of answering FAQs and perform complex multi-step actions.</p>
<h1 id="bring-your-application-to-production"><a class="header" href="#bring-your-application-to-production">Bring Your Application to Production</a></h1>
<p>Typing in questions and getting responses via <code>jacctl</code> in terminal is a quick and easy way of interactively test and use your program.
But the ultimate goal of building any products is to eventually deploying it to production and having it serve real users via standard interface such as RESTful API endpoints.
In this section, we will cover a number of items related to bringing your jac program to production.</p>
<h2 id="introducing-yield"><a class="header" href="#introducing-yield">Introducing <code>yield</code></a></h2>
<p><code>yield</code> is a jac keyword that suspend the walker and return a response, which then can be resumed at a later time with the walker context retained.
Walker context includes its <code>has</code> variables and its node traversal plan (i.e., any nodes that have been queued by previously executed <code>take</code> statements).
This context retention is done on a per-user basis.
<code>yield</code> is a great way to maintaining user-specific context and history in between walker calls.
To learn more about <code>yield,</code> refer to the relevant sections of the Jaseci Bible.</p>
<p>In the case of our conversational AI system, it is essential for our walker to remember the context information gained from previous interactions with the same user.
So let's update our walker with <code>yield.</code></p>
<pre><code class="language-jac">walker talk {
    has question, interactive = false;
    has wlk_ctx = {
        &quot;intent&quot;: null,
        &quot;entities&quot;: {},
        &quot;prev_state&quot;: null,
        &quot;next_state&quot;: null,
        &quot;respond&quot;: false
    };
    has response;
    root {
        take --&gt; node::dialogue_root;
    }
    cai_state {
        if (!question and interactive) {
            question = std.input(&quot;Question (Ctrl-C to exit)&gt; &quot;);
            here::init_wlk_ctx;
        } elif (!question and !interactive){
            std.err(&quot;ERROR: question is required for non-interactive mode&quot;);
            disengage;
        }
        here::nlu;
        here::process;
        if (visitor.wlk_ctx[&quot;respond&quot;]) {
            here::nlg;
            if (interactive): std.out(response);
            else {
                yield report response;
                here::init_wlk_ctx;
            }
            question = null;
            take here;
        } else {
            take visitor.wlk_ctx[&quot;next_state&quot;] else: take here;
        }
    }
}
</code></pre>
<p>Two new syntax here:</p>
<ul>
<li><code>report</code> returns variable from walker to its caller. When calling a walker via its REST API, the content of the API response payload will be what is reported.</li>
<li><code>yield report</code> is a shorthand for yielding and reporting at the same time. This is equivalane to <code>yield; report response;</code>.</li>
</ul>
<h2 id="introduce-sentinel"><a class="header" href="#introduce-sentinel">Introduce <code>sentinel</code></a></h2>
<p><code>sentinel</code> is the overseer of walkers, nodes and edges.
It is the abstraction Jaseci uses to encapsulate compiled walkers and architype nodes and edges.
The key operation with respesct to <code>sentinel</code> is &quot;register&quot; a sentinel.
You can think of registering a <code>sentinel</code> as a compiling your jac program.
The walkers of a given sentinel can then be invoked and run on arbitrary nodes of any graph.</p>
<p>Let's register our jac program</p>
<pre><code class="language-bash">jaseci &gt; sentinel register tesla_ai.jir -set_active true -mode ir
</code></pre>
<p>Three things are happening here:</p>
<ul>
<li>First, we registered the <code>jir</code> we compiled earlier to new sentinel. This means this new sentinel now has access to all of our walkers, nodes and edges. <code>-mode ir</code> option speciifes a <code>jir</code> program is registered instead of a <code>jac</code> program.</li>
<li>Second, with <code>-set_active true</code> we set this new sentinel to be the active sentinel. In other words, this sentinel is the default one to be used when requests hit the Jac APIs, if no specific sentinels are specified.</li>
<li>Third, <code>sentinel register</code> has automatically creates a new <code>graph</code> (if no currently active graph) and run the <code>init</code> walker on that graph. This behavior can be customized with the options <code>-auto_run</code> and <code>-auto_create_graph</code>.</li>
</ul>
<p>To check your graph</p>
<pre><code class="language-bash">jaseci &gt; graph get -mode dot
</code></pre>
<p>This will return the current active graph in DOT format.
This is the same output we get from running <code>jac dot</code> earlier.
Use this to check if your graph is successfully created.</p>
<p>Once a sentinel is registered, you can update its jac program with</p>
<pre><code class="language-bash">jaseci &gt; sentinel set -snt SENTINEL_ID -mode ir tesla_ai.jir
</code></pre>
<p>To get the sentinel ID, you can run one of the two following commands</p>
<pre><code class="language-bash">jaseci &gt; sentinel get
</code></pre>
<p>or</p>
<pre><code class="language-bash">jaseci &gt; sentinel list
</code></pre>
<p><code>sentinel get</code> returns the information about the current active sentinel, while <code>sentinel list</code> returns all available sentinels for the user.
The output will look something like this</p>
<pre><code class="language-jacon">{
  &quot;version&quot;: null,
  &quot;name&quot;: &quot;main.jir&quot;,
  &quot;kind&quot;: &quot;generic&quot;,
  &quot;jid&quot;: &quot;urn:uuid:817b4ff4-e6b7-4296-b383-55515e1e8b4a&quot;,
  &quot;j_timestamp&quot;: &quot;2022-08-04T20:23:16.952641&quot;,
  &quot;j_type&quot;: &quot;sentinel&quot;
}
</code></pre>
<p>The <code>jid</code> field is the ID for the sentinel. (<code>jid</code> stands for jaseci ID).</p>
<p>With a sentinel and graph, we can now run walker with</p>
<pre><code class="language-bash">jaseci &gt; walker run talk -ctx {\&quot;question\&quot;: \&quot;I want to schedule a test drive\&quot;}
</code></pre>
<p>And with <code>yield</code>, the next walker run will pick up where it leaves off and retain its variable states and nodes traversal plan.</p>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Just like any program, a set of automatic tests cases with robust coverage is essential to the success of the program through development to production.
Jac has built-in tests support and here is how you create a test case in jac.</p>
<pre><code class="language-jac">import {*} with &quot;tesla_ai.jac&quot;;

test &quot;testing the Tesla conv AI system&quot;
with graph::tesla_ai by walker::talk(question=&quot;Hey I would like to go on a test drive&quot;){
    res = std.get_report();
    assert(res[-1] == &quot;To set you up with a test drive, we will need your name and address.&quot;);
}
</code></pre>
<p>Let's break this down.</p>
<ul>
<li><code>test &quot;testing the tesla conv AI system&quot;</code> names the test.</li>
<li><code>with graph::tesla_ai</code> specify the graph to be used as the text fixture.</li>
<li><code>by walker::talk</code> specify the walker to test. It will be spawned on the anchor node of the graph.</li>
<li><code>std.get_report()</code> let you access the report content of the walker so that you can set up any assertion neccessary with <code>assert</code>.</li>
</ul>
<p>To run jac tests, save the test case(s) in a file (say <code>tests.jac</code>) and import the neccessary walkers and graphs. Then run</p>
<pre><code class="language-bash">jaseci &gt; jac test tests.jac
</code></pre>
<p>This will execute all the test cases in <code>tests.jac</code> squentially and report success or any assertion failures.</p>
<h2 id="running-jaseci-as-a-service"><a class="header" href="#running-jaseci-as-a-service">Running Jaseci as a Service</a></h2>
<p>So far, we have been interacting jaseci through <code>jacctl</code>.
jaseci can also be run as a service serving a set of RESTful API endpoints.
This is useful in production settings.
To run jaseci as a service, first we need to install the <code>jaseci_serv</code> package.</p>
<pre><code class="language-bash">pip install jaseci_serv
</code></pre>
<p>Then launching a jaseci server is as simple as</p>
<pre><code class="language-bash">jsserv makemigrations
jsserv migrate
jsserv runserver 0.0.0.0:3000
</code></pre>
<p>This will launch a Django RESTful API server at localhost and port 3000.
The Jaseci server supports a wide range of API endpoints.
All the <code>jacctl</code> commands we have used throughput this tutorial have an equivalent API endpoint, such as <code>walker_run</code> and <code>sentinel_register</code>.
As a matter of fact, the entire development journey in this tutorial can be done completely with a remote jaseci server instance.
You can go to <code>localhost:3000/docs</code> to check out all the available APIs.</p>
<h1 id="improve-your-ai-models-with-crowdsource"><a class="header" href="#improve-your-ai-models-with-crowdsource">Improve Your AI Models with Crowdsource</a></h1>
<p>Coming soon!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-for-running-ner-examples"><a class="header" href="#command-for-running-ner-examples">Command for running ner examples</a></h1>
<h3 id="compile-jac-program"><a class="header" href="#compile-jac-program">Compile jac program</a></h3>
<pre><code class="language-.jac">jac build main.jac
</code></pre>
<h3 id="activate-sentinel"><a class="header" href="#activate-sentinel">Activate sentinel</a></h3>
<pre><code>sentinel set -snt active:sentinel -mode ir main.jir
</code></pre>
<h3 id="call-walker-fro-training-and-pass-dataset-name-and-all-other-parameter"><a class="header" href="#call-walker-fro-training-and-pass-dataset-name-and-all-other-parameter">Call walker fro training and pass dataset name and all other parameter</a></h3>
<pre><code>walker run train_and_eval_all_models -ctx &quot;{\&quot;train_file\&quot;:\&quot;ner.json\&quot;,\&quot;eval_file\&quot;:\&quot;ner.json\&quot;,\&quot;num_train_epochs\&quot;:\&quot;10\&quot;,\&quot;batch_size\&quot;:\&quot;16\&quot;,\&quot;learning_rate\&quot;:\&quot;0.02\&quot;,\&quot;mode\&quot;:\&quot;default\&quot;}&quot;
</code></pre>
<h3 id="predict-entity-from-tfm"><a class="header" href="#predict-entity-from-tfm">Predict entity from tfm</a></h3>
<pre><code>walker run predict_entity_from_tfm -ctx &quot;{\&quot;text\&quot;:\&quot;Can you explain to me,please,what Homeowners Warranty Program means,what it applies to,what is its purpose? Thank you. The Humboldt University of Berlin is situated in Berlin, Germany\&quot;}&quot;
</code></pre>
<h3 id="predict-entity-from-flair"><a class="header" href="#predict-entity-from-flair">predict entity from flair</a></h3>
<pre><code>walker run predict_entity_from_flair -ctx &quot;{\&quot;labels\&quot;:\&quot;Fin_Corp\&quot;,\&quot;text\&quot;:\&quot;Can you explain to me,please,what Homeowners Warranty Program means,what it applies to,what is its purpose? Thank you. The Humboldt University of Berlin is situated in Berlin, Germany\&quot;}&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jaseci-kit"><a class="header" href="#jaseci-kit">Jaseci Kit</a></h1>
<p>Jaseci Kit is a collection of state-of-the-art machine learning models and useful tools that may be used in your application development.</p>
<h2 id="encoders"><a class="header" href="#encoders">Encoders</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Example</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><code>use_enc</code></td><td>USE Encoder</td><td><a href="support/guide/jaseci_kit/modules/encoders/use_enc/README.html">Link</a></td><td>Zero-shot</td><td>Ready</td><td>Sentence-level embedding pre-trained on general text corpus</td><td><a href="https://arxiv.org/abs/1803.11175">Paper</a></td></tr>
<tr><td><code>use_qa</code></td><td>USE QA</td><td><a href="support/guide/jaseci_kit/modules/encoders/use_qa/README.html">Link</a></td><td>Zero-shot</td><td>Ready</td><td>Sentence-level embedding pre-trained on Q&amp;A data corpus</td><td><a href="https://arxiv.org/abs/1803.11175">Paper</a></td></tr>
<tr><td><code>fast_enc</code></td><td>FastText</td><td><a href="support/guide/jaseci_kit/modules/encoders/fast_enc/README.html">Link</a></td><td>Training req.</td><td>Ready</td><td>FastText Text Classifier</td><td><a href="https://arxiv.org/abs/1712.09405">Paper</a></td></tr>
<tr><td><code>bi_enc</code></td><td>Bi-encoder</td><td><a href="support/guide/jaseci_kit/modules/encoders/bi_enc/README.html">Link</a></td><td>Training req./Zero-shot</td><td>Ready</td><td>Dual sentence-level encoders</td><td><a href="https://arxiv.org/abs/1803.11175">Paper</a></td></tr>
<tr><td><code>poly_enc</code></td><td>Poly-encoder</td><td></td><td>Training req./Zero-shot</td><td>Experimental</td><td>Poly Encoder</td><td><a href="https://arxiv.org/abs/1905.01969">Paper</a></td></tr>
<tr><td><code>cross_enc</code></td><td>Cross-encoder</td><td></td><td>Training req./Zero-shot</td><td>Experimental</td><td>Cross Encoder</td><td><a href="https://arxiv.org/abs/1905.01969">Paper</a></td></tr>
</tbody></table>
</div>
<h2 id="entity"><a class="header" href="#entity">Entity</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Example</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><code>ent_ext</code>/ <code>lstm_ner</code></td><td>Flair NER</td><td><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/README.html">Link</a></td><td>Training req.</td><td>Ready</td><td>Entity extraction using the FLAIR NER framework</td><td></td></tr>
<tr><td><code>tfm_ner</code></td><td>Transformer NER</td><td><a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/README.html">Link</a></td><td>Training req.</td><td>Ready</td><td>Token classification on Transformer models, can be used for NER</td><td><a href="https://huggingface.co/docs/transformers/tasks/token_classification#token-classification">Huggingface</a></td></tr>
<tr><td><code>lstm_ner</code></td><td>LSTM NER</td><td></td><td>Traininig req.</td><td>Experimental</td><td>Entity extraction/Slot filling via Long-short Term Memory Network</td><td></td></tr>
</tbody></table>
</div>
<h2 id="summarization"><a class="header" href="#summarization">Summarization</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Example</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><code>cl_summer</code></td><td>Summarizer</td><td><a href="support/guide/jaseci_kit/modules/summarization/cl_summer/README.html">Link</a></td><td>No Training req.</td><td>Ready</td><td>Extractive Summarization using Sumy</td><td><a href="https://miso-belica.github.io/sumy/">Doc.</a></td></tr>
<tr><td><code>t5_sum</code></td><td>Summarizer</td><td><a href="support/guide/jaseci_kit/modules/summarization/t5_sum/README.html">Link</a></td><td>No Training req.</td><td>Ready</td><td>Abstractive Summarization using the T5 Model</td><td><a href="https://huggingface.co/docs/transformers/model_doc/t5">Doc.</a>, <a href="https://arxiv.org/pdf/1910.10683.pdf">Paper</a></td></tr>
</tbody></table>
</div>
<h2 id="text-processing"><a class="header" href="#text-processing">Text Processing</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Example</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><code>text_seg</code></td><td>Text Segmenter</td><td><a href="support/guide/jaseci_kit/modules/text_processing/text_seg/README.html">Link</a></td><td>No Training req.</td><td>Experimetal</td><td>Topical Change Detection in Documents</td><td><a href="https://huggingface.co/dennlinger/roberta-cls-consec">Huggingface</a></td></tr>
</tbody></table>
</div>
<h2 id="object-detection"><a class="header" href="#object-detection">Object Detection</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Example</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><code>yolo_v5</code></td><td>Object Recognition</td><td><a href="support/guide/jaseci_kit/modules/object_detection/yolo_v5/README.html">Link</a></td><td>Training req.</td><td>Ready</td><td>'You only look once', is an object detection algorithm that divides images into a grid system</td><td><a href="https://docs.ultralytics.com/">Documentation</a></td></tr>
</tbody></table>
</div>
<h2 id="non-ai-tools"><a class="header" href="#non-ai-tools">Non-AI Tools</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Example</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><code>pdf_ext</code></td><td>PDF Extractor</td><td><a href="support/guide/jaseci_kit/modules/non_ai/pdf_ext/README.html">Link</a></td><td>Ready</td><td>Extract content from a PDF file via PyPDF2</td><td><a href="https://pypdf2.readthedocs.io/en/latest/">Doc.</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="encoders-1"><a class="header" href="#encoders-1">Encoders</a></h1>
<p>Text encoding is a process to convert meaningful text into number / vector representation so as to preserve the context and relationship between words and sentences, such that a machine can understand the pattern associated in any text and can make out the context of sentences.</p>
<p>Jaseci Kit provides the following optimized text encoders:</p>
<h2 id="encoders-2"><a class="header" href="#encoders-2">Encoders</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><a href="support/guide/jaseci_kit/modules/encoders/use_enc/README.html"><code>use_enc</code></a></td><td>USE Encoder</td><td>Zero-shot</td><td>Ready</td><td>Sentence-level embedding pre-trained on general text corpus</td><td><a href="support/guide/jaseci_kit/modules/encoders/use_enc/README.html">Documentation</a> <a href="https://arxiv.org/abs/1803.11175">Paper</a></td></tr>
<tr><td><a href="support/guide/jaseci_kit/modules/encoders/use_qa/README.html"><code>use_qa</code></a></td><td>USE QA</td><td>Zero-shot</td><td>Ready</td><td>Sentence-level embedding pre-trained on Q&amp;A data corpus</td><td><a href="support/guide/jaseci_kit/modules/encoders/use_qa/README.html">Documentation</a> <a href="https://arxiv.org/abs/1803.11175">Paper</a></td></tr>
<tr><td><a href="support/guide/jaseci_kit/modules/encoders/fast_enc/README.html"><code>fast_enc</code></a></td><td>FastText</td><td>Training required</td><td>Ready</td><td>FastText Text Classifier</td><td><a href="support/guide/jaseci_kit/modules/encoders/fast_enc/README.html">Documentation</a>  <a href="https://arxiv.org/abs/1712.09405">Paper</a></td></tr>
<tr><td><a href="support/guide/jaseci_kit/modules/encoders/bi_enc/README.html"><code>bi_enc</code></a></td><td>Bi-encoder</td><td>Training required / Zero-shot</td><td>Ready</td><td>Dual sentence-level encoders</td><td><a href="support/guide/jaseci_kit/modules/encoders/bi_enc/README.html">Documentation</a>  <a href="https://arxiv.org/abs/1803.11175">Paper</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="use-encoder-use_enc"><a class="header" href="#use-encoder-use_enc">USE Encoder (<code>use_enc</code>)</a></h1>
<p><code>use_enc</code> module uses the universal sentence encoder to generate sentence level embeddings.
The sentence level embeddings can then be used to calculate the similarity between two given text via cosine similarity and/or dot product.</p>
<ul>
<li><code>encode</code>: encodes the text and returns a embedding of 512 length
<ul>
<li>Alternate name: <code>get_embedding</code></li>
<li>Input:
<ul>
<li><code>text</code> (string or list of strings): text to be encoded</li>
</ul>
</li>
<li>Return: Encoded embeddings</li>
</ul>
</li>
<li><code>cos_sim_score</code>:
<ul>
<li>Input:
<ul>
<li><code>q_emb</code> (string or list of strings): first text to be embeded</li>
<li><code>a_emb</code> (string or list of strings): second text to be embedded</li>
</ul>
</li>
<li>Return: cosine similarity score</li>
</ul>
</li>
<li><code>text_simliarity</code>: calculate the simlarity score between given texts
<ul>
<li>Input:
<ul>
<li><code>text1</code> (string): first text</li>
<li><code>text2</code> (string): second text</li>
</ul>
</li>
<li>Return: cosine similarity score</li>
</ul>
</li>
<li><code>text_classify</code>: use USE encoder as a classifier
<ul>
<li>Input:
<ul>
<li><code>text</code> (string): text to classify</li>
<li><code>classes</code> (list of strings): candidate classification classes</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="example-jac-usage"><a class="header" href="#example-jac-usage">Example Jac Usage:</a></h2>
<pre><code class="language-jac"># Use USE encoder for zero-shot intent classification
walker use_enc_example {
    can use.encode, use.cos_sim_score;
    has text = &quot;What is the weather tomorrow?&quot;;
    has candidates = [
        &quot;weather forecast&quot;,
        &quot;ask for direction&quot;,
        &quot;order food&quot;
    ];
    text_emb = use.encode(text)[0];
    cand_embs = use.encode(candidates); # use.encode handles string/list

    max_score = 0;
    max_cand = 0;
    cand_idx = 0;
    for cand_emb in cand_embs {
        cos_score = use.cos_sim_score(cand_emb, text_emb);
        if (cos_score &gt; max_score) {
            max_score = cos_score;
            max_cand = cand_idx;
        }
        cand_idx += 1;
    }

    predicted_cand = candidates[max_cand];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-qa-use_qa"><a class="header" href="#use-qa-use_qa">USE QA (<code>use_qa</code>)</a></h1>
<p><code>use_qa</code> module uses the multilingual-qa to generate sentence level embeddings.
The sentence level embeddings can then be used to calculate best match between question and available answers via cosine similarity and/or dist_score.</p>
<ul>
<li>
<p><code>question_encode</code>: encodes question and returns a embedding of 512 length</p>
<ul>
<li>Alternate name: <code>enc_question</code></li>
<li>Input:
<ul>
<li><code>text</code> (string or list of strings): question to be encoded</li>
</ul>
</li>
<li>Return: Encoded embeddings</li>
</ul>
</li>
<li>
<p><code>answer_encode</code>: encodes answers and returns a embedding of 512 length</p>
<ul>
<li>Alternate name: <code>enc_answer</code></li>
<li>Input:
<ul>
<li><code>text</code> (string or list of strings): question to be encoded</li>
<li><code>context</code> (string or list of strings): usually the text around the answer text, for example it could be 2 sentences before plus 2 sentences after.</li>
</ul>
</li>
<li>Return: Encoded embeddings</li>
</ul>
</li>
<li>
<p><code>cos_sim_score</code>:</p>
<ul>
<li>Input:
<ul>
<li><code>q_emb</code> (string or list of strings): first embeded text</li>
<li><code>a_emb</code> (string or list of strings): second embeded text</li>
</ul>
</li>
<li>Return: cosine similarity score</li>
</ul>
</li>
<li>
<p><code>dist_score</code>:</p>
<ul>
<li>Input:
<ul>
<li><code>q_emb</code> (string or list of strings): first embeded text</li>
<li><code>a_emb</code> (string or list of strings): second embeded text</li>
</ul>
</li>
<li>Return: inner product score</li>
</ul>
</li>
<li>
<p><code>question_similarity</code>: calculate the simlarity score between given questions</p>
<ul>
<li>Input:
<ul>
<li><code>text1</code> (string): first text</li>
<li><code>text2</code> (string): second text</li>
</ul>
</li>
<li>Return: cosine similarity score</li>
</ul>
</li>
<li>
<p><code>question_classify</code>: use USE QA as question classifier</p>
<ul>
<li>Input:
<ul>
<li><code>text</code> (string): text to classify</li>
<li><code>classes</code> (list of strings): candidate classification classes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>answer_similarity</code>: calculate the simlarity score between given answer</p>
<ul>
<li>Input:
<ul>
<li><code>text1</code> (string): first text</li>
<li><code>text2</code> (string): second text</li>
</ul>
</li>
<li>Return: cosine similarity score</li>
</ul>
</li>
<li>
<p><code>answer_classify</code>: use USE encoder as answer classifier</p>
<ul>
<li>Input:
<ul>
<li><code>text</code> (string): text to classify</li>
<li><code>classes</code> (list of strings): candidate classification classes</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>qa_similarity</code>: calculate the simlarity score between question and answer</p>
<ul>
<li>Input:
<ul>
<li><code>text1</code> (string): first text</li>
<li><code>text2</code> (string): second text</li>
</ul>
</li>
<li>Return: cosine similarity score</li>
</ul>
</li>
<li>
<p><code>qa_classify</code>: use USE encoder as a QA classifier</p>
<ul>
<li>Input:
<ul>
<li><code>text</code> (string): text to classify</li>
<li><code>classes</code> (list of strings): candidate classification classes</li>
</ul>
</li>
<li>Returns: </li>
</ul>
</li>
</ul>
<h2 id="example-jac-usage-1"><a class="header" href="#example-jac-usage-1">Example Jac Usage:</a></h2>
<pre><code class="language-jac"># Use USE_QA model for zero-shot text classification
walker use_qa_example {
    can use.qa_similarity;
    has questions = &quot;What is your age?&quot;;
    has responses = [&quot;I am 20 years old.&quot;, &quot;good morning&quot;];
    has response_contexts = [&quot;I will be 21 next year.&quot;, &quot;great day.&quot;];

    max_score = 0;
    max_cand = 0;
    cand_idx = 0;
    for response in responses {
        cos_score = use.qa_similarity(text1=questions,text2=response);
        std.out(cos_score);
        if (cos_score &gt; max_score) {
            max_score = cos_score;
            max_cand = cand_idx;
        }
        cand_idx += 1;
    }

    predicted_cand = responses[max_cand];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fasttext-encoder-fast_enc"><a class="header" href="#fasttext-encoder-fast_enc">FastText Encoder (<code>fast_enc</code>)</a></h1>
<p><code>fast_enc</code> module uses the facebook's fasttext -- efficient learning of word representations and sentence classification.</p>
<ul>
<li><code>train</code>: used to train the Bi-Encoder for custom input
<ul>
<li>Input:
<ul>
<li><code>traindata</code> (Dict): dictionary of candidates and suportting contexts for each candidate</li>
<li><code>train_with_existing</code> (bool): if set to true train the model from scratch otherwise trains incrementally </li>
</ul>
</li>
</ul>
</li>
<li><code>predict</code>: predits the most suitable candidate for a provided context, takes text or embedding 
<ul>
<li>Input:
<ul>
<li><code>sentences</code> (list of strings): list of sentences the needs to be classified</li>
</ul>
</li>
<li>Return: a dictionary of sentence, predicted intent and probability </li>
</ul>
</li>
<li><code>save_model</code>:
<ul>
<li>Input 
<ul>
<li><code>model_path</code> (string): the path to save model</li>
</ul>
</li>
<li>Returns: &quot;[Saved model at] : &lt;model_path&gt;&quot; if model successfully saved</li>
</ul>
</li>
<li><code>load_model</code>:
<ul>
<li>Input 
<ul>
<li><code>model_path</code> (string): the path to save model</li>
</ul>
</li>
<li>Returns: &quot;[loaded model from] : &lt;model_path&gt;&quot; if model successfully loaded</li>
</ul>
</li>
</ul>
<h2 id="example-jac-usage-2"><a class="header" href="#example-jac-usage-2">Example Jac Usage:</a></h2>
<pre><code class="language-jac"># Train and inference with a fasttext classifier
walker fast_enc_example {
    has train_file = &quot;fast_enc_train.json&quot;;
    has train_with_existing = false;
    has test_sentence=  [&quot;what's going on ?&quot;];
    can fast_enc.train,fast_enc.predict;

    # Training the model
    train_data = file.load_json(train_file);
    fast_enc.train(traindata=train_data,train_with_existing=false);
    
    # Getting inference from the model
    resp_data=fast_enc.predict(sentences=test_sentence);
    std.out(resp_data);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bi-encoder-bi_enc"><a class="header" href="#bi-encoder-bi_enc"><strong>Bi-Encoder (<code>bi_enc</code>)</strong></a></h1>
<p><strong><code>bi_enc</code></strong> is a arrangement of two encoder modules from BERT, it represents context and candidate separately using twin-structured encoders, it takes contexts and candidates, to predict the best suitable candidate for each context. You can train the module on custom data to behave accordingly. Let's take a deep dive into the trainning culture.</p>
<p>This tutorial shows you how to train a Bi-Encoder with a custom training loop to categorize contexts by candidates. In this you use jaseci(jac) and python.</p>
<ol>
<li>Preparing <a href="support/guide/jaseci_kit/modules/encoders/bi_enc/index.html#1-praparing-dataset">dataset</a></li>
<li>Import <a href="support/guide/jaseci_kit/modules/encoders/bi_enc/index.html#2-import-bi-encoderbi_enc-module-in-jac">Bi-Encoder(bi_enc)</a> module in jac</li>
<li><a href="support/guide/jaseci_kit/modules/encoders/bi_enc/index.html#3-train-the-model">Train</a> the model</li>
<li><a href="support/guide/jaseci_kit/modules/encoders/bi_enc/index.html#4-evaluation-of-the-model-effectiveness-">Evaluate</a> the model's effectiveness</li>
<li>Use the trained model to make <a href="support/guide/jaseci_kit/modules/encoders/bi_enc/index.html#5-use-the-trained-model-to-make-predictions-">predictions</a></li>
</ol>
<h2 id="walk-through"><a class="header" href="#walk-through"><strong>Walk through</strong></a></h2>
<h3 id="1-praparing-dataset"><a class="header" href="#1-praparing-dataset"><strong>1. Praparing dataset</strong></a></h3>
<p>For this tutorial, we are going to leverage the biencoder for intent classification, which is categorizing an incoming text into a one of predefined intents. for demonstration purpose, we are going to use the SNIPS dataset as an example here. <a href="https://huggingface.co/datasets/snips_built_in_intents">snips dataset</a>.</p>
<p>SNIPS is a popular intent classificawtion datasets that covers intents such as <code>[ &quot;BookRestaurant&quot;, &quot;ComparePlaces&quot;, &quot;GetDirections&quot;, &quot;GetPlaceDetails&quot;, &quot;GetTrafficInformation&quot;, &quot;GetWeather&quot;, &quot;RequestRide&quot;, &quot;SearchPlace&quot;, &quot;ShareCurrentLocation&quot;, &quot;ShareETA&quot; ]</code>
We need to do a little data format conversion to create a version of SNIPS that work with our biencoder implemenation.
For this part, we are going to use Python. First, </p>
<ol>
<li>
<p><code>Import the dataset</code> from huggingface <a href="https://huggingface.co/datasets/snips_built_in_intents">dataset library</a>.</p>
<pre><code class="language-python"># import library
from datasets import load_dataset
# load dataset
dataset = load_dataset(&quot;snips_built_in_intents&quot;)
print(dataset[&quot;train&quot;][:2])
</code></pre>
<p>If imported successsfuly, you should see the data format to be something like this in output</p>
<blockquote>
<p>{&quot;text&quot;: [&quot;Share my location with Hillary's sister&quot;, &quot;Send my current location to my father&quot;], &quot;label&quot;: [5, 5]}</p>
</blockquote>
</li>
<li>
<p><code>Converting the format</code> from the SNIPS out of the box to the format that can be ingested by biencoder.</p>
<pre><code class="language-python">import pandas as pd
from sklearn.model_selection import train_test_split
import json

# get labels names
lab = dataset[&quot;train&quot;].features[&quot;label&quot;].names
# create labels dictionary
label_dict = {v: k for v, k in enumerate(lab)}
# dataset
dataset = dataset[&quot;train&quot;]

# create dataset function
def CreateData(data):
    # Create dataframe
    df = pd.DataFrame(data)
    # Map labels dict on label column
    df[&quot;label&quot;] = df[&quot;label&quot;].apply(lambda x : label_dict[x])
    # grouping text on basis of label
    df = df.groupby(&quot;label&quot;).agg({&quot;text&quot;: &quot;\t&quot;.join, &quot;label&quot;: &quot;\t&quot;.join})
    df[&quot;label&quot;] = df[&quot;label&quot;].apply(lambda x: x.split(&quot;\t&quot;)[0])

    # Create data dictionary
    data_dict = {}
    for i in range(len(df)):
        data_dict[df[&quot;label&quot;][i]] = df[&quot;text&quot;][i].split(&quot;\t&quot;)
    return data_dict
# Split dataset: Create train and test dataset and store in json file `train_bi.json` and `test_bi.json` and save to disk.
# Split dataset in train and test set
train, test = train_test_split(dataset, test_size=0.2, random_state=42)

# Create train dataset
train_data = CreateData(train)
# write data in json file 'train_bi.json'
with open(&quot;train_bi.json&quot;, &quot;w&quot;, encoding=&quot;utf8&quot;) as f:
    f.write(json.dumps(train_data, indent = 4))
    

# Create test dataset
test_data = CreateData(test)
data = {
    &quot;contexts&quot;: [],
    &quot;candidates&quot;: [],
    &quot;context_type&quot;: &quot;text&quot;,
    &quot;candidate_type&quot;: &quot;text&quot;
    }
for itm in test_data:
    data[&quot;candidates&quot;].append(itm)
    data[&quot;contexts&quot;].extend(test_data[itm])
# write data in json file 'test_bi.json'
with open(&quot;test_bi.json&quot;, &quot;w&quot;, encoding=&quot;utf8&quot;) as f:
        f.write(json.dumps(data, indent = 4))
</code></pre>
<p><strong>The resulting format should look something like this.</strong></p>
<ul>
<li>
<p><strong>train_bi.json</strong></p>
<pre><code>&quot;BookRestaurant&quot;: [
    &quot;Book me a table for 2 people at the sushi place next to the show tomorrow night&quot;,&quot;Find me a table for four for dinner tonight&quot;
    ],
&quot;ComparePlaces&quot;: [
    &quot;What's the cheapest between the two restaurants the closest to my hotel?&quot;
    ]
</code></pre>
</li>
<li>
<p><strong>test_bi.json</strong></p>
<pre><code>{
    {
        &quot;contexts&quot;: [
            &quot;We are a party of 4 people and we want to book a table at Seven Hills for sunset&quot;,
            &quot;Book a table at Saddle Peak Lodge for my diner with friends tonight&quot;,
            &quot;How do I go to Montauk avoiding tolls?&quot;,
            &quot;What's happening this week at Smalls Jazz Club?&quot;,
            &quot;Will it rain tomorrow near my all day event?&quot;,
            &quot;Send my current location to Anna&quot;,
            &quot;Share my ETA with Jo&quot;,
            &quot;Share my ETA with the Snips team&quot;
        ],
        &quot;candidates&quot;: [
            &quot;BookRestaurant&quot;,
            &quot;ComparePlaces&quot;,
            &quot;GetDirections&quot;,
            &quot;GetPlaceDetails&quot;,
            &quot;GetTrafficInformation&quot;,
            &quot;GetWeather&quot;,
            &quot;RequestRide&quot;,
            &quot;SearchPlace&quot;,
            &quot;ShareCurrentLocation&quot;,
            &quot;ShareETA&quot;
        ],
        &quot;context_type&quot;: &quot;text&quot;,
        &quot;candidate_type&quot;: &quot;text&quot;
    }
}
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="2-import-bi-encoderbi_enc-module-in-jac"><a class="header" href="#2-import-bi-encoderbi_enc-module-in-jac"><strong>2. Import <code>Bi-Encoder(bi_enc)</code> module in jac</strong></a></h3>
<ol>
<li>Open terminal and run jaseci by cmd
<blockquote>
<p>jsctl -m</p>
</blockquote>
</li>
<li>Load <code>bi_enc</code> module in jac by cmd
<blockquote>
<p>actions load module jaseci_kit.bi_enc</p>
</blockquote>
</li>
</ol>
<h3 id="3-train-the-model"><a class="header" href="#3-train-the-model"><strong>3. Train the model</strong></a></h3>
<p>For this tutorial, we are going to <code>train and infer</code> the <code>biencoder</code> for <code>intent classification</code> its <code>train</code> on snips <code>train datasets</code> and <code>infer</code> on <code>test dataset</code>, which is categorizing an incoming text into a one of predefined intents.</p>
<ul>
<li>
<p><strong>Creating Jac Program (<code>train and infer</code> bi_enc)</strong></p>
<ol>
<li>
<p>Create a file by name <code>bi_encoder.jac</code></p>
</li>
<li>
<p>Create node <code>model_dir</code> and <code>bi_encoder</code> in <code>bi_encoder.jac</code> file</p>
<pre><code>node model_dir;
node bi_encoder {};
</code></pre>
</li>
<li>
<p>Initializing <code>node bi_encoder</code> and import <code>train</code> and <code>infer</code> ability inside node.</p>
<pre><code># import train and infer ability
can bi_enc.train, bi_enc.infer;
</code></pre>
</li>
<li>
<p>Initialize module <code>train</code> and <code>infer</code> inside <code>bi_encoder node</code>
<code>bi_enc.train</code> take training argument and start traing <code>bi_enc</code> module</p>
<pre><code class="language-python">can train_bi_enc with train_bi_enc entry{
# Code snippet for training the model
train_data = file.load_json(visitor.train_file);

# Train the model 
report bi_enc.train(
    dataset=train_data,
    from_scratch=visitor.from_scratch,
    training_parameters={
        &quot;num_train_epochs&quot;: visitor.num_train_epochs.int
        }
    );
}
# prediction on test dataset
can infer with train_bi_enc exit{
    # Use the model to perform inference
    # returns the list of context with the suitable candidates
    test_data = file.load_json(visitor.test_file);
    resp_data = bi_enc.infer(
        contexts=test_data[&quot;contexts&quot;],
        candidates=test_data[&quot;candidates&quot;],
        context_type=test_data[&quot;context_type&quot;],
        candidate_type=test_data[&quot;candidate_type&quot;]
    );
    # the infer action returns all the candidate with the confidence scores
    # Iterate through the candidate labels and their predicted scores
    result = [];
    for pred in resp_data.list{
        text = pred[&quot;context&quot;];
        max_score = 0;
        max_intent = &quot;&quot;;
        for j=0 to j&lt;pred[&quot;candidate&quot;].length by j+=1 {
            if (pred[&quot;score&quot;][j] &gt; max_score){
                max_intent = pred[&quot;candidate&quot;][j];
                max_score = pred[&quot;score&quot;][j];
            }
        }
        result.list::append({
            &quot;context&quot;:text,
            &quot;predicted intent&quot;:max_intent,
            &quot;Conf_Score&quot;:max_score
            });
    }
    report [result];
}
# predict intent on new text
can predict with predict entry{        
# Use the model to perform inference
# returns the list of context with the suitable candidates
test_data = file.load_json(visitor.test_data_file);
resp_data = bi_enc.infer(
    contexts=test_data[&quot;contexts&quot;],
    candidates=test_data[&quot;candidates&quot;],
    context_type=test_data[&quot;context_type&quot;],
    candidate_type=test_data[&quot;candidate_type&quot;]
    );
# the infer action returns all the candidate with the confidence scores
# Iterate through the candidate labels and their predicted scores
pred = resp_data[0]
context = pred[&quot;contexts&quot;]
max_score = 0;
max_intent = &quot;&quot;;
for j=0 to j&lt;pred[&quot;candidate&quot;].length by j+=1 {
    if (pred[&quot;score&quot;][j] &gt; max_score){
        max_intent = pred[&quot;candidate&quot;][j];
        max_score = pred[&quot;score&quot;][j];
    }
}
report [{
        &quot;context&quot;:text,
        &quot;pred intent&quot;:max_intent,
        &quot;Conf_Score&quot;:max_score
        }];
}
</code></pre>
<p><strong>Parameter details</strong></p>
<ul>
<li><code>train</code>: will be used to train the Bi-Encoder on custom data
<ul>
<li>Input:
<ul>
<li><code>dataset</code> (Dict): dictionary of candidates and suportting contexts for each candidate</li>
<li><code>from_scratch</code> (bool): if set to true train the model from scratch otherwise trains incrementally </li>
<li><code>training_parameters</code> (Dict): dictionary of training parameters</li>
</ul>
</li>
<li>Returns: text when model training is completed</li>
</ul>
</li>
<li><code>infer</code>: will be used to predits the most suitable candidate for a provided context, takes text or embedding 
<ul>
<li>Input:
<ul>
<li><code>contexts</code> (string or list of strings): context which needs to be classified</li>
<li><code>candidates</code> (string or list of strings): list of candidates for the context </li>
<li><code>context_type</code> (string): can be text or embedding type</li>
<li><code>candidate_type</code> (string): can be text or embedding type</li>
</ul>
</li>
<li>Return: a dictionary of similarity score for each candidate and context </li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adding edge name of <code>bi_model</code> in <code>bi_encoder.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge bi_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding graph name of <code>bi_encoder_graph</code> for initializing node .</p>
<pre><code>graph bi_encoder_graph {
    has anchor bi_model_dir;
    spawn {
        bi_model_dir = spawn node::model_dir;
        bi_encoder_node = spawn node::bi_encoder;
        bi_model_dir -[bi_model(model_type=&quot;bi_encoder&quot;)]-&gt; bi_encoder_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing <code>walker init</code> for calling graph</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::bi_encoder_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating walker name of <code>train_bi_enc</code> for getting parameter from <strong>context or default</strong> and calling ability <code>train and infer</code> bi_encoder.</p>
<pre><code># Declaring the walker: 
walker train_bi_enc{
    # the parameters required for training    
    has train_file = &quot;train_bi.json&quot;;
    has from_scratch = true;
    has num_train_epochs = 20;
    has test_file = &quot;test_bi.json&quot;;    

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p><strong>Default parameter for train and test biencoder</strong> </br>
<code>train_file</code> : local path of <strong>train_bi.json</strong> file </br>
<code>from_scratch</code> : <strong>true</strong> </br>
<code>num_train_epochs</code> : <strong>20</strong> </br>
<code>test_file</code> : local path of <strong>test_bi.json</strong> file </br></p>
</li>
<li>
<p>Declaring walker for <code>predicting intents</code> on new text</p>
<pre><code>walker predict{
    has test_data_file = &quot;test_dataset.json&quot;;    

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p><strong>Final bi_encoder.jac</strong> program
we are conmbining all steps from <strong>2 to 8</strong> inside <strong>bi_encoder.jac</strong></p>
<pre><code class="language-python">node model_dir;
node bi_encoder{
    # import train and infer ability
    can bi_enc.train, bi_enc.infer;

    can train_bi_enc with train_bi_enc entry{
        #Code snippet for training the model
        train_data = file.load_json(visitor.train_file);
        
        # Train the model 
        report bi_enc.train(
            dataset=train_data,
            from_scratch=visitor.from_scratch,
            training_parameters={
                &quot;num_train_epochs&quot;: visitor.num_train_epochs.int
                }
            );
        }

    can infer with train_bi_enc exit{
        # Use the model to perform inference
        # returns the list of context with the suitable candidates
        test_data = file.load_json(visitor.test_file);
        resp_data = bi_enc.infer(
            contexts=test_data[&quot;contexts&quot;],
            candidates=test_data[&quot;candidates&quot;],
            context_type=test_data[&quot;context_type&quot;],
            candidate_type=test_data[&quot;candidate_type&quot;]
        );
        # the infer action returns all the candidate with the confidence scores
        # Iterate through the candidate labels and their predicted scores

        result = [];
        for pred in resp_data.list{
            text = pred[&quot;context&quot;];
            max_score = 0;
            max_intent = &quot;&quot;;
            for j=0 to j&lt;pred[&quot;candidate&quot;].length by j+=1 {
                if (pred[&quot;score&quot;][j] &gt; max_score){
                    max_intent = pred[&quot;candidate&quot;][j];
                    max_score = pred[&quot;score&quot;][j];
                }
            }
            result.list::append({
                &quot;context&quot;:text,
                &quot;predicted intent&quot;:max_intent,
                &quot;Conf_Score&quot;:max_score
                });
        }
        report [result];
    }

    # predict intent on new text
    can predict with predict entry{        
    # Use the model to perform inference
    test_data = file.load_json(visitor.test_data_file);
    resp_data = bi_enc.infer(
        contexts=test_data[&quot;contexts&quot;],
        candidates=test_data[&quot;candidates&quot;],
        context_type=test_data[&quot;context_type&quot;],
        candidate_type=test_data[&quot;candidate_type&quot;]
        );
    
    # the infer action returns all the candidate with the confidence scores
    # Iterate through the candidate labels and their predicted scores
    pred = resp_data[0];
    max_score = 0;
    max_intent = &quot;&quot;;
    for j=0 to j&lt;pred[&quot;candidate&quot;].length by j+=1 {
        if (pred[&quot;score&quot;][j] &gt; max_score){
            max_intent = pred[&quot;candidate&quot;][j];
            max_score = pred[&quot;score&quot;][j];
        }
    }
    report [{
        &quot;context&quot;: pred[&quot;context&quot;],
        &quot;pred intent&quot;: max_intent,
        &quot;Conf_Score&quot;: max_score
        }];
    }
}


# adding edge
edge bi_model {
    has model_type;
}

graph bi_encoder_graph {
    has anchor bi_model_dir;
    spawn {
        bi_model_dir = spawn node::model_dir;
        bi_encoder_node = spawn node::bi_encoder;
        bi_model_dir -[bi_model(model_type=&quot;bi_encoder&quot;)]-&gt; bi_encoder_node;
    }
}

walker init {
    root {
    spawn here --&gt; graph::bi_encoder_graph; 
    }
}


# Declaring the walker: 
walker train_bi_enc{
    # the parameters required for training    
    has train_file = &quot;train_bi.json&quot;;
    has from_scratch = true;
    has num_train_epochs = 20;
    has test_file = &quot;test_bi.json&quot;;    

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}

# declaring walker for predicting intents on new text
walker predict{
    # passing input data for prediction
    has test_data_file = &quot;test_dataset.json&quot;;    

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
</li>
</ol>
<p><strong>Steps for running <code>bi_encoder.jac</code> programm</strong></p>
<ol>
<li>
<p>Build <code>bi_encoder.jac</code> by run cmd</p>
<blockquote>
<p>jac build bi_encoder.jac</p>
</blockquote>
</li>
<li>
<p>Activate sentinal by run cmd</p>
<blockquote>
<p>sentinel set -snt active:sentinel -mode ir bi_encoder.jir</p>
</blockquote>
<p><strong>Note</strong>: If getting error <strong><code>ValueError: badly formed hexadecimal UUID string</code></strong> execute only once</p>
<blockquote>
<p>sentinel register -set_active true -mode ir bi_encoder.jir</p>
</blockquote>
</li>
<li>
<p>Calling walker <code>train_bi_enc</code> with <code>default parameter</code> for training <code>bi_enc</code> module by cmd</p>
<blockquote>
<p>walker run train_bi_enc </br></p>
</blockquote>
</li>
</ol>
<p>After <code>3rd step</code> running logging will shown on console </br>
<strong><code>training logs</code></strong></p>
<pre><code>jaseci &gt; walker run train_bi_enc
Saving non-shared model to : modeloutput
non shared model created
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:13&lt;00:00,  2.42it/s]
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:13&lt;00:00, 14.12it/s]

            Epoch : 1
            loss : 0.11524221436543898
            LR : 0.000891891891891892

100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:01&lt;00:00, 21.54it/s]
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:01&lt;00:00, 21.42it/s]

            Epoch : 2
            loss : 0.030822114031197445
            LR : 0.0006689189189189189

100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:01&lt;00:00, 20.99it/s]
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:01&lt;00:00, 20.67it/s]

            Epoch : 3
            loss : 0.016803985327538667
            LR : 0.000445945945945946

100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:01&lt;00:00, 19.98it/s]
97%|███████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▊     | 32/33 [00:01&lt;00:00, 19.59it/s]

            Epoch : 4
            loss : 0.011880970348350027
            LR : 0.000222972972972973

100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:04&lt;00:00,  8.16it/s]
100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 33/33 [00:04&lt;00:00,  6.06it/s]

            Epoch : 5
            loss : 0.010109249611780273
            LR : 0.0

Epoch: 100%|█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████| 5/5 [00:22&lt;00:00,  4.49s/batch]

</code></pre>
</li>
</ul>
<h3 id="4-evaluation-of-the-model-effectiveness"><a class="header" href="#4-evaluation-of-the-model-effectiveness"><strong>4. Evaluation of the model effectiveness</strong></a></h3>
<ul>
<li>
<p>Performing model effectiveness on <code>test_bi.json</code> dataset.</p>
<pre><code>Model testing Accuracy : 0.9090909090909091
Model testing F1_Score : 0.886656034024455

Model classification Report

                        precision    recall  f1-score   support

        BookRestaurant       1.00      1.00      1.00        14
         ComparePlaces       0.57      1.00      0.73         4
         GetDirections       1.00      1.00      1.00         7
       GetPlaceDetails       1.00      0.80      0.89        10
 GetTrafficInformation       1.00      0.50      0.67         4
            GetWeather       0.90      1.00      0.95         9
           RequestRide       0.83      1.00      0.91         5
           SearchPlace       0.80      0.67      0.73         6
  ShareCurrentLocation       1.00      1.00      1.00         3
              ShareETA       1.00      1.00      1.00         4

              accuracy                           0.91        66
             macro avg       0.91      0.90      0.89        66
          weighted avg       0.93      0.91      0.91        66
</code></pre>
<p><strong>Sample Result Data</strong></p>
<pre><code>[
    {
        &quot;context&quot;: &quot;I want a table for friday 8pm for 2 people at Katz's Delicatessen&quot;,
        &quot;pred intent&quot;: &quot;BookRestaurant&quot;,
        &quot;true intent&quot;: &quot;BookRestaurant&quot;,
        &quot;Conf_Score&quot;: 16.789536811645576
    },
    {
        &quot;context&quot;: &quot;Is Vertigo Sky Lounge more expensive than the bar I usually go to in New York?&quot;,
        &quot;pred intent&quot;: &quot;ComparePlaces&quot;,
        &quot;true intent&quot;: &quot;ComparePlaces&quot;,
        &quot;Conf_Score&quot;: 10.970629125448095
    },
    {
        &quot;context&quot;: &quot;Directions to Disneyworld avoiding traffic&quot;,
        &quot;pred intent&quot;: &quot;GetDirections&quot;,
        &quot;true intent&quot;: &quot;GetDirections&quot;,
        &quot;Conf_Score&quot;: 18.088717110248858
    },
    {
        &quot;context&quot;: &quot;Show me the fastest itinerary to my Airbnb on a Friday night&quot;,
        &quot;pred intent&quot;: &quot;GetDirections&quot;,
        &quot;true intent&quot;: &quot;GetDirections&quot;,
        &quot;Conf_Score&quot;: 12.83485819143171
    },
    {
        &quot;context&quot;: &quot;Is there any traffic on US 20?&quot;,
        &quot;pred intent&quot;: &quot;GetTrafficInformation&quot;,
        &quot;true intent&quot;: &quot;GetTrafficInformation&quot;,
        &quot;Conf_Score&quot;: 12.378884709882225
    },
    {
        &quot;context&quot;: &quot;Can I take my bike to go to work today?&quot;,
        &quot;pred intent&quot;: &quot;GetTrafficInformation&quot;,
        &quot;true intent&quot;: &quot;GetWeather&quot;,
        &quot;Conf_Score&quot;: 13.005006348394783
    },
    {
        &quot;context&quot;: &quot;Book a Lyft car to go to 33 greene street&quot;,
        &quot;pred intent&quot;: &quot;RequestRide&quot;,
        &quot;true intent&quot;: &quot;RequestRide&quot;,
        &quot;Conf_Score&quot;: 18.330015462917917
    },
    
    {
        &quot;context&quot;: &quot;Get me a ride to the airport&quot;,
        &quot;pred intent&quot;: &quot;RequestRide&quot;,
        &quot;true intent&quot;: &quot;RequestRide&quot;,
        &quot;Conf_Score&quot;: 27.063900934951988
    },
    {
        &quot;context&quot;: &quot;Find me the finest sushi restaurant in the area of my next meeting&quot;,
        &quot;pred intent&quot;: &quot;SearchPlace&quot;,
        &quot;true intent&quot;: &quot;SearchPlace&quot;,
        &quot;Conf_Score&quot;: 13.798050719287755
    }
]
</code></pre>
</li>
</ul>
<h3 id="5-use-the-trained-model-to-make-predictions"><a class="header" href="#5-use-the-trained-model-to-make-predictions"><strong>5. Use the trained model to make predictions</strong> </br></a></h3>
<ul>
<li>
<p>Create new input data for prdiction stored in <code>test_dataset.json</code> file (can take any name) </br></p>
<p><strong>Input data</strong></p>
<pre><code>  {
      &quot;contexts&quot;: [
          &quot;We are a party of 4 people and we want to book a table at Seven Hills for sunset&quot;
      ],
      &quot;candidates&quot;: [
          &quot;BookRestaurant&quot;,
          &quot;ComparePlaces&quot;,
          &quot;GetDirections&quot;,
          &quot;GetPlaceDetails&quot;,
          &quot;GetTrafficInformation&quot;,
          &quot;GetWeather&quot;,
          &quot;RequestRide&quot;,
          &quot;SearchPlace&quot;,
          &quot;ShareCurrentLocation&quot;,
          &quot;ShareETA&quot;
      ],
      &quot;context_type&quot;: &quot;text&quot;,
      &quot;candidate_type&quot;: &quot;text&quot;
  }
</code></pre>
</li>
<li>
<p>Calling walker for predict intents by cmd</p>
<pre><code>walker run predict -ctx &quot;{\&quot;test_data_file\&quot;:\&quot;test_dataset.json\&quot;}&quot;
</code></pre>
<p><strong>Output Result</strong></p>
<pre><code> [
  {
    &quot;context&quot;: &quot;We are a party of 4 people and we want to book a table at Seven Hills for sunset&quot;,
    &quot;pred intent&quot;: &quot;BookRestaurant&quot;,
    &quot;Conf_Score&quot;: 19.72020419731474
  }
]
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-extraction--recognition"><a class="header" href="#entity-extraction--recognition">Entity Extraction / Recognition</a></h1>
<p>Named entity recognition (NER) is the process of categroizing and identifying informational entities in text. Jaseci provides the following NER engines: </p>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/README.html"><code>ent_ext</code></a></td><td>Flair NER</td><td>Training req.</td><td>Ready</td><td>Entity extraction using the FLAIR NER framework</td><td><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/README.html">Documentation</a></td></tr>
<tr><td><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/README.html"><code>tfm_ner</code></a></td><td>Transformer NER</td><td>Training req.</td><td>Ready</td><td>Token classification on Transformer models, can be used for NER</td><td><a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/README.html">Documentation</a> <a href="https://huggingface.co/docs/transformers/tasks/token_classification#token-classification">Huggingface</a></td></tr>
<tr><td><code>lstm_ner</code></td><td>LSTM NER</td><td>Training Required</td><td>Experimental</td><td>Entity extraction/Slot filling via Long-short Term Memory Network</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h3 id="entity-extraction-using-flair-nerent_ext"><a class="header" href="#entity-extraction-using-flair-nerent_ext">Entity Extraction Using <code>FLAIR NER(ent_ext)</code></a></h3>
<h3 id="flair-nerent_ext-module-uses-flair-named-entity-recognition-architecture-it-can-either-be-used-zero-shot-or-few-shot-entity-recognition"><a class="header" href="#flair-nerent_ext-module-uses-flair-named-entity-recognition-architecture-it-can-either-be-used-zero-shot-or-few-shot-entity-recognition"><strong>FLAIR NER</strong><code>(ent_ext)</code> module uses flair named entity recognition architecture. It can either be used <code>zero-shot</code> or <code>few-shot</code> entity recognition.</a></h3>
<p>For this tutorial we are going to leaverage the flair ner <code>Zero-shot classification</code> and <code>Few-shot classification</code> Use Case</p>
<p><strong>USE CASE I : <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#use-case-i--zero-shot-entity-detection-classify-entity-without-training-ner-data">Zero-Shot entity detection</a></strong></p>
<ol>
<li>Import <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#1-import-flair-ner-module-in-jac">flair ner(ent_ext)</a> module</li>
<li><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#2-classify-entity-">Classify Entity</a></li>
</ol>
<p><strong>USE CASE II : <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#use-case-ii--few-shot-classification">Few-shot classification</a></strong></p>
<ol>
<li>Preparing <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#1-creating-input-datasets">dataset</a></li>
<li>Import <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#2-import-flair-nerent_ext-module-in-jac">flair ner(ent_ext)</a> module</li>
<li><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#3-few-shot-classification-train-test-and-validate-model">Few-shot classification</a></li>
</ol>
<p><strong><a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#experiment-and-methodology">Eperiment and methodology</a></strong></p>
<h1 id="walk-through-1"><a class="header" href="#walk-through-1"><strong>Walk through</strong></a></h1>
<h2 id="use-case-i--zero-shot-entity-detection-classify-entity-without-training-ner-data"><a class="header" href="#use-case-i--zero-shot-entity-detection-classify-entity-without-training-ner-data"><strong>USE CASE I</strong> : <code>Zero-Shot entity detection</code> Classify entity without training <code>NER Data</code>:</a></h2>
<h3 id="1-import-flair-ner-module-in-jac"><a class="header" href="#1-import-flair-ner-module-in-jac"><strong>1. Import Flair Ner Module in jac</strong></a></h3>
<ol>
<li>Open terminal an run jaseci by cmd
<pre><code>jsctl -m
</code></pre>
</li>
<li>Load module <code>ent_ext</code> in jac by cmd
<pre><code>actions load module jaseci_kit.ent_ext
</code></pre>
</li>
</ol>
<h3 id="2-classify-entity-"><a class="header" href="#2-classify-entity-"><strong>2. Classify Entity</strong> :</a></h3>
<p>For this tutorial we are going to classify entity text with <code>flair ner(ent_ext)</code> module on <code>tars-ner</code> pretrained model.</p>
<ul>
<li>
<p>Creating jac program for <strong>zero-shot(ent_ext)</strong></p>
<ol>
<li>
<p>Create a file by name <code>zero_shot_ner.jac</code></p>
</li>
<li>
<p>Create node <code>model_dir</code> and <code>flair_ner</code> in <code>zero_shot_ner.jac</code> file</p>
<pre><code>node model_dir;
node flair_ner {};
</code></pre>
</li>
<li>
<p>Initializing node flair_ner and adding abilty <code>set_config</code> and <code>entity_detection</code></p>
<pre><code>node flair_ner{
    # set model configuration and infer entity
    ent_ext.set_config, can ent_ext.entity_detection;
    }
</code></pre>
</li>
<li>
<p>Initializing module for <code>set_config</code> inside node <code>flair_ner</code></p>
<p><code>set_config</code> will get parameter from context and load model in module. its take two argument <code>model_name(str)</code> an <code>model_type(str)</code>.</p>
<pre><code>can set_config with infer_zero_shot entry{
    report ent_ext.set_config(
        ner_model = visitor.model_name,
        model_type = visitor.model_type
    );
}
</code></pre>
</li>
<li>
<p>Initializing module <code>infer_zero_shot</code> for <strong>zero_shot tokenclassification</strong> inside <strong>flair_ner node</strong></p>
<p><code>infer_zero_shot</code> module take two arguments <code>text</code> and <code>labels list</code> for infer entity.</p>
<pre><code>can infer_zero_shot with infer_zero_shot entry{
    text = visitor.text;
    labels = visitor.labels.list;
    result =  ent_ext.entity_detection(
        text=text,
        ner_labels= labels
        );
    fn = &quot;result.json&quot;;
    result = {&quot;text&quot;:text,&quot;entities&quot;:result[&quot;entities&quot;]};
    file.dump_json(fn, result);
}
</code></pre>
</li>
<li>
<p>Adding edge name of <code>ner_model</code> in <code>zero_shot_ner.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge ner_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding graph name of <code>ner_val_graph</code> for initializing node .</p>
<pre><code>graph ner_eval_graph {
    has anchor ner_model_dir;
    spawn {
        ner_model_dir = spawn node::model_dir;
        flair_ner_node = spawn node::flair_ner;
        ner_model_dir -[ner_model(model_type=&quot;flair_ner&quot;)]-&gt; flair_ner_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing <code>walker init</code> for calling graph</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::ner_val_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating <code>walker</code> name of <code>infer_zero_shot</code> for getting parameter from context and calling ability <code>set_config</code> and <code>infer_zero_shot</code> entity detection.</p>
<pre><code># creating walker for entity predictions
walker infer_zero_shot{
    has model_name;
    has model_type;
    has text;
    has labels;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p>It take arguments from context and call ability to set model configuration <code>set_config</code> and <code>infer_zero_shot</code> for detecting entity from text and store <code>result</code> in <code>result.json file</code></p>
</li>
</ol>
<ul>
<li>
<p><strong>Final jac program <code>zero_shot_ner.jac</code></strong></p>
<pre><code>node model_dir;
node flair_ner {
    # load the model actions here
    can ent_ext.entity_detection, ent_ext.set_config;

    can set_config with infer_zero_shot entry{
        report ent_ext.set_config(
            ner_model = visitor.model_name,
            model_type = visitor.model_type
        );
    }

    can infer_zero_shot with infer_zero_shot entry{
        text = visitor.text;
        labels = visitor.labels.list;
        result =  ent_ext.entity_detection(
            text=text,
            ner_labels= labels
            );
        fn = &quot;result.json&quot;;
        result = {&quot;text&quot;:text,&quot;entities&quot;:result[&quot;entities&quot;]};
        file.dump_json(fn, result);
    }
}

edge ner_model {
    has model_type;
}

graph ner_eval_graph {
    has anchor ner_model_dir;
    spawn {
        ner_model_dir = spawn node::model_dir;
        flair_ner_node = spawn node::flair_ner;
        ner_model_dir -[ner_model(model_type=&quot;flair_ner&quot;)]-&gt; flair_ner_node;
    }
}



walker init {
    root {
    spawn here --&gt; graph::ner_eval_graph; 
    }
}

# creating walker for entity predictions
walker infer_zero_shot{
    has model_name;
    has model_type;
    has text;
    has labels;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Steps for calling jac program <code>use case 1</code> and <code>infer_zero_shot entity</code> from new text.</p>
<ol>
<li>
<p>Build <code>zero_shot_ner.jac</code> by run cmd</p>
<pre><code>jac build zero_shot_ner.jac
</code></pre>
</li>
<li>
<p>Activate <code>sentinal</code> by run cmd:</p>
<pre><code>sentinel set -snt active:sentinel -mode ir zero_shot_ner.jir
</code></pre>
<p><strong>Note</strong>: If getting error <strong><code>ValueError: badly formed hexadecimal UUID string</code></strong> execute only once</p>
<blockquote>
<p>sentinel register -set_active true -mode ir zero_shot_ner.jir</p>
</blockquote>
</li>
<li>
<p>Module <code>entity_detection</code>: detects all availabe entities from the provided context</p>
<ul>
<li>
<h3 id="input-data"><a class="header" href="#input-data">Input Data:</a></h3>
<ul>
<li><code>model_name</code>: name of model which we are using for zero-shot entity detection e.g. <code>tars-ner</code></li>
<li><code>model_type</code> : type of model using in entity detection e.g. <code>tars</code> </li>
<li><code>text (string)</code>: context to detect entities. e.g. &quot;They had a record of five wins and two losses in Opening Day games at Bennett Park 19 wins and 22 losses at Tiger Stadium and three wins and four losses at Comerica Park for a total home record in Opening Day games of 26 wins and 28 losses&quot;</li>
<li><code>ner_labels(list of strings)</code>: List of entities, e.g. <code>[&quot;LOC&quot;,&quot;PER&quot;]</code></li>
</ul>
</li>
<li>
<h3 id="output-1"><a class="header" href="#output-1">Output</a></h3>
<ul>
<li><code>Result</code>: Created a json file that stored <code>input text</code> and <code>predicted entities</code> in result.json file`</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Run the following command to execute walker for <code>entity_detection</code> and pass <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#input-data"><code>Input Data</code></a> in context.</p>
<pre><code>walker run infer_zero_shot -ctx &quot;{\&quot;model_name\&quot;:\&quot;tars-ner\&quot;,\&quot;model_type\&quot;:\&quot;tars\&quot;,\&quot;text\&quot;:\&quot;They had a record of five wins and two losses in Opening Day games at Bennett Park 19 wins and 22 losses at Tiger Stadium and three wins and four losses at Comerica Park for a total home record in Opening Day games of 26 wins and 28 losses\&quot;,\&quot;labels\&quot;:[\&quot;building\&quot;, \&quot;organization\&quot;]}&quot;
</code></pre>
</li>
<li>
<p>After executing step 6 entity output will be stored in <code>result.json</code> file </p>
<pre><code>{
    &quot;text&quot;: &quot;They had a record of five wins and two losses in Opening Day games at Bennett Park 19 wins and 22 losses at Tiger Stadium and three wins and four losses at Comerica Park for a total home record in Opening Day games of 26 wins and 28 losses&quot;,
    &quot;entities&quot;: [
        {
            &quot;entity_text&quot;: &quot;Bennett Park&quot;,
            &quot;entity_value&quot;: &quot;building&quot;,
            &quot;conf_score&quot;: 0.9999510645866394,
            &quot;start_pos&quot;: 70,
            &quot;end_pos&quot;: 82
        },
        {
            &quot;entity_text&quot;: &quot;Tiger Stadium&quot;,
            &quot;entity_value&quot;: &quot;building&quot;,
            &quot;conf_score&quot;: 0.9999762773513794,
            &quot;start_pos&quot;: 108,
            &quot;end_pos&quot;: 121
        },
        {
            &quot;entity_text&quot;: &quot;Comerica Park&quot;,
            &quot;entity_value&quot;: &quot;building&quot;,
            &quot;conf_score&quot;: 0.999976634979248,
            &quot;start_pos&quot;: 156,
            &quot;end_pos&quot;: 169
        }
    ]
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="use-case-ii--few-shot-classification"><a class="header" href="#use-case-ii--few-shot-classification"><strong>Use Case II : Few-shot classification</strong></a></h2>
<p>In Few shot classification we are going train, test and validate <code>ent_ext</code> module</p>
<h3 id="1-creating-input-datasets"><a class="header" href="#1-creating-input-datasets">1. Creating Input Datasets</a></h3>
<p>For <code>train</code> <code>test</code> and <code>validation</code> we are going to prepare dataset from <a href="https://huggingface.co/datasets/conll2003">Conll2003</a> dataset, we are creating list of dict and storing in json file by name <code>train.json, validation.json and test.json</code>, 
and storing dataset file in directory name <code>dataset</code> and put all required file in this.</p>
<ul>
<li><strong>train_file : <code>dataset/train.json</code></strong>
<pre><code>[
    {
        &quot;context&quot;: &quot;EU rejects German call to boycott British lamb&quot;,
        &quot;entities&quot;: [
            {
                &quot;entity_value&quot;: &quot;EU&quot;,
                &quot;entity_type&quot;: &quot;ORG&quot;,
                &quot;start_index&quot;: 0,
                &quot;end_index&quot;: 2
            },
            {
                &quot;entity_value&quot;: &quot;German&quot;,
                &quot;entity_type&quot;: &quot;MISC&quot;,
                &quot;start_index&quot;: 11,
                &quot;end_index&quot;: 17
            },
            {
                &quot;entity_value&quot;: &quot;British&quot;,
                &quot;entity_type&quot;: &quot;MISC&quot;,
                &quot;start_index&quot;: 34,
                &quot;end_index&quot;: 41
            }
        ]
    }
]
</code></pre>
</li>
<li><strong>val_file : <code>dataset/val.json</code></strong>
<pre><code>[
    {
        &quot;context&quot;: &quot;CRICKET LEICESTERSHIRE TAKE OVER AT TOP AFTER INNINGS VICTORY&quot;,
        &quot;entities&quot;: [
            {
                &quot;entity_value&quot;: &quot;LEICESTERSHIRE&quot;,
                &quot;entity_type&quot;: &quot;ORG&quot;,
                &quot;start_index&quot;: 8,
                &quot;end_index&quot;: 22
            }
        ]
    }
]
</code></pre>
</li>
<li><strong>test_file : <code>dataset/test.json</code></strong>
<pre><code>[
    {
        &quot;context&quot;: &quot;The former Soviet republic was playing in an Asian Cup finals tie for the first time&quot;,
        &quot;entities&quot;: [
            {
                &quot;entity_value&quot;: &quot;Soviet&quot;,
                &quot;entity_type&quot;: &quot;MISC&quot;,
                &quot;start_index&quot;: 11,
                &quot;end_index&quot;: 17
            },
            {
                &quot;entity_value&quot;: &quot;Asian&quot;,
                &quot;entity_type&quot;: &quot;MISC&quot;,
                &quot;start_index&quot;: 45,
                &quot;end_index&quot;: 50
            },
            {
                &quot;entity_value&quot;: &quot;Asian&quot;,
                &quot;entity_type&quot;: &quot;MISC&quot;,
                &quot;start_index&quot;: 45,
                &quot;end_index&quot;: 50
            }
        ]
    }
]
</code></pre>
</li>
</ul>
<h3 id="2-import-flair-nerent_ext-module-in-jac"><a class="header" href="#2-import-flair-nerent_ext-module-in-jac"><strong>2. Import Flair ner(ent_ext) Module in jac</strong></a></h3>
<ol>
<li>Open terminal an run jaseci by cmd
<pre><code>jsctl -m
</code></pre>
</li>
<li>Load module <code>ent_ext</code> in jac by cmd
<pre><code>actions load module jaseci_kit.ent_ext
</code></pre>
</li>
</ol>
<h3 id="3-few-shot-classification-train-test-and-validate-model"><a class="header" href="#3-few-shot-classification-train-test-and-validate-model"><strong>3. Few-shot classification <code>(Train, Test and Validate model)</code></strong></a></h3>
<p>For this tutorial we are going to train the model on train dataset and validate the model on validation dataset and final test model on the test dataset.</p>
<ul>
<li>
<p><strong>Creating Jac Program</strong></p>
<ol>
<li>
<p>Create a file by name <code>flair_ner.jac</code></p>
</li>
<li>
<p>Create node <code>model_dir</code> and <code>flair_ner</code> in <code>flair_ner.jac</code> file</p>
<pre><code>node model_dir;
node flair_ner {};
</code></pre>
</li>
<li>
<p>Initializing node flair_ner and adding abilty <code>set_config</code> and <code>entity_detection</code></p>
<pre><code>node flair_ner{
    # set ability model configuration and train model
    ent_ext.set_config, can ent_ext.train, ent_ext.entity_detection;
    }
</code></pre>
</li>
<li>
<p>Initializing module for <code>set_config</code> inside node <code>flair_ner</code></p>
<pre><code>can set_config with infer_zero_shot entry{
    report ent_ext.set_config(
        ner_model = visitor.model_name,
        model_type = visitor.model_type
    );
}
</code></pre>
<p><strong>set_config</strong> will take two argument <code>model_name(str)</code> and <code>model_type(str)</code>.
and load model for training and validation.</p>
</li>
<li>
<p>Initializing module for <code>train</code> and <code>infer</code> inside node <code>flair_ner</code></p>
<pre><code>can train with train_and_val_flair entry{
    # train the model with a given dataset
    train_data = file.load_json(visitor.train_file);
    val_data = file.load_json(visitor.val_file);
    test_data = file.load_json(visitor.test_file);

    # training model
    ent_ext.train(
        train_data = train_data,
        val_data = val_data,
        test_data = test_data,
        train_params = {
            &quot;num_epoch&quot;: visitor.num_train_epochs.int,
            &quot;batch_size&quot;: visitor.batch_size.int,
            &quot;LR&quot;: visitor.learning_rate.float
            });
}

can infer with predict_flair entry{
    report ent_ext.entity_detection(
        text = visitor.text,
        ner_labels = visitor.ner_labels.list
    );
}
</code></pre>
<p><strong>train</strong> will take 4 parameter describing in upcoming steps <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#input-data-for-train-and-validation">parameter_description</a></p>
</li>
<li>
<p>Adding edge name of <code>ner_model</code> in <code>flair_ner.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge ner_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding graph name of <code>ner_val_graph</code> for initializing node .</p>
<pre><code>graph ner_eval_graph {
    has anchor ner_model_dir;
    spawn {
        ner_model_dir = spawn node::model_dir;
        flair_ner_node = spawn node::flair_ner;
        ner_model_dir -[ner_model(model_type=&quot;flair_ner&quot;)]-&gt; flair_ner_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing <code>walker init</code> for calling graph</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::ner_val_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating <code>walker</code> name of <code>train_and_val_flair</code> for getting parameter from context and calling ability <code>set_config</code> and <code>train</code> and start training model on new dataset, validate and test</p>
<pre><code>## creating walker 
walker train_and_val_flair {
    # Take in a training and eval dataset
    has train_file;
    has val_file;
    has test_file;
    has model_name=&quot;prajjwal1/bert-tiny&quot;;
    has model_type=&quot;trfmodel&quot;;
    has num_train_epochs=3;
    has batch_size=8;
    has learning_rate=0.02;

    # Train all NER models on the train set
    # and validate them on the val set
    # report accuracy performance on flair NER models
    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p>Here we are initialize some default argument and also we are providing all argument from context. it take arguments from context and call ability to set model configuration <code>set_config</code> and <code>train</code> is for training, val and test model on new datasets.</p>
</li>
<li>
<p>Creating walker for <code>predicting</code> <code>entities</code> from trained flair model.</p>
<pre><code># infer
walker predict_flair{
    has text;
    #declare default labels
    has ner_labels = [&quot;PER&quot;,&quot;ORG&quot;, &quot;LOC&quot;, &quot;MISC&quot;];

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }

}
</code></pre>
</li>
</ol>
</li>
<li>
<p><strong>Final Jac Program</strong></p>
<ul>
<li><code>flair_ner.jac</code>
<pre><code>node model_dir;
node flair_ner {
    # load the model actions here
    can ent_ext.set_config, ent_ext.train, ent_ext.entity_detection;


    can set_config with train_and_val_flair entry{
        ent_ext.set_config(
            ner_model = visitor.model_name,
            model_type = visitor.model_type
        );
    }


    can train with train_and_val_flair entry{
        # train the model with a given dataset
        train_data = file.load_json(visitor.train_file);
        val_data = file.load_json(visitor.val_file);
        test_data = file.load_json(visitor.test_file);

        # training model
        ent_ext.train(
            train_data = train_data,
            val_data = val_data,
            test_data = test_data,
            train_params = {
                &quot;num_epoch&quot;: visitor.num_train_epochs.int,
                &quot;batch_size&quot;: visitor.batch_size.int,
                &quot;LR&quot;: visitor.learning_rate.float
                });
    }

    can infer with predict_flair entry{
        report ent_ext.entity_detection(
            text = visitor.text,
            ner_labels = visitor.ner_labels.list
        );
    }
}


edge ner_model {
    has model_type;
}

graph ner_eval_graph {
    has anchor ner_model_dir;
    spawn {
        ner_model_dir = spawn node::model_dir;
        flair_ner_node = spawn node::flair_ner;
        ner_model_dir -[ner_model(model_type=&quot;flair_ner&quot;)]-&gt; flair_ner_node;
    }
}


walker init {
    root {
    spawn here --&gt; graph::ner_eval_graph; 
    }
}

## creating walker for:
# Train all NER models on the train set
# and validate them on the val set
# and test on test set
# report accuracy performance on flair NER models

walker train_and_val_flair {
    # Take in a training and eval dataset
    has train_file;
    has val_file;
    has test_file;
    has model_name=&quot;prajjwal1/bert-tiny&quot;;
    has model_type=&quot;trfmodel&quot;;
    has num_train_epochs=3;
    has batch_size=8;
    has learning_rate=0.02;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}

# infer
walker predict_flair{
    has text;
    #declare default labels
    has ner_labels = [&quot;PER&quot;,&quot;ORG&quot;, &quot;LOC&quot;, &quot;MISC&quot;];

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }

}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Steps for calling jac program(<code>flair_ner.jac</code>)</strong></p>
<ol>
<li>
<p>Build <code>flair_ner.jac</code> by run cmd :</p>
<pre><code>jac build flair_ner.jac
</code></pre>
</li>
<li>
<p>Activate <code>sentinal</code> by run cmd:</p>
<pre><code>sentinel set -snt active:sentinel -mode ir flair_ner.jir
</code></pre>
<p><strong>Note</strong>: If getting error <strong><code>ValueError: badly formed hexadecimal UUID string</code></strong> execute only once</p>
<blockquote>
<p>sentinel register -set_active true -mode ir flair_ner.jir</p>
</blockquote>
</li>
<li>
<p>Create <code>train and validation context</code>: train model on train dataset file and validate and test on validate and test dataset file.</p>
<ul>
<li>
<h3 id="input-data-for-train-and-validation"><a class="header" href="#input-data-for-train-and-validation">Input data for train and validation:</a></h3>
<ul>
<li><code>train_file(List(Dict))</code> : training dataset file</li>
<li><code>val_file(List(Dict))</code>: validation datase file</li>
<li><code>test_file(List(Dict))</code>: test dataset file</li>
<li><code>model_name(str)</code> : <code>prajjwal1/bert-tiny</code> or <code>tars-ner</code></li>
<li><code>model_type(str)</code> : <code>trfmodel</code> or <code>tars</code></li>
<li><code>num_train_epochs(int)</code> : <code>3</code> (default)</li>
<li><code>batch_size(int)</code>: <code>8</code></li>
<li><code>learning_rate(float)</code>:<code>0.02</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>Run the following command to execute walker for <code>model train and validation</code> and pass <a href="support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html#input-data-for-train-and-validation"><code>input data</code></a> in context.</p>
<pre><code>walker run train_and_val_flair -ctx &quot;{\&quot;train_file\&quot;:\&quot;dataset/train.json\&quot;,\&quot;val_file\&quot;:\&quot;dataset/val.json\&quot;,\&quot;test_file\&quot;:\&quot;dataset/test.json\&quot;,\&quot;model_name\&quot;:\&quot;prajjwal1/bert-tiny\&quot;,\&quot;model_type\&quot;:\&quot;trfmodel\&quot;,\&quot;num_train_epochs\&quot;:\&quot;10\&quot;,\&quot;batch_size\&quot;:\&quot;8\&quot;,\&quot;learning_rate\&quot;:\&quot;0.02\&quot;}&quot;

</code></pre>
</li>
<li>
<p>You'll find the following logs in train folder inside model name.
<code>Console logs</code></p>
<pre><code>2022-06-14 10:58:47,583 ----------------------------------------------------------------------------------------------------
2022-06-14 10:58:47,583 Corpus: &quot;Corpus: 14041 train + 3250 dev + 3453 test sentences&quot;
2022-06-14 10:58:47,583 ----------------------------------------------------------------------------------------------------
2022-06-14 10:58:47,583 Parameters:
2022-06-14 10:58:47,584  - learning_rate: &quot;0.02&quot;
2022-06-14 10:58:47,584  - mini_batch_size: &quot;128&quot;
2022-06-14 10:58:47,584  - patience: &quot;3&quot;
2022-06-14 10:58:47,584  - anneal_factor: &quot;0.5&quot;
2022-06-14 10:58:47,584  - max_epochs: &quot;10&quot;
2022-06-14 10:58:47,584  - shuffle: &quot;True&quot;
2022-06-14 10:58:47,584  - train_with_dev: &quot;False&quot;
2022-06-14 10:58:47,584  - batch_growth_annealing: &quot;False&quot;
2022-06-14 10:58:47,584 ----------------------------------------------------------------------------------------------------
2022-06-14 10:58:47,584 Model training base path: &quot;train/prajjwal1/bert-tiny&quot;
2022-06-14 10:58:47,584 ----------------------------------------------------------------------------------------------------
2022-06-14 10:58:47,584 Device: cuda:0
2022-06-14 10:58:47,584 ----------------------------------------------------------------------------------------------------
2022-06-14 10:58:47,584 Embeddings storage mode: cpu
2022-06-14 10:58:47,585 ----------------------------------------------------------------------------------------------------
2022-06-14 10:59:11,725 epoch 1 - iter 11/110 - loss 0.46690662 - samples/sec: 58.35 - lr: 0.020000
2022-06-14 10:59:36,854 epoch 1 - iter 22/110 - loss 0.35627199 - samples/sec: 56.04 - lr: 0.020000
2022-06-14 10:59:56,318 epoch 1 - iter 33/110 - loss 0.32018351 - samples/sec: 72.35 - lr: 0.020000
2022-06-14 11:00:16,082 epoch 1 - iter 44/110 - loss 0.30274213 - samples/sec: 71.25 - lr: 0.020000
2022-06-14 11:00:35,760 epoch 1 - iter 55/110 - loss 0.28451030 - samples/sec: 71.56 - lr: 0.020000
2022-06-14 11:00:58,241 epoch 1 - iter 66/110 - loss 0.26581275 - samples/sec: 62.64 - lr: 0.020000
2022-06-14 11:01:24,133 epoch 1 - iter 77/110 - loss 0.25145255 - samples/sec: 54.39 - lr: 0.020000
2022-06-14 11:01:48,914 epoch 1 - iter 88/110 - loss 0.24174765 - samples/sec: 56.82 - lr: 0.020000
2022-06-14 11:02:15,320 epoch 1 - iter 99/110 - loss 0.23233378 - samples/sec: 53.33 - lr: 0.020000
2022-06-14 11:02:40,455 epoch 1 - iter 110/110 - loss 0.22324374 - samples/sec: 56.03 - lr: 0.020000
2022-06-14 11:02:40,455 ----------------------------------------------------------------------------------------------------
2022-06-14 11:02:40,456 EPOCH 1 done: loss 0.2232 - lr 0.0200000
2022-06-14 11:04:15,844 DEV : loss 0.08416544854674485 - f1-score (micro avg)  0.1417
2022-06-14 11:04:15,876 BAD EPOCHS (no improvement): 0
2022-06-14 11:04:15,922 saving best model
..............
..............
..............

2022-06-14 11:48:43,609 epoch 10 - iter 11/110 - loss 0.05611527 - samples/sec: 61.04 - lr: 0.020000
2022-06-14 11:49:06,084 epoch 10 - iter 22/110 - loss 0.05563375 - samples/sec: 62.66 - lr: 0.020000
2022-06-14 11:49:29,709 epoch 10 - iter 33/110 - loss 0.05567900 - samples/sec: 59.61 - lr: 0.020000
2022-06-14 11:49:52,993 epoch 10 - iter 44/110 - loss 0.05584901 - samples/sec: 60.48 - lr: 0.020000
2022-06-14 11:50:16,497 epoch 10 - iter 55/110 - loss 0.05558204 - samples/sec: 59.91 - lr: 0.020000
2022-06-14 11:50:39,222 epoch 10 - iter 66/110 - loss 0.05536536 - samples/sec: 61.97 - lr: 0.020000
2022-06-14 11:51:03,463 epoch 10 - iter 77/110 - loss 0.05519602 - samples/sec: 58.09 - lr: 0.020000
2022-06-14 11:51:27,246 epoch 10 - iter 88/110 - loss 0.05550491 - samples/sec: 59.21 - lr: 0.020000
2022-06-14 11:51:50,920 epoch 10 - iter 99/110 - loss 0.05559963 - samples/sec: 59.48 - lr: 0.020000
2022-06-14 11:52:13,645 epoch 10 - iter 110/110 - loss 0.05556217 - samples/sec: 61.97 - lr: 0.020000
2022-06-14 11:52:13,646 ----------------------------------------------------------------------------------------------------
2022-06-14 11:52:13,646 EPOCH 10 done: loss 0.0556 - lr 0.0200000
2022-06-14 11:53:51,555 DEV : loss 0.03640907264452083 - f1-score (micro avg)  0.7614
2022-06-14 11:53:51,587 BAD EPOCHS (no improvement): 0
2022-06-14 11:53:51,634 saving best model
2022-06-14 11:53:51,725 ----------------------------------------------------------------------------------------------------
2022-06-14 11:53:51,726 loading file train/prajjwal1/bert-tiny/best-model.pt
2022-06-14 11:53:54,423 No model_max_length in Tokenizer's config.json - setting it to 512. Specify desired model_max_length by passing it as attribute to embedding instance.
2022-06-14 11:55:30,534 0.7138	0.7305	0.7221	0.6166
2022-06-14 11:55:30,534 
Results:
- F-score (micro) 0.7221
- F-score (macro) 0.5625
- Accuracy 0.6166

By class:
            precision    recall  f1-score   support

        PER     0.7186    0.8751    0.7892      1617
        LOC     0.7645    0.8118    0.7874      1668
        ORG     0.6902    0.5527    0.6138      1661
        MISC    0.6192    0.6254    0.6223       702
     &lt;STOP&gt;     0.0000    0.0000    0.0000         0

  micro avg     0.7138    0.7305    0.7221      5648
  macro avg     0.5585    0.5730    0.5625      5648
weighted avg    0.7115    0.7305    0.7164      5648
samples avg     0.6166    0.6166    0.6166      5648

</code></pre>
</li>
<li>
<p>Run the following command to execute walker <code>predict_flair</code> for predicting entities.</p>
<pre><code>walker run predict_flair -ctx &quot;{\&quot;text\&quot;:\&quot;Two goals from defensive errors in the last six minutes allowed Japan to come from behind and collect all three points from their opening meeting against Syria\&quot;}&quot;
</code></pre>
<p>After executing walker <code>predict_flair</code> will get output e.g.</p>
<pre><code>[
    {
        &quot;entities&quot;: [
            {
                &quot;entity_text&quot;: &quot;Japan&quot;,
                &quot;entity_value&quot;: &quot;LOC&quot;,
                &quot;conf_score&quot;: 0.9944729208946228,
                &quot;start_pos&quot;: 64,
                &quot;end_pos&quot;: 69
            },
            {
                &quot;entity_text&quot;: &quot;Syria&quot;,
                &quot;entity_value&quot;: &quot;LOC&quot;,
                &quot;conf_score&quot;: 0.9952408075332642,
                &quot;start_pos&quot;: 154,
                &quot;end_pos&quot;: 159
            }
        ]
    }
]
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="experiment-and-methodology"><a class="header" href="#experiment-and-methodology"><strong>Experiment and methodology</strong></a></h2>
<ul>
<li>
<p><strong>Zero-Shot entity detection</strong></p>
<p>Let us further look our <code>zero-shot entity</code> detection on <a href="https://ningding97.github.io/fewnerd/">Few-Nerd Dataset</a>, Few-NERD is a large-scale, fine-grained manually annotated named entity recognition dataset, which contains <code>8 coarse-grained(Major)</code> types, <code>66 fine-grained(All)</code> labels types. Three benchmark tasks are built, one is supervised (Few-NERD (SUP)) and the other two are few-shot (Few-NERD (INTRA) and Few-NERD (INTER)).</p>
<h3 id="dataset-details"><a class="header" href="#dataset-details"><strong>Dataset details</strong></a></h3>
<p>| Dataset Name                   | train dataset             | validation dataset         | test dataset          |
|--------------------------------|---------------------------|----------------------------|-----------------------|
| FEW-NERD (SUP)                 | 131767                    | 18824                      | 37648                 |</p>
<p>For zero-shot entity-detection we are using flair <strong>tars-ner</strong> model.</p>
<p><strong>Results</strong></p>
<h2 id="zero-shot-performance-on-few-nerdinter-test-dataset"><a class="header" href="#zero-shot-performance-on-few-nerdinter-test-dataset">Zero-shot performance on FEW-NERD(INTER) test Dataset.</a></h2>
<p>| Labels          | Accuracy        | F1_Score     |
|-----------------|-----------------|--------------|
| All             | 0.32053081      | 0.305329825  |
| Major           | 0.475163372	    | 0.447818008  |</p>
<h2 id="zero-shot-performance-on-few-nerdintra-test-dataset"><a class="header" href="#zero-shot-performance-on-few-nerdintra-test-dataset">Zero-shot performance on FEW-NERD(INTRA) test Dataset.</a></h2>
<p>| Labels          | Accuracy         | F1_Score     |
|-----------------|------------------|--------------|
| All             | 0.143001171      | 0.171142318  |
| Major           | 0.540210805	     | 0.462717092  |</p>
<h2 id="zero-shot-performance-on-few-nerdsup-test-dataset"><a class="header" href="#zero-shot-performance-on-few-nerdsup-test-dataset">Zero-shot performance on FEW-NERD(SUP) test Dataset.</a></h2>
<p>| Labels          | Accuracy         | F1_Score     |
|-----------------|------------------|--------------|
| All             | 0.105859864      | 0.128166615  |
| Major           | 0.475106014	     | 0.431429256  |</p>
<p>From this results we will get following insight, if we have number of labels is less, we will get higher accuracy and f1_score.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-extraction-using-transformers-tfm_ner"><a class="header" href="#entity-extraction-using-transformers-tfm_ner">Entity Extraction Using Transformers (<code>tfm_ner</code>)</a></h1>
<p><strong>What is NER:</strong> named entity recognition (NER) — sometimes referred to as entity chunking, extraction, or identification — is the task of identifying and categorizing key information (entities) in text. An entity can be any word or series of words that consistently refers to the same thing. Every detected entity is classified into a predetermined category.</p>
<p><strong><code>tfm_ner</code></strong>: module based on transformers to identify and extract entities. It uses TokenClassification method from Huggingface.</p>
<p>This tutorial show you how to train test and validate <strong>tfm_ner</strong> module.</p>
<h1 id="transformer-ner"><a class="header" href="#transformer-ner">Transformer NER</a></h1>
<ol>
<li>Preparing <a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html#1-preparing-dataset">Dataset</a></li>
<li>Import <a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html#2-import-tfm_ner-module-in-jaseci">tfm_ner</a> module</li>
<li>Model <a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html#3-model-training-and-validation">training and validation</a></li>
<li><a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html#4-predicting-entities">Predicting entities</a></li>
<li><a href="support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html#5-experiments-and-methodology">Experiments and methodology</a></li>
</ol>
<h2 id="1-preparing-dataset"><a class="header" href="#1-preparing-dataset"><strong>1. Preparing Dataset</strong></a></h2>
<p>For train, test and validation dataset, we are going to creating list of dict and storing in json file by name <code>train.json</code>, <code>validation.json</code> and <code>test.json</code> for demonstration perpose we are using here <a href="https://huggingface.co/datasets/conll2003">conll2003 dataset</a> and storing dataset file in directory name <code>dataset</code> and put all required file in this directory.</p>
<p><strong>Example Dataset file <code>data format</code></strong></p>
<ul>
<li>
<p><strong><code>train_data</code>:</strong>: (List(Dict)): a list dictionary containing contexts and list of entities in each context.</p>
<pre><code>[{
    &quot;context&quot;: &quot;However a loophole in the law allowed Buddharakkita and Jayewardene evade the death penalty as the Capital Punishment Repeal Act allowed for a sentence of death to a person convicted for murder committed prior to December 2 1959 and not for the offence of conspiracy to commit murder&quot;,
    &quot;entities&quot;: [
        {
            &quot;entity_value&quot;: &quot;Buddharakkita&quot;,
            &quot;entity_type&quot;: &quot;person&quot;,
            &quot;start_index&quot;: 38,
            &quot;end_index&quot;: 51
        },
        {
            &quot;entity_value&quot;: &quot;Jayewardene&quot;,
            &quot;entity_type&quot;: &quot;person&quot;,
            &quot;start_index&quot;: 56,
            &quot;end_index&quot;: 67
        },
        {
            &quot;entity_value&quot;: &quot;Capital Punishment Repeal Act&quot;,
            &quot;entity_type&quot;: &quot;event&quot;,
            &quot;start_index&quot;: 99,
            &quot;end_index&quot;: 128
        }
    ]
    }
]
</code></pre>
</li>
<li>
<p><strong><code>val_data</code>:</strong> (List(Dict)): a list dictionary containing contexts and list of entities in each context</p>
<pre><code>[
    {
        &quot;context&quot;: &quot;The Stavros Niarchos Foundation Cultural Center inaugurated in 2016 will house the National Library of Greece and the Greek National Opera&quot;,
        &quot;entities&quot;: [
            {
                &quot;entity_value&quot;: &quot;Stavros Niarchos Foundation Cultural Center&quot;,
                &quot;entity_type&quot;: &quot;building&quot;,
                &quot;start_index&quot;: 4,
                &quot;end_index&quot;: 47
            },
            {
                &quot;entity_value&quot;: &quot;National Library of Greece&quot;,
                &quot;entity_type&quot;: &quot;building&quot;,
                &quot;start_index&quot;: 83,
                &quot;end_index&quot;: 109
            },
            {
                &quot;entity_value&quot;: &quot;Greek National Opera&quot;,
                &quot;entity_type&quot;: &quot;building&quot;,
                &quot;start_index&quot;: 118,
                &quot;end_index&quot;: 138
            }
        ]
    }
]
</code></pre>
</li>
<li>
<p><strong><code>test_data</code>:</strong> (List(Dict)): a list dictionary containing contexts and list of entities in each context</p>
<pre><code>[
    {
        &quot;context&quot;: &quot;The project proponents told the Australian Financial Review in December that year that they had been able to demonstrate that the market for backpacker tourism was less affected by these events and that they intended to apply for an air operator 's certificate in January 2004&quot;,
        &quot;entities&quot;: [
            {
                &quot;entity_value&quot;: &quot;Australian Financial Review&quot;,
                &quot;entity_type&quot;: &quot;organization&quot;,
                &quot;start_index&quot;: 32,
                &quot;end_index&quot;: 59
            }
        ]
    }
]
</code></pre>
</li>
</ul>
<h2 id="2-import-tfm_ner-module-in-jaseci"><a class="header" href="#2-import-tfm_ner-module-in-jaseci"><strong>2. Import <code>tfm_ner</code> module in jaseci</strong></a></h2>
<ol>
<li>Open terminal and run jaseci by cmd
<pre><code>jsctl -m
</code></pre>
</li>
<li>Load module tfm_ner in jac by cmd
<pre><code>actions load module jaseci_kit.tfm_ner
</code></pre>
</li>
</ol>
<h2 id="3-model-training-and-validation"><a class="header" href="#3-model-training-and-validation"><strong>3. Model training and validation</strong></a></h2>
<p>For this tutorial we are going to train the model on train dataset and validate the model on validation dataset and finaly we test model on the test dataset.</p>
<p><strong>1. Creating Jac Program</strong></p>
<ol>
<li>
<p><code>Create a file (main.jac)</code></p>
</li>
<li>
<p>Create node <code>model_dir</code> and  <code>tfm_ner</code> in <code>main.jac</code></p>
<pre><code>node model_dir;
node tfm_ner {}
</code></pre>
</li>
<li>
<p>Initializing <code>node tfm_ner</code> and adding abilty:- <code>train</code>, <code>infer</code></p>
<p>Here we are importing ability to train and infer model.</p>
<pre><code>node tfm_ner {
    # train, infer
    can tfm_ner.train, tfm_ner.extract_entity, tfm_ner.load_model, tfm_ner.save_model, tfm_ner.get_train_config, tfm_ner.set_train_config;
}

</code></pre>
</li>
<li>
<p>Initializing module for <code>train and validation</code> inside <code>node tfm_ner</code>
In this step we are initializing <code>training</code> and <code>validation</code> of tfm_ner model. It will take 5 parameter train, test, val (file contain <code>list of dict</code>) and mode and epochs</p>
<pre><code># train and validation model 
can train_and_val with train_and_val_tfm entry {
    train_data = file.load_json(visitor.train_file);
    val_data = file.load_json(visitor.val_file);
    test_data = file.load_json(visitor.test_file);
    std.out(&quot;corpus : &quot;,train_data.length,&quot; train + &quot;,val_data.length,&quot; val +&quot;,test_data.length,&quot; test sentences&quot;);
    tfm_ner.train(
        mode = visitor.mode,
        epochs = visitor.num_train_epochs.int,
        train_data = train_data,
        dev_data = val_data,
        test_data = test_data
        );
    std.out(&quot;training and validation done &quot;);
    }
</code></pre>
</li>
<li>
<p>Adding module for <code>infer entity</code> inside node <code>tfm_ner</code></p>
<p><code>Infer</code> module will take text input and return entities list.</p>
<pre><code># infer entity from text
can infer with predict_entity_from_tfm entry {
    report tfm_ner.extract_entity(
        text = visitor.text
    );
}
</code></pre>
</li>
<li>
<p>Adding <code>edge</code> name of  <code>ner_model</code> in <code>main.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge ner_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding <code>graph</code> name of <code>ner_val_graph</code> for initializing node . </p>
<pre><code># Adding Graph
graph ner_val_graph {
    has anchor ner_model_dir;
    spawn {
        ner_model_dir = spawn node::model_dir;
        tfm_ner_node = spawn node::tfm_ner;
        ner_model_dir -[ner_model(model_type=&quot;tfm_ner&quot;)]-&gt; tfm_ner_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing <code>walker init</code> for calling graph</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::ner_val_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating <code>walker</code> name of <code>train_and_val_tfm</code> for getting parameter from context and calling ability <code>training and validation</code> model.</p>
<pre><code># creating walker 
walker train_and_val_tfm {
    has train_file;
    has val_file;
    has test_file;
    has num_train_epochs;
    has mode;

    # Train NER models on the train set
    # and validate them on the val set (Optional)
    # and test them on the test set (Optional)

    # report accuracy performance of NER model on inside dir creating on place of current path `main.jac` file &quot;train/logs/&quot;
    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
</li>
<li>
<p>Creating a walker name of <code>predict_entity_from_tfm</code> for getting new text as input from context and infer entities.</p>
<pre><code>walker predict_entity_from_tfm{
    has text;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
</li>
</ol>
<ul>
<li>
<p><strong>Final jac programm <code>(main.jac)</code></strong></p>
<pre><code>node model_dir;
node tfm_ner {
    # train,infer
    can tfm_ner.extract_entity, tfm_ner.train;

    # extracting entities
    can infer with predict_entity_from_tfm entry {
        report tfm_ner.extract_entity(
            text = visitor.text
        );
    }

    ## train and validate
    can train_and_val with train_and_val_tfm entry {

        train_data = file.load_json(visitor.train_file);
        val_data = file.load_json(visitor.val_file);
        test_data = file.load_json(visitor.test_file);
        std.out(&quot;corpus : &quot;,train_data.length,&quot; train + &quot;,val_data.length,&quot; dev +&quot;,test_data.length,&quot; test sentences&quot;);
        tfm_ner.train(
            mode = visitor.mode,
            epochs = visitor.num_train_epochs.int,
            train_data = train_data,
            dev_data = val_data,
            test_data = test_data
            );
        std.out(&quot;training and validation done &quot;);
        }
}


edge ner_model {
    has model_type;
}

graph ner_val_graph {
    has anchor ner_model_dir;
    spawn {
        ner_model_dir = spawn node::model_dir;
        tfm_ner_node = spawn node::tfm_ner;
        ner_model_dir -[ner_model(model_type=&quot;tfm_ner&quot;)]-&gt; tfm_ner_node;
    }
}


walker init {
    root {
    spawn here --&gt; graph::ner_val_graph; 
    }
}

## creating walker 
walker train_and_val_tfm {
    has train_file;
    has val_file;
    has test_file;
    has num_train_epochs;
    has mode;

    # Train all NER models on the train set
    # and validate them on the val set
    # report accuracy performance across all NER models
    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}

walker predict_entity_from_tfm{
    has text;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}

</code></pre>
</li>
</ul>
<p><strong>2. Steps for running <code>main.jac</code> file</strong> and <code>train</code> and <code>validate</code> tfm_ner model</p>
<ol>
<li>
<p>Build main.jac by run:</p>
<pre><code>jac build main.jac
</code></pre>
</li>
<li>
<p>Run the following command to Activate sentinal:</p>
<pre><code>sentinel set -snt active:sentinel -mode ir main.jir
</code></pre>
</li>
<li>
<p>Create <code>Training Input</code></p>
<ul>
<li><code>mode</code>: (String): mode for training the model, available options are :
* <code>default</code>: train the model from scratch.
* <code>incremental</code>: providing more training data for current set of entities.
* <code>append</code>: changing the number of entities (model is restarted and trained with all of traindata).</li>
<li><code>epochs </code>: (int): Number of epoch you want model to train.</li>
<li><code>train_file</code>: <code>list[dict]</code> train data file name.</li>
<li><code>val_file</code>: <code>list[dict]</code> validation data file name.</li>
<li><code>test_file</code>: <code>list[dict]</code> test data file name.</li>
</ul>
</li>
<li>
<p>Run the following command to execute walker <code>train_and_val_tfm</code></p>
<pre><code>walker run train_and_val_tfm -ctx &quot;{\&quot;train_file\&quot;:\&quot;dataset/train.json\&quot;,\&quot;val_file\&quot;:\&quot;dataset/dev.json\&quot;,\&quot;test_file\&quot;:\&quot;dataset/test.json\&quot;,\&quot;num_train_epochs\&quot;:\&quot;50\&quot;,\&quot;mode\&quot;:\&quot;default\&quot;}&quot;
</code></pre>
</li>
<li>
<p>You'll find the following logs in <code>train</code> folder.</p>
<pre><code>2022-06-06 11:23:46.832007    Training epoch: 1/50
2022-06-06 11:23:46.847969    Training loss per 100 training steps: 0.9243220090866089
2022-06-06 11:23:47.186904    Training loss epoch: 0.8817697350795453
2022-06-06 11:23:47.191905    Training accuracy epoch: 0.11538461538461539
2022-06-06 11:23:47.330845    Validation loss epoch: 0.7973677378434402
2022-06-06 11:23:47.336076    Validation accuracy epoch: 0.038461538461538464
2022-06-06 11:23:47.442199    Epoch 1 total time taken : 0:00:00.610192
2022-06-06 11:23:47.448885    ------------------------------------------------------------
2022-06-06 11:23:47.456886    Training epoch: 2/50
2022-06-06 11:23:47.474848    Training loss per 100 training steps: 0.8383979797363281
2022-06-06 11:23:47.814906    Training loss epoch: 0.7714704366830679
2022-06-06 11:23:47.820939    Training accuracy epoch: 0.023076923076923078
2022-06-06 11:23:47.969910    Validation loss epoch: 0.70741940003175
2022-06-06 11:23:47.976287    Validation accuracy epoch: 0.0
2022-06-06 11:23:48.075297    Epoch 2 total time taken : 0:00:00.618411
2022-06-06 11:23:48.081293    ------------------------------------------------------------
............
............
............
2022-06-01 07:07:56.382809     Training epoch: 50/50
2022-06-01 07:08:22.558677     Training loss epoch: 0.06641783774011399
2022-06-01 07:08:22.558712     Training accuracy epoch: 0.9109369783381449
2022-06-01 07:08:22.558778     evaluation loss epoch: 0.16095292149111629
2022-06-01 07:08:22.558790     evaluation accuracy epoch: 0.8269142243363511
2022-06-01 07:08:22.647852     Epoch 50 total time taken : 0:00:26.265050
2022-06-01 07:08:22.647874     ------------------------------------------------------------
2022-06-01 07:08:22.797730     Model Training is Completed
2022-06-01 07:08:22.797769     ------------------------------------------------------------
2022-06-01 07:08:22.797779     Total time taken to completed training :  0:22:06.770898
2022-06-01 07:08:22.797795     ------------------------------------------------------------
2022-06-01 07:08:22.797807     Model testing is started
2022-06-01 07:08:22.797819     ------------------------------------------------------------
2022-06-01 07:08:27.092534     f1_score(macro) : 0.6822521889259535
2022-06-01 07:08:27.092573     Accuracy : 0.7892490767336889 
2022-06-01 07:08:27.092581     Classification Report
2022-06-01 07:08:27.092584     ------------------------------------------------------------
            precision    recall  f1-score   support

        O       0.00      0.00      0.00         0
    I-PER       0.91      0.90      0.91      2496
    I-ORG       0.82      0.68      0.74      1018
    I-MISC      0.84      0.54      0.66       236
    I-LOC       0.66      0.64      0.65       252
    B-PER       0.84      0.85      0.85      2714
    B-ORG       0.83      0.71      0.77      2513
    B-MISC      0.82      0.64      0.72       991
    B-LOC       0.85      0.84      0.85      1965

 accuracy                           0.79     12185
macro avg       0.73      0.65      0.68     12185
weighted avg    0.85      0.79      0.82     12185

2022-06-01 07:08:27.092694     ------------------------------------------------------------
2022-06-01 07:08:27.092707     Total time taken to completed testing :  0:00:04.294899
2022-06-01 07:08:27.092722     ------------------------------------------------------------ 

</code></pre>
</li>
</ol>
<h2 id="4-predicting-entities"><a class="header" href="#4-predicting-entities"><strong>4. Predicting Entities</strong></a></h2>
<ul>
<li>
<p>For predicting entities we are going execute walker <code>predict_entity_from_tfm</code> and provide text input in context and will get output <code>list of entities</code> available in text-data.
Run the following command to execute walker <code>predict_entity_from_tfm</code></p>
<pre><code>walker run predict_entity_from_tfm -ctx &quot;{\&quot;text\&quot;:\&quot;It was the second costly blunder by Syria in four minute\&quot;}&quot;
</code></pre>
</li>
<li>
<p>After executing walker <code>predict_entity_from_tfm</code> , will get <code>predicted entities</code> list as</p>
<pre><code>[
    {
        &quot;entity_value&quot;: &quot;syria&quot;,
        &quot;entity_type&quot;: &quot;B-LOC&quot;,
        &quot;score&quot;: 0.8613966703414917,
        &quot;start_index&quot;: 36,
        &quot;end_index&quot;: 41
    }
]
</code></pre>
</li>
</ul>
<h1 id="5-experiments-and-methodology"><a class="header" href="#5-experiments-and-methodology"><strong>5. Experiments and methodology</strong></a></h1>
<p>Let us further look into our model training and evaluation methodology</p>
<h2 id="evaluation-of-tfm_ner-with-tiny-bert-and-bert"><a class="header" href="#evaluation-of-tfm_ner-with-tiny-bert-and-bert"><strong>Evaluation of tfm_ner with <code>tiny-bert</code> and <code>bert</code></strong></a></h2>
<p>We are evaluating <code>tiny-bert</code> and <code>bert-base-uncased</code> model on following datasets.</p>
<h2 id="dataset-description"><a class="header" href="#dataset-description"><strong>Dataset description</strong></a></h2>
<p>We are using two different dataset.</p>
<p><strong>1. CONLL2003 <a href="https://huggingface.co/datasets/conll2003">dataset</a></strong> is a named entity recognition dataset released as a part of CoNLL-2003 shared task. CoNLL-2003 dataset have <strong>4 labels</strong>(PER, ORG, LOC, MISC).</p>
<p><strong>2. FEW-NERD <a href="https://ningding97.github.io/fewnerd/">dataset</a></strong> is a large-scale, fine-grained manually annotated named entity recognition dataset, which contains <code>8 coarse-grained(Major)</code> types, <code>66 fine-grained(All)</code> types labels.</p>
<h3 id="dataset-details-1"><a class="header" href="#dataset-details-1"><strong>Dataset details</strong></a></h3>
<div class="table-wrapper"><table><thead><tr><th>Dataset Name</th><th>train dataset</th><th>validation dataset</th><th>test dataset</th></tr></thead><tbody>
<tr><td>Conll2003</td><td>14,041</td><td>3,250</td><td>3,453</td></tr>
<tr><td>FEW-NERD (SUP)</td><td>131,767</td><td>18,824</td><td>37,648</td></tr>
</tbody></table>
</div>
<h2 id="training-methodology"><a class="header" href="#training-methodology"><strong>Training methodology</strong></a></h2>
<p>For training model we are using pytorch model from huggingface for token classification .</p>
<ul>
<li>
<p><strong>Default training parameter are following</strong>.</p>
<pre><code>&quot;MAX_LEN&quot;: 128,
&quot;TRAIN_BATCH_SIZE&quot;: 64,
&quot;VALID_BATCH_SIZE&quot;: 32,
&quot;EPOCHS&quot;: 50,
&quot;LEARNING_RATE&quot;: 2e-05,
&quot;MAX_GRAD_NORM&quot;: 10,
&quot;MODE&quot;: &quot;default&quot;
</code></pre>
<h3 id="machine-description-for-training-model"><a class="header" href="#machine-description-for-training-model"><strong><code>Machine</code> description for training model</strong></a></h3>
<ul>
<li><strong>RAM</strong> : <strong><code>32GB</code></strong></li>
<li><strong>GPU</strong> : <strong><code>TESLA T4</code></strong></li>
<li><strong>Memory GPU</strong> : <strong><code>16GB</code></strong></li>
</ul>
<h3 id="results"><a class="header" href="#results"><strong>Results</strong></a></h3>
<h3 id="training-on-sample-data-from-few-nerdsup-dataset-on-major-labels"><a class="header" href="#training-on-sample-data-from-few-nerdsup-dataset-on-major-labels">Training on sample data from <code>FEW-NERD(SUP)</code> Dataset on <code>major labels</code></a></h3>
<p>| Model_Name               | Evaluation_Accuracy  | Test_Accuracy   | Test F1_Score       |Time Taken(avg)  |
|--------------------------|----------------------|-----------------|---------------------|-----------------|
|bert-base-uncased         | 0.6910               | 0.6888	        | 0.6353              | 2HR+20MIN       |
|prajjwal1/bert-tiny       | 0.2184	              | 0.2182          | 0.2090	          | 26MIN           |</p>
<h3 id="training-on-sample-data-from-few-nerdsup-dataset"><a class="header" href="#training-on-sample-data-from-few-nerdsup-dataset">Training on sample data from <code>FEW-NERD(SUP)</code> Dataset</a></h3>
<p>| Model_Name               | Evaluation_Accuracy  | Test_Accuracy   | Test F1_Score       | Time Taken(avg) |
|--------------------------|----------------------|-----------------|---------------------|-----------------|
|bert-base-uncased         | 0.5841               | 0.5830	        | 0.5702              | 3HR+36MIN       |
|prajjwal1/bert-tiny       | 0.1900	              | 0.1894          | 0.0546    	      | 35MIN           |</p>
<h3 id="training-on-conll2003-dataset"><a class="header" href="#training-on-conll2003-dataset">Training on <code>CONLL2003</code> dataset</a></h3>
<p>| Model_Name               | Evaluation_Accuracy  | Test_Accuracy   | Test F1_Score       | Time Taken(avg) |
|--------------------------|----------------------|-----------------|---------------------|-----------------|
|bert-base-uncased         | 0.9585               | 0.9859	        | 0.8100              | 3HR+45MIN       |
|prajjwal1/bert-tiny       | 0.8269	              | 0.7892          | 0.6823              | 35MIN           |</p>
<p>After comparing these results we will get the insight from this</p>
<ul>
<li>
<p><strong>Number of labels upto 4</strong></p>
<ul>
<li>We prefare training time, we need to go with small model e.g. <code>tiny-bert</code></li>
<li>We are focussing higher accuracy result, we need to go with bigger model e.g. <code>bert-base-uncased</code></li>
</ul>
</li>
<li>
<p><strong>Number of labels greater then 4</strong></p>
<ul>
<li>We need to go with bigger model so we will get higher <code>accuracy</code> and <code>f1-score</code> e.g. <code>bert-base-uncased</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="text-summarization"><a class="header" href="#text-summarization">Text Summarization</a></h1>
<p>Text summarization consists of condensing or creating a shorter version of an initial text while preserving the key meaning of the text. Text summarization may be used in text classification, headline generation, question answering, etc. Jaseci provides the following text summarization engines:</p>
<h2 id="summarization-models"><a class="header" href="#summarization-models">Summarization Models</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><a href="support/guide/jaseci_kit/modules/summarization/cl_summer/README.html"><code>cl_summer</code></a></td><td>Summarizer</td><td>No Training req.</td><td>Ready</td><td>Extractive Summarization using Sumy</td><td><a href="support/guide/jaseci_kit/modules/summarization/cl_summer/README.html">Documenatation</a> <a href="https://miso-belica.github.io/sumy/">Doc.</a></td></tr>
<tr><td><a href="support/guide/jaseci_kit/modules/summarization/t5_sum/README.html"><code>t5_sum</code></a></td><td>Summarizer</td><td>No Training req.</td><td>Ready</td><td>Abstractive Summarization using the T5 Model</td><td><a href="support/guide/jaseci_kit/modules/summarization/t5_sum/README.html">Documentation</a> <a href="https://huggingface.co/docs/transformers/model_doc/t5">Doc.</a>, <a href="https://arxiv.org/pdf/1910.10683.pdf">Paper</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="summarizer-cl_summer"><a class="header" href="#summarizer-cl_summer"><strong>Summarizer (<code>cl_summer</code>)</strong></a></h1>
<p>Module <code>cl_summer</code> uses the <code>sumy summarizer</code> to extract summary from text.</p>
<ol>
<li>Import <a href="support/guide/jaseci_kit/modules/summarization/cl_summer/index.html#1-import-summarizer-cl_summer-module-in-jac"><code>cl_summer</code></a> module in jac</li>
<li><a href="support/guide/jaseci_kit/modules/summarization/cl_summer/index.html#2-summarizer">Summarizer</a></li>
</ol>
<h1 id="walk-through-2"><a class="header" href="#walk-through-2"><strong>Walk through</strong></a></h1>
<h2 id="1-import-summarizer-cl_summer-module-in-jac"><a class="header" href="#1-import-summarizer-cl_summer-module-in-jac"><strong>1. Import Summarizer (<code>cl_summer</code>) module in jac</strong></a></h2>
<ol>
<li>For executing jaseci Open terminal and run follow command.
<pre><code>jsctl -m
</code></pre>
</li>
<li>Load cl_summer module in jac by command
<pre><code>actions load module jaseci_kit.cl_summer
</code></pre>
</li>
</ol>
<h2 id="2-summarizer"><a class="header" href="#2-summarizer"><strong>2. Summarizer</strong></a></h2>
<p>For this tutorial, we are going to leverage the <strong>Summarizer</strong> (<code>cl_summer</code>) which would help us to generate summary of the provided text.</p>
<ul>
<li>
<p>Creating Jac Program for <strong>summarizer</strong> (<code>cl_summer</code>)</p>
<ol>
<li>
<p>Create a file by name summarizer.jac</p>
</li>
<li>
<p>Create node model_dir and <code>summarizer</code> in <code>summarizer.jac</code> file.</p>
<pre><code>node model_dir;
node summarizer{};
</code></pre>
</li>
<li>
<p>Initializing node <code>summarizer</code> and import <code>cl_summer.summarize</code> ability inside node <code>summarizer</code>.</p>
<pre><code># import ability
can cl_summer.summarize;
</code></pre>
</li>
<li>
<p>Initialize module <code>summarize</code> inside <code>summarizer</code> node.</p>
<pre><code class="language-python"># summarizer
can summarize with summarizer entry{
    data = file.load_json(visitor.data);
    
    report cl_summer.summarize(
        text = data[&quot;text&quot;],
        url = data[&quot;url&quot;],
        sent_count = data[&quot;sent_count&quot;],
        summarizer_type = data[&quot;summarizer_type&quot;]
        );      
}
</code></pre>
<p><code>summarize</code>: to get the extractive summary of the text in the given number of sentence counts .</p>
<p><strong>Parameter details</strong></p>
<ul>
<li>
<p><strong>Input Data</strong></p>
<p><strong>data.json</strong> file</p>
<pre><code>{
    &quot;text&quot;: &quot;There was once a king of Scotland whose name was Robert Bruce. He needed to be both brave and wise because the times in which he lived were wild and   rude. The King of England was at war with him and had led a great army into Scotland to drive him out of the land. Battle after battle had been fought. Six times Bruce had led his brave little army against his foes and six times his men had been beaten and driven into flight. At last his army was scattered, and he was forced to hide in the woods and in lonely places among the mountains. One rainy day, Bruce lay on the ground under a crude shed listening to the patter of the drops on the roof above him. He was tired and unhappy. He was ready to give up all hope. It seemed to him that there was no use for him to try to do anything more. As he lay thinking, he saw a spider over his head making ready to weave her web. He watched her as she toiled slowly and with great care. Six times she tried to throw her frail thread from one beam to another, and six times it fell short. 'Poor thing,' said Bruce: 'you, too, know what it is to fail.', But the spider did not lose hope with the sixth failure. With still more care, she made ready to try for the seventh time. Bruce almost forgot his own troubles as, he watched her swing herself out upon the slender line. Would she fail again? No! The thread was carried safely to the beam and fastened there.&quot;,
    &quot;url&quot;: &quot;none&quot;,
    &quot;sent_count&quot;: 5,
    &quot;summarizer_type&quot;: &quot;LsaSummarizer&quot;
}
</code></pre>
<ul>
<li><code>text(String)</code>: text the contain the entire context</li>
<li><code>url(String)</code>: the link to the webpage</li>
<li><code>sent_count(int)</code>: number of sentence you want in the summary</li>
<li><code>summarizer_type(String)</code>: name of the summarizer type, available options are:
<ul>
<li>LsaSummarizer</li>
<li>LexRankSummarizer</li>
<li>LuhnSummarizer</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Output</strong>
List of Sentences that best summarizes the context</p>
</li>
</ul>
</li>
<li>
<p>Adding edge name of <code>summ_model</code> in <code>summarizer.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge summ_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding graph name of <code>summ_graph</code> for initializing node.</p>
<pre><code class="language-python"># adding graph
graph summ_graph {
    has anchor summ_model_dir;
    spawn {
        summ_model_dir = spawn node::model_dir;
        summarizer_node = spawn node::summarizer;
        summ_model_dir -[summ_model(model_type=&quot;summarizer&quot;)]-&gt; summarizer_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing walker init for calling graph.</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::summ_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating walker name of <code>summarizer</code> for getting parameter from context or default and calling ability <code>summarize</code>.</p>
<pre><code class="language-python"># declaring walker for summerize text
walker summarizer{
    has data=&quot;data.json&quot;;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p><strong>Final summarizer.jac program</strong></p>
<pre><code class="language-python">node model_dir;
node summarizer{
    # import ability
    can cl_summer.summarize;

    # summarizer
    can summarize with summarizer entry{
        data = file.load_json(visitor.data);
        
        report cl_summer.summarize(
            text = data[&quot;text&quot;],
            url = data[&quot;url&quot;],
            sent_count = data[&quot;sent_count&quot;],
            summarizer_type = data[&quot;summarizer_type&quot;]
            );      
    }
}

# adding edge
edge summ_model {
    has model_type;
}

# adding graph
graph summ_graph {
    has anchor summ_model_dir;
    spawn {
        summ_model_dir = spawn node::model_dir;
        summarizer_node = spawn node::summarizer;
        summ_model_dir -[summ_model(model_type=&quot;summarizer&quot;)]-&gt; summarizer_node;
    }
}

# declaring init walker
walker init {
    root {
    spawn here --&gt; graph::summ_graph; 
    }
}

# declaring walker for summerize text
walker summarizer{
    has data=&quot;data.json&quot;;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}    
</code></pre>
</li>
</ol>
<ul>
<li>
<p><strong>Steps for running <code>summarizer.jac</code> program</strong></p>
<ul>
<li>
<p>Execute the follow command for Build <code>summarizer.jac</code></p>
<pre><code>jac build summarizer.jac
</code></pre>
</li>
<li>
<p>Execute the follow command to Activate sentinal</p>
<pre><code>sentinel set -snt active:sentinel -mode ir summarizer.jir
</code></pre>
</li>
<li>
<p>Execute the walker <code>summarizer</code> with default parameter for <code>summarizer(cl_summer)</code> module by following command</p>
<pre><code>walker run summarizer
</code></pre>
</li>
<li>
<p>After executing walker <code>summarizer</code> result data will show on console.</p>
<p><strong>Result</strong></p>
<pre><code> &quot;report&quot;: [
            [
            &quot;The King of England was at war with him and had led a great army into Scotland to drive him out of the land.&quot;,
            &quot;At last his army was scattered, and he was forced to hide in the woods and in lonely places among the mountains.&quot;,
            &quot;One rainy day, Bruce lay on the ground under a crude shed listening to the patter of the drops on the roof above him.&quot;,
            &quot;As he lay thinking, he saw a spider over his head making ready to weave her web.&quot;,
            &quot;Bruce almost forgot his own troubles as, he watched her swing herself out upon the slender line.&quot;
            ]
        ]
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summarizationt5_sum"><a class="header" href="#summarizationt5_sum"><strong>Summarization(<code>t5_sum</code>)</strong></a></h1>
<p>Module <code>t5_sum</code> uses the hugging face T5 transformer model to provide abstractive summary from text.</p>
<ol>
<li>Import <a href="support/guide/jaseci_kit/modules/summarization/t5_sum/index.html#1-import-summarizer-t5_sum-module-in-jac"><code>t5_sum</code></a> module in jac</li>
<li><a href="support/guide/jaseci_kit/modules/summarization/t5_sum/index.html#2-summarization">Summarization</a></li>
</ol>
<h1 id="walk-through-3"><a class="header" href="#walk-through-3"><strong>Walk through</strong></a></h1>
<h2 id="1-import-summarizer-t5_sum-module-in-jac"><a class="header" href="#1-import-summarizer-t5_sum-module-in-jac"><strong>1. Import Summarizer (<code>t5_sum</code>) module in jac</strong></a></h2>
<ol>
<li>For executing jaseci Open terminal and run follow command.
<pre><code>jsctl -m
</code></pre>
</li>
<li>Load cl_summer module in jac by command
<pre><code>actions load module jaseci_kit.t5_sum
</code></pre>
</li>
</ol>
<h2 id="2-summarization"><a class="header" href="#2-summarization"><strong>2. Summarization</strong></a></h2>
<p>For this tutorial, we are going to leverage the <strong>Summarizer</strong>(<code>t5_sum</code>) which would generate the summary from text. </p>
<ul>
<li>
<p>Creating Jac Program for <strong>summarizer</strong> (<code>t5_sum</code>)</p>
<ol>
<li>
<p>Create a file by name summarizer.jac</p>
</li>
<li>
<p>Create node model_dir and <code>summarizer</code> in <code>summarizer.jac</code> file.</p>
<pre><code>node model_dir;
node summarizer{};
</code></pre>
</li>
<li>
<p>import <code>t5_sum.classify_text</code> ability inside node <code>summarizer</code>.</p>
<pre><code># import ability
can t5_sum.classify_text;
</code></pre>
</li>
<li>
<p>Initialize module <code>summarize</code> inside <code>summarizer</code> node.</p>
<pre><code class="language-python"># summarizer
can summarize with summarizer entry{
    data = file.load_json(visitor.dataset);
    report t5_sum.classify_text(
        text = data[&quot;text&quot;],
        min_length = data[&quot;min_length&quot;],
        max_length = data[&quot;max_length&quot;]
        );
}
</code></pre>
<p><code>classify_text</code>: use the T5 model to summarize a body of text</p>
<p><strong>Parameter details</strong></p>
<ul>
<li>
<p><strong>Input Data</strong>  <strong><code>dataset.json</code></strong> file</p>
<pre><code>{
    &quot;text&quot;: &quot;The US has passed the peak on new coronavirus cases, President Donald Trump said and predicted that some states would reopen this month. The US has over 637,000 confirmed Covid-19 cases and over 30,826 deaths, the highest for any country in the world. At the daily White House coronavirus briefing on Wednesday, Trump said new guidelines to reopen the country would be announced on Thursday after he speaks to governors. We'll be the comeback kids, all of us, he said. We want to get our country back. The Trump administration has  previously fixed May 1 as a possible date to reopen the world's largest economy, but the president said some states may be able to return to normalcy earlier than that.&quot;,
    &quot;min_length&quot;: 30,
    &quot;max_length&quot;: 100
}
</code></pre>
<ul>
<li>
<p><code>text (string)</code>: text to summarize</p>
</li>
<li>
<p><code>min_length (integer):</code> the least amount of words you want returned from the model</p>
</li>
<li>
<p><code>max_length (integer):</code> the most amount of words you want returned from the model</p>
</li>
<li>
<p><strong>Output</strong>
List of Sentences that best summarizes the context</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adding edge name of <code>summ_model</code> in <code>summarizer.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge summ_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding graph name of <code>summ_graph</code> for initializing node.</p>
<pre><code class="language-python"># adding graph
graph summ_graph {
    has anchor summ_model_dir;
    spawn {
        summ_model_dir = spawn node::model_dir;
        summarizer_node = spawn node::summarizer;
        summ_model_dir -[summ_model(model_type=&quot;summarizer&quot;)]-&gt; summarizer_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing walker init for calling graph.</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::summ_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating walker name of <code>summarizer</code> for getting parameter from context or default and calling ability <code>summarize</code>.</p>
<pre><code class="language-python"># declaring walker for summerize text
walker summarizer{
    has dataset=&quot;dataset.json&quot;;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p><strong>Final get_seg.jac program</strong></p>
<pre><code class="language-python">node model_dir;
node summarizer{
    # import ability
    can t5_sum.classify_text;

    # summarizer
    can summarize with summarizer entry{
        data = file.load_json(visitor.dataset);
        
        report t5_sum.classify_text(
            text = data[&quot;text&quot;],
            min_length = data[&quot;min_length&quot;],
            max_length = data[&quot;max_length&quot;]
            );      
    }
}

# adding edge
edge summ_model {
    has model_type;
}

# adding graph
graph summ_graph {
    has anchor summ_model_dir;
    spawn {
        summ_model_dir = spawn node::model_dir;
        summarizer_node = spawn node::summarizer;
        summ_model_dir -[summ_model(model_type=&quot;summarizer&quot;)]-&gt; summarizer_node;
    }
}

walker init {
    root {
    spawn here --&gt; graph::summ_graph; 
    }
}

# declaring walker for summerize text
walker summarizer{
    has dataset=&quot;data.json&quot;;

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
</li>
</ol>
<ul>
<li>
<p><strong>Steps for running <code>summarizer.jac</code> program</strong></p>
<ul>
<li>
<p>Execute the follow command for Build <code>summarizer.jac</code></p>
<pre><code>jac build summarizer.jac
</code></pre>
</li>
<li>
<p>Execute the follow command to Activate sentinal</p>
<pre><code>sentinel set -snt active:sentinel -mode ir summarizer.jir
</code></pre>
</li>
<li>
<p>Execute the walker <code>summarizer</code> with default parameter for <code>summarizer(cl_summer)</code> module by following command</p>
<pre><code>walker run summarizer
</code></pre>
</li>
<li>
<p>After executing walker <code>summarizer</code> result data will show on console.</p>
<p><strong>Result</strong></p>
<pre><code>  &quot;report&quot;: [
                &quot;the president predicts some states will reopen this month. the country has over 637,000 confirmed cases and over 30,826 deaths, the highest for any country in the world. we'll be the comeback kids, all of us.&quot;
            ]
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text-processing-1"><a class="header" href="#text-processing-1">Text Processing</a></h1>
<p>Text processing comprises an array of operations, performed on text input to manipulate, transform or analyze textual content. Jaseci provides the following text processing engines:</p>
<h2 id="text-processing-models"><a class="header" href="#text-processing-models">Text Processing Models</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><a href="support/guide/jaseci_kit/modules/text_processing/text_seg/README.html"><code>text_seg</code></a></td><td>Text Segmenter</td><td>No Training required</td><td>Experimental</td><td>Topical Change Detection in Documents</td><td><a href="support/guide/jaseci_kit/modules/text_processing/text_seg/README.html">Documentation</a> <a href="https://huggingface.co/dennlinger/roberta-cls-consec">Huggingface</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="text-segmenter-text_seg"><a class="header" href="#text-segmenter-text_seg"><strong>Text Segmenter (text_seg)</strong></a></h1>
<p>Module <code>text_seg</code> implemented for the Topical Change Detection in Documents via Embeddings of Long Sequences.</p>
<ol>
<li>Import <a href="support/guide/jaseci_kit/modules/text_processing/text_seg/index.html#1-import-text_segementer-text_seg-module-in-jac"><code>text_seg</code></a> module in jac</li>
<li>Get <a href="support/guide/jaseci_kit/modules/text_processing/text_seg/index.html#2-get-segments">segments</a></li>
</ol>
<h1 id="walk-through-4"><a class="header" href="#walk-through-4"><strong>Walk through</strong></a></h1>
<h2 id="1-import-text_segementer-text_seg-module-in-jac"><a class="header" href="#1-import-text_segementer-text_seg-module-in-jac"><strong>1. Import text_segementer (<code>text_seg</code>) module in jac</strong></a></h2>
<ol>
<li>For executing jaseci Open terminal and run follow command.
<pre><code>jsctl -m
</code></pre>
</li>
<li>Load <code>text_seg</code> module in jac by command
<pre><code>actions load module jaseci_kit.text_seg
</code></pre>
</li>
</ol>
<h2 id="2-get-segments"><a class="header" href="#2-get-segments"><strong>2. Get segments</strong></a></h2>
<p>For this tutorial, we are going to leverage the <strong>text segmenter</strong> (<code>text_seg</code>) for the purpose of text segmentation, </p>
<ul>
<li>
<p>Creating Jac Program <strong>text segmenter</strong> (<code>text_seg</code>)</p>
<ol>
<li>
<p>Create a file by name <strong><code>segment.jac</code></strong></p>
</li>
<li>
<p>Create node model_dir and <code>text_seg</code> in <code>segment.jac</code> file.</p>
<pre><code>node model_dir;
node text_seg{};
</code></pre>
</li>
<li>
<p>Initializing node text_seg and import <code>text_seg.load_model</code> and <code>text_seg.get_segments</code> ability inside node <code>text_seg</code>.</p>
<pre><code># import ability
can text_seg.load_model, text_seg.get_segments;
</code></pre>
</li>
<li>
<p>Initialize module <code>load_model</code> and <code>get_segments</code> inside <code>get_seg</code> node.</p>
<pre><code class="language-python"># loading model 
can load_model with text_segment entry{
    text_seg.load_model(
        model_name = visitor.model_name
    );
}

# text segmentation
can get_segments with text_segment entry{
    data = file.load_json(visitor.data);
    
    report text_seg.get_segments(
        text = data[&quot;text&quot;],
        threshold = data[&quot;threshold&quot;]
    );      
}
</code></pre>
<p><code>load_model</code> to load the available model for text segmentation.
<code>get_segements</code>: gets different topics in the context provided, given a threshold</p>
<p><strong>Parameter details</strong></p>
<ul>
<li>Input
<ul>
<li>
<p><code>model_name(String)</code>: name of the transformer model to load, options are:</p>
<ul>
<li><code>wiki</code> : trained on wikipedia data</li>
<li><code>legal</code>: trained on legal documents</li>
</ul>
</li>
<li>
<p><strong>Input Data</strong></p>
<pre><code>{
    &quot;text&quot;: &quot;There was once a king of Scotland whose name was Robert Bruce. He needed to be both brave and wise because the times in which he lived were wild and rude. The King of England was at war with him and had led a great army into Scotland to drive him out of the land. Battle after battle had been fought. Six times Bruce had led his brave little army against his foes and six times his men had been beaten and driven into flight. At last his army was scattered, and he was forced to hide in the woods and in lonely places among the mountains. One rainy day, Bruce lay on the ground under a crude shed listening to the patter of the drops on the roof above him. He was tired and unhappy. He was ready to give up all hope. It seemed to him that there was no use for him to try to do anything more. As he lay thinking, he saw a spider over his head making ready to weave her web. He watched her as she toiled slowly and with great care. Six times she tried to throw her frail thread from one beam to another, and six times it fell short. 'Poor thing,' said Bruce: 'you, too, know what it is to fail. But the spider did not lose hope with the sixth failure. With still more care, she made ready to try for the seventh time. Bruce almost forgot his own troubles as he watched her swing herself out upon the slender line. Would she fail again? No! The thread was carried safely to the beam and fastened there.&quot;,
    &quot;threshold&quot;: 0.65
}
</code></pre>
<ul>
<li><code>text(String)</code>: text the contain the entire context </li>
<li><code>threshold(Float)</code>: range is between 0-1, make each sentence as segment if, threshold is 1.</li>
</ul>
</li>
<li>
<p><strong>Output</strong>
List of Sentences that best summarizes the context</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Adding edge name of <code>seg_model</code> in <code>segment.jac</code> file for connecting nodes inside graph.</p>
<pre><code># adding edge
edge seg_model {
    has model_type;
}
</code></pre>
</li>
<li>
<p>Adding graph name of <code>text_seg_graph</code> for initializing node.</p>
<pre><code>graph text_seg_graph {
    has anchor seg_model_dir;
    spawn {
        seg_model_dir = spawn node::model_dir;
        text_seg_node = spawn node::text_seg;
        seg_model_dir -[seg_model(model_type=&quot;text_seg&quot;)]-&gt; text_seg_node;
    }
}
</code></pre>
</li>
<li>
<p>Initializing walker init for calling graph.</p>
<pre><code>walker init {
    root {
    spawn here --&gt; graph::text_seg_graph; 
    }
}
</code></pre>
</li>
<li>
<p>Creating walker name of <code>text_segment</code> for getting parameter from context or default and calling ability <code>load_model</code> and <code>get_segments</code>.</p>
<pre><code class="language-python"># declaring walker for summerize text
walker text_segment{
    has model_name=&quot;wiki&quot;;
    has data=&quot;text.json&quot;;    

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
<p><strong>Final <code>segment.jac</code> program</strong></p>
<pre><code class="language-python">node model_dir;
node text_seg{
    # import all module ability
    can text_seg.load_model, text_seg.get_segments;

    # loading model 
    can load_model with text_segment entry{
        text_seg.load_model(
            model_name = visitor.model_name
        );
    }

    # text segmentation
    can segment with text_segment entry{
        data = file.load_json(visitor.data);
        
        report text_seg.get_segments(
            text = data[&quot;text&quot;],
            threshold = data[&quot;threshold&quot;]
        );      
    }
}



# adding edge
edge seg_model {
    has model_type;
}

# adding graph
graph text_seg_graph {
    has anchor seg_model_dir;
    spawn {
        seg_model_dir = spawn node::model_dir;
        text_seg_node = spawn node::text_seg;
        seg_model_dir -[seg_model(model_type=&quot;text_seg&quot;)]-&gt; text_seg_node;
    }
}

# declare init graph
walker init {
    root {
    spawn here --&gt; graph::text_seg_graph; 
    }
}


# declaring walker for summerize text
walker text_segment{
    has model_name=&quot;wiki&quot;;
    has data=&quot;text.json&quot;;    

    root {
        take --&gt; node::model_dir;
    }
    model_dir {
        take --&gt;;
    }
}
</code></pre>
</li>
</ol>
<ul>
<li>
<p><strong>Steps for running <code>segment.jac</code> program</strong></p>
<ul>
<li>
<p>Execute the follow command for Build <code>segment.jac</code></p>
<pre><code>jac build segment.jac
</code></pre>
</li>
<li>
<p>Execute the follow command to Activate sentinal</p>
<pre><code>sentinel set -snt active:sentinel -mode ir segment.jir
</code></pre>
<p><strong>Note</strong>: If getting error <strong><code>ValueError: badly formed hexadecimal UUID string</code></strong> execute only once</p>
<blockquote>
<p>sentinel register -set_active true -mode ir segment.jir</p>
</blockquote>
</li>
<li>
<p>Execute the walker <code>text_segment</code> with default parameter for <code>text segmentation (text_seg)</code> module by following command</p>
<pre><code>walker run text_segment
</code></pre>
<p>After executing walker <code>text_segment</code> result data will show on console.</p>
<p><strong>Result</strong></p>
<pre><code>&quot;report&quot;: [
            [
                &quot;There was once a king of Scotland whose name was Robert Bruce. He needed to be both brave and wise because the times in which he lived were wild and rude. The King of England was at war with him and had led a great army into Scotland to drive him out of the land. Battle after battle had been fought. Six times Bruce had led his brave little army against his foes and six times his men had been beaten and driven into flight. At last his army was scattered, and he was forced to hide in the woods and in lonely places among the mountains.&quot;,
                &quot;One rainy day, Bruce lay on the ground under a crude shed listening to the patter of the drops on the roof above him. He was tired and unhappy. He was ready to give up all hope. It seemed to him that there was no use for him to try to do anything more. As he lay thinking, he saw a spider over his head making ready to weave her web. He watched her as she toiled slowly and with great care. Six times she tried to throw her frail thread from one beam to another, and six times it fell short. ' Poor thing,' said Bruce: 'you, too, know what it is to fail. But the spider did not lose hope with the sixth failure. With still more care, she made ready to try for the seventh time.&quot;,
                &quot;Bruce almost forgot his own troubles as he watched her swing herself out upon the slender line. Would she fail again? No! The thread was carried safely to the beam and fastened there.&quot;
        ]
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-detection--recognition"><a class="header" href="#object-detection--recognition">Object Detection / Recognition</a></h1>
<p>Object detection or objecr recognition refers to a collection of operations for identifying objects in digital photographs or streaming video. Jaseci provides the following object detection engines for use in development:</p>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><a href="support/guide/jaseci_kit/modules/object_detection/yolov5/README.html"><code>yolov5</code></a></td><td>YoloV5</td><td>Training required</td><td>Ready</td><td>Object detection algorithm that divides images into a grid system. Each cell in the grid is responsible for detecting objects within itself.</td><td><a href="support/guide/jaseci_kit/modules/object_detection/yolo_v5/README.html">Documentation</a> <a href="https://arxiv.org/abs/2004.10934v1">Paper</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="yolov5"><a class="header" href="#yolov5">YoloV5</a></h1>
<h3 id="yolo-v5-yolov5"><a class="header" href="#yolo-v5-yolov5">Yolo V5 (<code>yolov5</code>)</a></h3>
<p>YOLOv5 <code>yolov5</code>  is a family of object detection architectures and models pretrained on the COCO dataset, and represents Ultralytics open-source research into future vision AI methods, incorporating lessons learned and best practices evolved over thousands of hours of research and development.</p>
<ul>
<li><code>load_model</code>: Allows you to load the yolov5 pytorch model.
<ul>
<li>Input: 
<ul>
<li><code>name</code> (string) (required): the name of the trained model. </li>
<li><code>confidence_threshold</code> (integer) (optional): is a number between 0 and 1 that represents the likelihood that the output of the Machine Learning model is correct and will satisfy a user's request.</li>
</ul>
</li>
<li>Return : Message whether the model was sucessfully loaded or not.</li>
<li>Note: Before loading the model (weights) need to be in a specific location at <code>object_detection/yolov5/runs/train/exp/weights</code>, with a specific file suffix/type (*.pt)</li>
</ul>
</li>
<li><code>detect</code>: Based on the image(s) provided by the user it will try to predict where an object alongside with it's label is on the each attached image(s).
<ul>
<li>Input:
<ul>
<li><code>file_list</code> (files) (required): the image files you want the model to detect objects location.</li>
<li><code>image_size</code> (integer) (optional): The inference size of the image(s) attached.</li>
<li><code>download_image</code> (boolean) (optional): Whether or not you want the image(s) to be returned to the current API.</li>
</ul>
</li>
<li>Return: The class (labels) it picked up from image, Bounding Box Coordinates (bbox) where the object was detected, confidence ( score ) and image in base64 format.</li>
</ul>
</li>
</ul>
<h3 id="how-to-create-an-image-based-on-the-image_bas64-string"><a class="header" href="#how-to-create-an-image-based-on-the-image_bas64-string">How to create an image based on the image_bas64 string</a></h3>
<p>In <code>api.py</code> there is a function called <code>base64EncodeImage</code> this is what converts the image to image arrays then into string.</p>
<pre><code>def base64EncodeImage(img):
    &quot;&quot;&quot;Takes an input image and returns a base64 encoded string representation of that image (jpg format)&quot;&quot;&quot;
    _, im_arr = cv2.imencode(&quot;.jpg&quot;, img)
    im_b64 = base64.b64encode(im_arr.tobytes()).decode(&quot;utf-8&quot;)

    return im_b64

</code></pre>
<h3 id="how-it-supports-multiple-images"><a class="header" href="#how-it-supports-multiple-images">How it supports multiple images</a></h3>
<p>For the <code>/detect</code> endpoint it accepts an array of files and the data have to be send through a multipart or formdata or else it won't work, which will be later encoded, processed and then returned to the user.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-ai-tools-1"><a class="header" href="#non-ai-tools-1">Non-AI Tools</a></h1>
<p>Here is a collection of other engines and tools that Jaseci provides, which do not classify as AI or ML in nature but are useful nonetheless:</p>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Model Name</th><th>Type</th><th>Status</th><th>Description</th><th>Resources</th></tr></thead><tbody>
<tr><td><a href="support/guide/jaseci_kit/modules/non_ai/pdf_ext/README.html"><code>pdf_ext</code></a></td><td>PDF Extractor</td><td>No Training</td><td>Ready</td><td>Topical Change Detection in Documents via Embeddings of Long Sequences.</td><td><a href="support/guide/jaseci_kit/modules/non_ai/pdf_ext/README.html">Documentation</a> <a href="https://pypdf2.readthedocs.io/en/latest/">Doc.</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="pdf-extractor-pdf_ext"><a class="header" href="#pdf-extractor-pdf_ext">PDF Extractor (<code>pdf_ext</code>)</a></h1>
<p><code>pdf_ext</code> module implemented for the Topical Change Detection in Documents via Embeddings of Long Sequences.</p>
<ul>
<li><code>extract_pdf</code>: gets different topics in the context provided, given a threshold 
<ul>
<li>Input 
<ul>
<li><code>url</code>(String): gets the pdf from URL</li>
<li><code>path</code>(Float): gets the pdf from local path</li>
<li><code>metadata</code>(Bool): to display available metadata of PDF</li>
</ul>
</li>
<li>Returns: a json with number of pages the pdf had and content</li>
</ul>
</li>
</ul>
<h4 id="example-jac-usage-3"><a class="header" href="#example-jac-usage-3">Example Jac Usage:</a></h4>
<pre><code class="language-jac">walker pdf_ext_example {
    has url = &quot;http://www.africau.edu/images/default/sample.pdf&quot;;
    has metadata = true;
    can pdf_ext.extract_pdf;

    # Getting the dat from PDF
    resp_data = pdf_ext.extract_pdf(url=url,
    metadata=metadata);
    std.out(resp_data);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="about"><a class="header" href="#about">About</a></h2>
<p>Jaseci UI kit provides a set of components and utilities that can quickly integrate with your Jac code or use in Jaseci Studio.</p>
<h2 id="guide"><a class="header" href="#guide">Guide</a></h2>
<ul>
<li><a href="jaseci_ui_kit/./components/docs/what-is-jaseci-ui-kit.html">Introduction</a></li>
<li><a href="jaseci_ui_kit/./components/docs/basic-concepts.html">Basic Concepts</a></li>
<li><a href="jaseci_ui_kit/./components/docs/built-in-actions.html">Built-in Actions</a></li>
<li><a href="jaseci_ui_kit/./components/docs/connecting-an-api.html">Connecting an API</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/">Components</a>
<ul>
<li><a href="jaseci_ui_kit/./components/docs/components/AuthForm.html">AuthForm</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Badge.html">Badge</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Breadcrumbs.html">Breadcrumbs</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Button.html">Button</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/ButtonGroup.html">ButtonGroup</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Card.html">Card</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Carousel.html">Carousel</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Checkbox.html">Checkbox</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Collapse.html">Collapse</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Checkbox.html">Checkbox</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Collapse.html">Collapse</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Column.html">Column</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Container.html">Container</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Datagrid.html">Datagrid</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/DataList.html">DataList</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/DatePicker.html">DatePicker</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Dialog.html">Dialog</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Divider.html">Divider</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Dropdown.html">Dropdown</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Hero.html">Hero</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Inputbox.html">Inputbox</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Navbar.html">Navbar</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Popover.html">Popover</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Progress.html">Progress</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Radio.html">Radio</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/RadioGroup.html">RadioGroup</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Range.html">Range</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Rating.html">Rating</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Row.html">Row</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Select.html">Select</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/SpeechInput.html">SpeechInput</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Stat.html">Stat</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Tabs.html">Tabs</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Text.html">Text</a></li>
<li><a href="jaseci_ui_kit/./components/docs/components/Textbox.html">Textbox</a></li>
</ul>
</li>
</ul>
<h2 id="developers-guide"><a class="header" href="#developers-guide">Developer's Guide</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jaseci-studio"><a class="header" href="#jaseci-studio">Jaseci Studio</a></h1>
<h2 id="create-account"><a class="header" href="#create-account">Create Account</a></h2>
<p>Register on Jaseci Studio <a href="jaseci_ui_kit/components/docs//">here</a> . Once you register you can then log in and be taken to the Home page</p>
<p><img src="jaseci_ui_kit/components/docs/../../../support/guide/assets/Studio-Home.png" alt="HomePage" /></p>
<h2 id="create-project"><a class="header" href="#create-project">Create Project</a></h2>
<p>Create you first project by selecting the create Project button on the top right.
<img src="jaseci_ui_kit/components/docs/../../../support/guide/assets/Studio-NewProject.png" alt="Create Project" /></p>
<p>Name your Project then click create.
<a href="jaseci_ui_kit/components/docs/../../../support/guide/assets/Studio-NewProject.png">pic of creation button</a></p>
<h2 id="which-tool-to-use"><a class="header" href="#which-tool-to-use">which tool to use</a></h2>
<p>You will have two choices to create your frontend : </p>
<ul>
<li>
<p>The Editor , this is where you write either the Json code to create frontend or JAC code to bring components together to create your frontend. </p>
</li>
<li>
<p>The Builder,  this is a drag and drop option to create your Frontend.It is simpler than the Editor for person without the technical experience.</p>
</li>
</ul>
<h2 id="editor"><a class="header" href="#editor">Editor</a></h2>
<p>Create you page by selecting the <code>+ New</code> button on the Editor Page. </p>
<p><img src="jaseci_ui_kit/components/docs/../../../support/guide/assets/Studio-Editor.png" alt="Editor" /></p>
<h2 id="view-or-jac"><a class="header" href="#view-or-jac">View Or JAC</a></h2>
<p>to be added</p>
<p><img src="jaseci_ui_kit/components/docs/../../../support/guide/assets/studio-View_JAC.png" alt="View or JAC" /></p>
<h3 id="view"><a class="header" href="#view">View</a></h3>
<p>Add components for your Page in the Editor. You can learn more about Components <a href="jaseci_ui_kit/components/docs/./components.html">here</a>.
The Top menu has a few butttons . In order you have the <code>Run</code> button , this runs  the JSON code , The <code>save</code> buttton which saves your work , <code>Preview View</code> , this is to open and close the Preview Section , <code>{ }</code> , these curly braces are used to beautify the JSON code and the <code>menu</code> button , this opens a drop down that contains Components , Examples which you can add and a import and Export Project.</p>
<h3 id="menu"><a class="header" href="#menu">Menu</a></h3>
<p>The Drop menu when selected gives 3 Options .They are :</p>
<ul>
<li>
<p>Components , You can various components to your editor to assist in your Frontend Developemnt.
<img src="jaseci_ui_kit/components/docs/../../../support/guide/assets/Studio-add_components.png" alt="Add Components" /></p>
</li>
<li>
<p>examples , Add finished Frontend which you can then customise. 
<img src="jaseci_ui_kit/components/docs/../../../support/guide/assets/Studio-Examples.png" alt="Examples" /></p>
</li>
<li>
<p>Import/Export , Import or Export your JSON or JAC code.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="creating-a-component"><a class="header" href="#creating-a-component">Creating a Component</a></h3>
<p>Each component in Jaseci UI Kit is rendered within a <code>jsc-app</code>. After setting up your code, and assuming your <code>jsc-app</code> component is placed somewhere in your html tree, the next step is to create the markup. We won't be using HTML to create the structure of our webpage, however, in this case, we will use our <code>jsc-app</code> component to generate the markup using JSON.</p>
<p>Creating a component is simple: at the bare minimum we need to create an object with a <em>component</em>, <em>props</em>, and <em>sections</em> properties. Here's an example of how we can render a Navbar component.</p>
<pre><code class="language-JSON">	[
		{
			&quot;component&quot;: &quot;Navbar&quot;,
			&quot;sections&quot;: {
				&quot;links&quot;: [
					{
						&quot;component&quot;: 'NavLink',
						&quot;props&quot;: {&quot;label&quot;: &quot;Home&quot;}
					}
				]
			},
			&quot;props&quot;: {
				&quot;label&quot;: &quot;Jaseci&quot;,
				&quot;background&quot;: &quot;red&quot;
			},
		}
	]
</code></pre>
<p>In the code above we asked for a Navbar component with a single link element, we set the label of our navbar to 'Jaseci' and the background to 'red'. We also asked for a link within the navbar and for it to be rendered within the <em>links</em> section.</p>
<h3 id="names"><a class="header" href="#names">Names</a></h3>
<p>Names are unique values we attach to a component that will allow us to reference it in the future to get the value of its properties.</p>
<h3 id="sections"><a class="header" href="#sections">Sections</a></h3>
<p>Sections allow us to place components within another component. It also allows us to place components at specific locations within another component. In our example above, with the navbar component, links is a section specific to the navbar component that allows us to add <em>Link</em> components within the navbar. Some components have sections and some do not, so be sure to review the available sections for each component to know when and where you can place components within another.</p>
<h3 id="events"><a class="header" href="#events">Events</a></h3>
<p>Events allow us to interact with our markup. Just like we can generate the <em>structure</em> of our webpage using <em>props</em> to control the styling and content of our components we can use <em>events</em> to add logic and functionality to make our site interactive. Let's have a look at how we can add an event to our navbar component.</p>
<p>Let's assume we want to display an alert message when a link is clicked: we can modify our link component to listen to an <em>onClick</em> event we can perform an action when we click on the link component.</p>
<p>Taking the code from our example above, let's modify it, we'll start by adding an <em>events</em> property to our link component, and within that events property, our action. Let's do it.</p>
<pre><code class="language-JSON">	[
		{
			&quot;name&quot;: &quot;nav&quot;,
			&quot;component&quot;: &quot;Navbar&quot;,
			&quot;sections&quot;: {
				&quot;links&quot;: [
					{
						&quot;component&quot;: 'NavLink',
						&quot;props&quot;: { &quot;label&quot;: 'Home' }
						&quot;events&quot;: {
							&quot;onClick&quot;: [
								{
									&quot;fn&quot;: &quot;alert&quot;,
									&quot;args&quot;: [&quot;Jaseci&quot;]
								}
							]
						}
					}
				]
			},
			&quot;props&quot;: {
				&quot;label&quot;: &quot;Jaseci&quot;
			},
		}
	]
</code></pre>
<p>After adding the code above, whenever we click on the <em>Home</em> link we are going see the message &quot;Jaseci&quot; printed in an alert dialog.</p>
<h3 id="actions"><a class="header" href="#actions">Actions</a></h3>
<p>Actions allow us to run arbitrary javascript functions and built-in functions provided by the ui kit in response to certain events. You can perform multiple actions, one after the other, or compose actions to perform an action after another completes, or fails.</p>
<p>In the example above we created an alert action in response to an <code>onClick</code> event. Let's take a closer look at what we did.</p>
<p>To create an action we need to create an object with the <code>fn</code> property and the <code>args</code> property.</p>
<ul>
<li><em>fn</em> - the name of the function we want to call</li>
<li><em>args</em> - the values we pass to the function as arguments</li>
</ul>
<p>Here what our action looked like.</p>
<pre><code class="language-JSON">&quot;onClick&quot;: [
	{
		&quot;fn&quot;: &quot;alert&quot;,
		&quot;args&quot;: [&quot;Jaseci&quot;]
	}
]
</code></pre>
<p>What if we wanted to <em>update</em> a property instead? We can changing our action function to <code>update</code> along provide its two args: the property we want to update and the value of the property.</p>
<p>Here what our action looks like now.</p>
<pre><code class="language-JSON">&quot;onClick&quot;: [
	{
		&quot;fn&quot;: &quot;update&quot;,
		&quot;args&quot;: [&quot;nav.label&quot;, &quot;Jaseci 2.0&quot;]
	}
]
</code></pre>
<p>Assuming this <code>onClick</code> event is still attached to our nav link component, whenever we click on this link the label of the navbar will change from <code>Jaseci</code> to <code>Jaseci 2.0</code>.</p>
<h4 id="action-conditions"><a class="header" href="#action-conditions">Action conditions</a></h4>
<p>Consider the following code.</p>
<pre><code class="language-JSON">&quot;onClick&quot;: [
	{
		&quot;fn&quot;: &quot;update&quot;,
		&quot;args&quot;: [&quot;nav.label&quot;, &quot;Jaseci 2.0&quot;],
		&quot;cond&quot;: ['var(nav.label)::#neq::Jaseci 2.0'],
	}
]
</code></pre>
<p>What have you noticed? It works the same as before, however, there's now a <code>cond</code> property, this property allow us to prevent the execution of some actions unless a certain condition is satisfied. Each condition is a string. In this example, if we click update and the label is not already <code>Jaseci 2.0</code> the action will run, if is <code>Jaseci 2.0</code>, it remain the same.</p>
<p>We can provide multiple conditions to an action and the action will only run if all conditions are satisfied.</p>
<h4 id="chaining-actions"><a class="header" href="#chaining-actions">Chaining Actions</a></h4>
<p>We can run until another is executed. We can do so by providing an action as the value to the <code>onCompleted</code> property of another action. Here's an example using the code above:</p>
<pre><code class="language-JSON">&quot;onClick&quot;: [
	{
		&quot;fn&quot;: &quot;update&quot;,
		&quot;args&quot;: [&quot;nav.label&quot;, &quot;Jaseci 2.0&quot;],
		&quot;cond&quot;: ['var(nav.label)::#neq::Jaseci 2.0'],
		&quot;onCompleted&quot;: {
			&quot;fn&quot;: &quot;alert&quot;,
			&quot;args&quot;: [&quot;Navbar title updated.&quot;]
		}
	}
]
</code></pre>
<p>Also consider the following code.</p>
<pre><code class="language-JSON">&quot;onClick&quot;: [
	{
		&quot;fn&quot;: &quot;update&quot;,
		&quot;args&quot;: [&quot;nav.label&quot;, &quot;Jaseci 2.0&quot;],
		&quot;cond&quot;: ['var(nav.label)::#neq::Jaseci 2.0']
	},
	{
		&quot;fn&quot;: &quot;alert&quot;,
		&quot;args&quot;: [&quot;Navbar title updated.&quot;]
	}
]
</code></pre>
<p>In the first code above, we ask for an alert dialog to display after the <code>update</code> action is finished. But what about the second code, doesn't it work the same? In this case, yes, but also no. Taking a closer lock at the <code>update</code> action of the first code, it has a <code>cond</code>, this condition will also prevent the <code>onCompleted</code> action from running if the <code>update</code> function did not run. The second code will give us an alert dialog even if the update function did not run.</p>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>Operations are &quot;custom actions&quot; that we can create that will allow us to reuse a particular sequence of actions across components. Each operation has a name and can optionally accept a number of arguments.</p>
<p>Take a look at the following example:</p>
<pre><code class="language-JSON">[
    {
        &quot;component&quot;: &quot;Container&quot;,
        &quot;name&quot;: &quot;container1&quot;,
        &quot;operations&quot;: {
            &quot;sayHi&quot;: {
                &quot;args&quot;: [
                    &quot;message&quot;
                ],
                &quot;run&quot;: [
                    {
                        &quot;fn&quot;: &quot;alert&quot;,
                        &quot;args&quot;: [
                            &quot;arg(message) cool!&quot;
                        ]
                    }
                ]
            }
        }
    },
    {
        &quot;component&quot;: &quot;Button&quot;,
        &quot;events&quot;: {
            &quot;onClick&quot;: [
                {
                    &quot;fn&quot;: &quot;runOperation&quot;,
                    &quot;operation&quot;: &quot;container1.sayHi&quot;,
                    &quot;args&quot;: [
                        &quot;Hello world!&quot;
                    ]
                }
            ]
        },
        &quot;props&quot;: {
            &quot;name&quot;: &quot;btn1&quot;,
            &quot;label&quot;: &quot;Say Hello&quot;
        }
    }
]
</code></pre>
<p>In the example above, we defined an operation within the <code>container1</code> component then we called this operation in the <code>btn1</code> component. Each operation is called using the <code>callOperation</code> action. The <code>callOperation</code> action requires the <code>operation</code> property to be defined with a valid operation as its value. An operation is referenced using the format <code>[Component Name].[Operation Name]</code> which translates to <code>container1.sayHi</code> in this case.</p>
<h4 id="operation-args"><a class="header" href="#operation-args">Operation Args</a></h4>
<p>When defining an operation we can set the <code>args</code> property to a list of strings. This can be used to accept args to your operation. Each arg can be used in the actions within an operation and will be replaced by the values passed in the args of the <code>callOperation</code> action. In the example above, <code>arg(message)</code> is replaced with 'Hello world!' and the message alerted is 'Hello world! cool'.</p>
<h3 id="property-references"><a class="header" href="#property-references">Property References</a></h3>
<p>Property references allow us to get the value of the property of a component. This allows us to move across components. For example, let's say you have an <code>Inputbox</code> component and you want to <code>alert</code> the value of the input box whenever the user presses the <code>Enter</code> button. How would we do that? Let's explore.</p>
<p>Let's start by taking a look at the following code:</p>
<pre><code class="language-JSON">[
		{
			&quot;name&quot;: &quot;inputbox1&quot;,
			&quot;component&quot;: &quot;Inputbox&quot;,
			&quot;sections&quot;: []
			&quot;events&quot;: {
				&quot;onEnter&quot;: [
					{
						fn: &quot;alert&quot;,
						args: &quot;Hello, var(inputbox1.value)!&quot;
					}
				]
			},
			&quot;props&quot;: {
				&quot;placeholder&quot;: &quot;Enter your name...&quot;
			},
		}
]
</code></pre>
<p>The above code will render an <code>Inputbox</code> component with a placeholder of <code>Enter your name...</code>. If we enter our name in the box and press the <code>Enter</code> button on the keyboard an alert dialog is shown and <code>var(inputbox1.value)</code> is replaced with the value of the input box.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-component"><a class="header" href="#update-component">Update Component</a></h1>
<p>The update action allows us to update a property of a component.</p>
<h3 id="args"><a class="header" href="#args">Args</a></h3>
<ol start="0">
<li>component property in the format <code>[component name].[property]</code></li>
<li>the new value</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>&quot;onClick&quot;: [
{
&quot;fn&quot;: &quot;update&quot;,
&quot;args&quot;: [&quot;nav.label&quot;, &quot;Jaseci 2.0&quot;],
}
]</p>
<h2 id="alert"><a class="header" href="#alert">Alert</a></h2>
<p>Runs the browser alert function.</p>
<h3 id="args-1"><a class="header" href="#args-1">Args</a></h3>
<ol start="0">
<li>alert message</li>
</ol>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-JSON">&quot;onClick&quot;: [
    {
        &quot;fn&quot;: &quot;add&quot;,
        &quot;args&quot;: [1, 3],
    }
]
</code></pre>
<h2 id="call-endpoint"><a class="header" href="#call-endpoint">Call Endpoint</a></h2>
<p>Runs the browser alert function.</p>
<h2 id="properties"><a class="header" href="#properties">Properties</a></h2>
<ul>
<li>endpoint - the api url that will be called</li>
</ul>
<h3 id="args-2"><a class="header" href="#args-2">Args</a></h3>
<ol start="0">
<li>HTTP Verb</li>
<li>Request body</li>
</ol>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-JSON">&quot;onClick&quot;: [
        {
            &quot;fn&quot;: &quot;callEndpoint&quot;,
            &quot;endpoint&quot;: &quot;http://localhost:3334/message&quot;,
            &quot;args&quot;: [
                &quot;POST&quot;,
                {
                    &quot;message&quot;: &quot;Hello!&quot;
                }
            ]
        }
]
</code></pre>
<h2 id="append"><a class="header" href="#append">Append</a></h2>
<p>Adds a component as a child of another component.</p>
<h3 id="args-3"><a class="header" href="#args-3">Args</a></h3>
<ol start="0">
<li>component name</li>
<li>component structure - the child component</li>
</ol>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-JSON">&quot;onClick&quot;: [
    {
        &quot;fn&quot;: &quot;append&quot;,
        &quot;args&quot;: [&quot;msgs&quot;,
            {
                &quot;component&quot;: &quot;Text&quot;,
                &quot;props&quot;: {
                    &quot;value&quot;: &quot;Hello&quot;
                }
            }
        ],
    }
]

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="creating-an-api-endpoint"><a class="header" href="#creating-an-api-endpoint">Creating an API Endpoint</a></h2>
<p>The webkit is able to call api endpoints, as long as the api endpoint sends back a list of supported / built-in actions.</p>
<p>For example, let's say we want to alert a message on the frontend. To do so, we'll need to ensure that the response body for the api endpoint is an array that contains an alert action.</p>
<h4 id="example-api-endpoint"><a class="header" href="#example-api-endpoint">Example API Endpoint</a></h4>
<pre><code class="language-JS">Route.post('/alert-message', async ({ request }) =&gt; {
  return [
    {
      fn: 'alert',
      args: [`Hey, how are you?`],
    },
    {
      fn: 'alert',
      args: [`How is the weather?`],
    },
  ]
})
</code></pre>
<p>From the code above, once it reaches the frontend, each action specified in the array will execute; you should see two alert messages.</p>
<h2 id="calling-the-endpoint"><a class="header" href="#calling-the-endpoint">Calling the Endpoint</a></h2>
<p>Once the api endpoint is ready, we can call it on the frontend with the <code>callEndpoint</code> action.</p>
<p>For example:</p>
<pre><code class="language-JSON">{
    &quot;component&quot;: &quot;Button&quot;,
    &quot;props&quot;: {
        &quot;label&quot;: &quot;Alert Messages&quot;
    },
    &quot;events&quot;: {
        &quot;onClick&quot;: [
            {
                &quot;fn&quot;: &quot;callEndpoint&quot;,
                &quot;endpoint&quot;: &quot;http://localhost:3334/alert-message&quot;,
                &quot;args&quot;: [
                    &quot;POST&quot;,
                    {}
                ]
            }
        ]
    }
}

</code></pre>
<p>The callEndpoint action can receive optional args, the HTTP verb and the request body.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-of-components"><a class="header" href="#list-of-components">List of Components</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th><th>Link</th></tr></thead><tbody>
<tr><td>AuthForm</td><td>---</td><td><a href="jaseci_ui_kit/components/docs/components/AuthForm.html">Detailed Description</a></td></tr>
<tr><td>Badge</td><td>---</td><td><a href="jaseci_ui_kit/components/docs/components/Badge.html">Detailed Description</a></td></tr>
<tr><td>Breadcrumbs</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Breadcrumbs.html">Detailed Description</a></td></tr>
<tr><td>Button</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Button.html">Detailed Description</a></td></tr>
<tr><td>ButtonGroup</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/ButtonGroup.html">Detailed Description</a></td></tr>
<tr><td>Card</td><td>--------</td><td><a href="jaseci_ui_kit/components/docs/components/Card.html">Detailed Description</a></td></tr>
<tr><td>Carousel</td><td>--------</td><td><a href="jaseci_ui_kit/components/docs/components/Carousel.html">Detailed Description</a></td></tr>
<tr><td>Checkbox</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Checkbox.html">Detailed Description</a></td></tr>
<tr><td>Collapse</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Collapse.html">Detailed Description</a></td></tr>
<tr><td>Column</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Column.html">Detailed Description</a></td></tr>
<tr><td>Container</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Container.html">Detailed Description</a></td></tr>
<tr><td>Datagrid</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Datagrid.html">Detailed Description</a></td></tr>
<tr><td>Data list</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/DataList.html">Detailed Description</a></td></tr>
<tr><td>Date Picker</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/DatePicker.html">Detailed Desciption</a></td></tr>
<tr><td>Dialog</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Dialog.html">Detailed Description</a></td></tr>
<tr><td>Divider</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Divider.html">Detailed Description</a></td></tr>
<tr><td>Dropdown</td><td>--------</td><td><a href="jaseci_ui_kit/components/docs/components/Dropdown.html">Detailed Description</a></td></tr>
<tr><td>Hero</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Hero.html">Detailed Description</a></td></tr>
<tr><td>Inputbox</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Inputbox.html">Detailed Description</a></td></tr>
<tr><td>Navbar</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Navbar.html">Detailed Description</a></td></tr>
<tr><td>Popover</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Popover.html">Detailed Description</a></td></tr>
<tr><td>Progress</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Progress.html">Detailed Description</a></td></tr>
<tr><td>Radio</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Radio.html">Detailed Description</a></td></tr>
<tr><td>Radio Group</td><td>----</td><td><a href="jaseci_ui_kit/components/docs/components/RadioGroup.html">Detailed Description</a></td></tr>
<tr><td>Range</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Range.html">Detailed Description</a></td></tr>
<tr><td>Rating</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/Rating.html">Detailed Description</a></td></tr>
<tr><td>Row</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Row.html">Detailed Description</a></td></tr>
<tr><td>Select</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Select.html">Detailed Description</a></td></tr>
<tr><td>Speech Input</td><td>-------</td><td><a href="jaseci_ui_kit/components/docs/components/SpeechInput.html">Detailed Description</a></td></tr>
<tr><td>Stat</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Stat.html">Detailed Description</a></td></tr>
<tr><td>Tabs</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Tabs.html">Detailed Description</a></td></tr>
<tr><td>Text</td><td>-----</td><td><a href="jaseci_ui_kit/components/docs/components/Text.html">Detailed Description</a></td></tr>
<tr><td>Textbox</td><td>------</td><td><a href="jaseci_ui_kit/components/docs/components/Textbox.html">Detailed Description</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-auth-form"><a class="header" href="#title-auth-form">title: Auth Form</a></h2>
<h4 id="summary"><a class="header" href="#summary">Summary</a></h4>
<p>Quickly add user login and sign up to your jaseci site</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
      &quot;component&quot;: &quot;AuthForm&quot;,
      &quot;props&quot;: {
        &quot;mode&quot;: &quot;login&quot;,
        &quot;serverURL&quot;: &quot;http://localhost:8000&quot;,
        &quot;tokenKey&quot;: &quot;tokenKey&quot;,
        &quot;hideNameField&quot;: true
      }
}
</code></pre>
<h3 id="props"><a class="header" href="#props">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>mode</td><td>&quot;login&quot; or &quot;signup&quot;</td><td>Determines which form to display</td></tr>
<tr><td>serverURL</td><td>string</td><td>Jaseci Server URL</td></tr>
<tr><td>tokenKey</td><td>tokenKey</td><td>Location used to store the token in localstorage</td></tr>
<tr><td>hideNameField</td><td>boolean</td><td>Opt-in/out of collecting the user's name when they sign up</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-badge"><a class="header" href="#title-badge">title: Badge</a></h2>
<h4 id="summary-1"><a class="header" href="#summary-1">Summary</a></h4>
<p>Simple badge/chip component</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
      &quot;component&quot;: &quot;Badge&quot;,
      &quot;props&quot;: {
        &quot;name&quot;: &quot;badge1&quot;,
        &quot;label&quot;: &quot;Project&quot;,
        &quot;size&quot;: &quot;md&quot;,
        &quot;palette&quot;: &quot;primary&quot;
      }
}
</code></pre>
<h3 id="props-1"><a class="header" href="#props-1">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>label</td><td><code>string</code></td><td></td></tr>
<tr><td>palette</td><td><code>info</code> or <code>warning</code> or <code>primary</code> or <code>secondary</code> or <code>success</code> or <code>accent</code> or <code>ghost</code></td><td></td></tr>
<tr><td>size</td><td><code>xs</code> or <code>sm</code> or <code>md</code> or <code>lg</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-breadcrumbs"><a class="header" href="#title-breadcrumbs">title: Breadcrumbs</a></h2>
<h4 id="summary-2"><a class="header" href="#summary-2">Summary</a></h4>
<p>Renders a breadcrumbs navigation component</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">
    {
          &quot;component&quot;: &quot;Breadcrumbs&quot;,
          &quot;props&quot;: {
            &quot;links&quot;: [
              {
                &quot;label&quot;: &quot;Apple&quot;,
                &quot;href&quot;: &quot;http://google.com&quot;
              },
              {
                &quot;label&quot;: &quot;Oranges&quot;,
                &quot;href&quot;: &quot;http://example.com&quot;
              },
              {
                &quot;label&quot;: &quot;Cashews&quot;
              }
            ]
          }
    }

</code></pre>
<h3 id="props-2"><a class="header" href="#props-2">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>links</td><td><code>Array&lt;{label: string, href: string}&gt;</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-button"><a class="header" href="#title-button">title: Button</a></h2>
<h4 id="summary-3"><a class="header" href="#summary-3">Summary</a></h4>
<p>A <code>Button</code> will render a <code>jsc-button</code>. Under the hood, this <code>jsc-button</code> tag will render a <code>html</code> button element within it's shadow DOM.</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
	&quot;component&quot;: &quot;Button&quot;,
	&quot;events&quot;: {},
	&quot;props&quot;: {
		&quot;label&quot;: &quot;Click me&quot;,
        &quot;palette&quot;: &quot;primary&quot;
	},
	&quot;css&quot;: {
		&quot;background&quot;: &quot;red&quot;
	}
}


</code></pre>
<p>The above code will render a button with a red background and a label of &quot;Click me&quot;.</p>
<h3 id="props-3"><a class="header" href="#props-3">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>label</td><td><code>string</code></td><td></td></tr>
<tr><td>variant</td><td><code>default</code> or <code>link</code></td><td></td></tr>
<tr><td>size</td><td><code>sm</code> or <code>md</code> or <code>lg</code> or <code>xs</code></td><td></td></tr>
<tr><td>palette</td><td><code>primary</code> or <code>secondary</code> or <code>accent</code> or <code>info</code> or <code>warning</code> or <code>error</code> or <code>success</code> or <code>accent</code> or <code>ghost</code></td><td></td></tr>
<tr><td>fullWidth</td><td><code>boolean</code></td><td></td></tr>
<tr><td>active</td><td><code>boolean</code></td><td></td></tr>
<tr><td>noRadius</td><td><code>boolean</code></td><td></td></tr>
<tr><td>tooltip</td><td><code>string</code></td><td></td></tr>
<tr><td>tooltipPosition</td><td><code>bottom</code> or <code>left</code> or <code>right</code></td><td></td></tr>
<tr><td>tooltipPalette</td><td><code>primary</code> or <code>secondary</code> or <code>accent</code> or <code>info</code> or <code>warning</code> or <code>error</code> or <code>success</code> or <code>accent</code> or <code>ghost</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-buttongroup"><a class="header" href="#title-buttongroup">title: ButtonGroup</a></h2>
<h4 id="summary-4"><a class="header" href="#summary-4">Summary</a></h4>
<p>Renders a group of buttons</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
                  &quot;component&quot;: &quot;ButtonGroup&quot;,
                  &quot;props&quot;: {
                    &quot;buttons&quot;: [
                      {
                        &quot;label&quot;: &quot;Page 1&quot;,
                        &quot;href&quot;: &quot;http://google.com&quot;
                      },
                      {
                        &quot;label&quot;: &quot;Page 2&quot;,
                        &quot;href&quot;: &quot;http://google.com&quot;,
                        &quot;active&quot;: &quot;true&quot;
                      },
                      {
                        &quot;label&quot;: &quot;Page 3&quot;,
                        &quot;href&quot;: &quot;http://google.com&quot;
                      }
                    ]
                  }
                }
</code></pre>
<h3 id="props-4"><a class="header" href="#props-4">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>buttons</td><td><code>Array&lt;{label: string, href: string, active?: boolean}&gt;</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-card"><a class="header" href="#title-card">title: Card</a></h2>
<h4 id="summary-5"><a class="header" href="#summary-5">Summary</a></h4>
<p>General purpose card component</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
  &quot;component&quot;: &quot;Card&quot;,
  &quot;props&quot;: {
    &quot;variant&quot;: &quot;outline&quot;,
    &quot;shadow&quot;: &quot;md&quot;,
    &quot;outlineColor&quot;: &quot;red&quot;,
    &quot;radius&quot;: &quot;lg&quot;
  },
  &quot;css&quot;: {
    &quot;padding&quot;: &quot;20px 20px&quot;
  },
  &quot;sections&quot;: {
    &quot;children&quot;: []
  }
}
</code></pre>
<h3 id="props-5"><a class="header" href="#props-5">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>variant</td><td><code>outline</code> or <code>shadow</code></td><td></td></tr>
<tr><td>shadow</td><td><code>sm</code> or <code>md</code> or <code>lg</code> or <code>xl</code></td><td></td></tr>
<tr><td>radius</td><td><code>sm</code> or <code>md</code> or <code>lg</code> or <code>full</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-carousel"><a class="header" href="#title-carousel">title: Carousel</a></h2>
<h4 id="summary-6"><a class="header" href="#summary-6">Summary</a></h4>
<p>Create an image slideshow</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
  &quot;component&quot;: &quot;Carousel&quot;,
  &quot;props&quot;: {
    &quot;images&quot;: [
      {
        &quot;src&quot;: &quot;http://example.com/image.png&quot;
      }
    ]
  }
}
</code></pre>
<h3 id="props-6"><a class="header" href="#props-6">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>images</td><td><code>Array&lt;{src: string}&gt;</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-checkbox"><a class="header" href="#title-checkbox">title: Checkbox</a></h2>
<h4 id="summary-7"><a class="header" href="#summary-7">Summary</a></h4>
<p>Capture boolean input</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">
{
  &quot;name&quot;: &quot;checkbox1&quot;,
  &quot;component&quot;: &quot;Checkbox&quot;,
  &quot;props&quot;: {
    &quot;label&quot;: &quot;Correct?&quot;,
    &quot;palette&quot;: &quot;{{config:fieldPalette}}&quot;,
    &quot;size&quot;: &quot;xs&quot;
  }
}
</code></pre>
<h3 id="props-7"><a class="header" href="#props-7">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>label</td><td><code>string</code></td><td></td></tr>
<tr><td>size</td><td><code>xs</code> or <code>sm</code> or <code>md</code> or <code>lg</code></td><td></td></tr>
<tr><td>palette</td><td><code>primary</code> or <code>secondary</code> or <code>accent</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-checkbox-1"><a class="header" href="#title-checkbox-1">title: Checkbox</a></h2>
<h4 id="summary-8"><a class="header" href="#summary-8">Summary</a></h4>
<p>Separate content into collapsable sections</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">    {
            &quot;component&quot;: &quot;Collapse&quot;,
            &quot;props&quot;: {
              &quot;label&quot;: &quot;How do I use Jaseci?&quot;,
              &quot;palette&quot;: &quot;primary&quot;,
              &quot;defaultValue&quot;: &quot;80&quot;
            },
            &quot;sections&quot;: {
              &quot;children&quot;: [
                { &quot;component&quot;: &quot;Text&quot;, &quot;props&quot;: { &quot;value&quot;: &quot;Visit the site to learn more: &quot; } },
                {
                  &quot;component&quot;: &quot;Anchor&quot;,
                  &quot;props&quot;: {
                    &quot;label&quot;: &quot;Click Here&quot;,
                    &quot;palette&quot;: &quot;primary&quot;,
                    &quot;href&quot;: &quot;https://docs.jaseci.org/&quot;
                  }
                }
              ]
            }
      }
</code></pre>
<h3 id="props-8"><a class="header" href="#props-8">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>label</td><td><code>string</code></td><td></td></tr>
<tr><td>palette</td><td><code>primary</code> or <code>secondary</code> or <code>accent</code></td><td></td></tr>
<tr><td>icon</td><td><code>plus</code> or <code>arrow</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="sections-1"><a class="header" href="#sections-1">Sections</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>children</td><td>Hidden content when the component is in a collapsed state</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-checkbox-2"><a class="header" href="#title-checkbox-2">title: Checkbox</a></h2>
<h4 id="summary-9"><a class="header" href="#summary-9">Summary</a></h4>
<p>Capture boolean input</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">
{
  &quot;name&quot;: &quot;checkbox1&quot;,
  &quot;component&quot;: &quot;Checkbox&quot;,
  &quot;props&quot;: {
    &quot;label&quot;: &quot;Correct?&quot;,
    &quot;palette&quot;: &quot;{{config:fieldPalette}}&quot;,
    &quot;size&quot;: &quot;xs&quot;
  }
}
</code></pre>
<h3 id="props-9"><a class="header" href="#props-9">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>label</td><td><code>string</code></td><td></td></tr>
<tr><td>size</td><td><code>xs</code> or <code>sm</code> or <code>md</code> or <code>lg</code></td><td></td></tr>
<tr><td>palette</td><td><code>primary</code> or <code>secondary</code> or <code>accent</code></td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-checkbox-3"><a class="header" href="#title-checkbox-3">title: Checkbox</a></h2>
<h4 id="summary-10"><a class="header" href="#summary-10">Summary</a></h4>
<p>Separate content into collapsable sections</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">    {
            &quot;component&quot;: &quot;Collapse&quot;,
            &quot;props&quot;: {
              &quot;label&quot;: &quot;How do I use Jaseci?&quot;,
              &quot;palette&quot;: &quot;primary&quot;,
              &quot;defaultValue&quot;: &quot;80&quot;
            },
            &quot;sections&quot;: {
              &quot;children&quot;: [
                { &quot;component&quot;: &quot;Text&quot;, &quot;props&quot;: { &quot;value&quot;: &quot;Visit the site to learn more: &quot; } },
                {
                  &quot;component&quot;: &quot;Anchor&quot;,
                  &quot;props&quot;: {
                    &quot;label&quot;: &quot;Click Here&quot;,
                    &quot;palette&quot;: &quot;primary&quot;,
                    &quot;href&quot;: &quot;https://docs.jaseci.org/&quot;
                  }
                }
              ]
            }
      }
</code></pre>
<h3 id="props-10"><a class="header" href="#props-10">Props</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>label</td><td><code>string</code></td><td></td></tr>
<tr><td>palette</td><td><code>primary</code> or <code>secondary</code> or <code>accent</code></td><td></td></tr>
<tr><td>icon</td><td><code>plus</code> or <code>arrow</code></td><td></td></tr>
</tbody></table>
</div>
<h3 id="sections-2"><a class="header" href="#sections-2">Sections</a></h3>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>description</th></tr></thead><tbody>
<tr><td>children</td><td>Hidden content when the component is in a collapsed state</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-jaseci-column"><a class="header" href="#title-jaseci-column">title: Jaseci Column</a></h2>
<h4 id="summary-11"><a class="header" href="#summary-11">Summary</a></h4>
<p>A <code>Column</code> is a layout component that allows you to align <code>children</code> components vertically. A column is rendered as a flexbox container.</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
	&quot;component&quot;: &quot;Column&quot;,
	&quot;events&quot;: {},
	&quot;sections&quot;: {
		&quot;children&quot;: []
	},
	&quot;props&quot;: {
		&quot;justify&quot;: &quot;center&quot;,
		&quot;items&quot;: &quot;start&quot;
	}
}
</code></pre>
<p>The above will align the children elements in a column that's aligned to the left of the x-axis and center-aligned on the y-axis.</p>
<h4 id="sections-3"><a class="header" href="#sections-3">Sections</a></h4>
<ul>
<li>children</li>
</ul>
<h4 id="props-11"><a class="header" href="#props-11">Props</a></h4>
<div class="table-wrapper"><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody>
<tr><td>justify</td><td><code>start</code> or <code>end</code> or <code>center</code> or <code>around</code> or <code>evenly</code></td><td>positions children along the y-axis</td></tr>
<tr><td>items</td><td><code>start</code> or <code>end</code> or <code>center</code></td><td>positions children along the x-axis</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><hr />
<h2 id="title-container"><a class="header" href="#title-container">title: Container</a></h2>
<h4 id="summary-12"><a class="header" href="#summary-12">Summary</a></h4>
<p>A <code>Container</code> is a general-purpose component, analogous to a <code>div</code> element, that will render a <code>div</code> you can style and attach events to.</p>
<p><u>Example:</u></p>
<pre><code class="language-JSON">{
	&quot;component&quot;: &quot;Container&quot;,
	&quot;css&quot;: {
        &quot;width&quot;: &quot;200px&quot;,
        &quot;height&quot;: &quot;200px&quot;,
	}
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
