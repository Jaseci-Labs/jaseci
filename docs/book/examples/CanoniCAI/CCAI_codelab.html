<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CanoniCAI Example - Jaseci Documentation</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Jaseci Official Documentation</li><li class="chapter-item expanded "><a href="../../LICENSE.html"><strong aria-hidden="true">1.</strong> License</a></li><li class="chapter-item expanded "><a href="../../CHANGELOG.html"><strong aria-hidden="true">2.</strong> About this Release</a></li><li class="chapter-item expanded "><a href="../../CONTRIBUTING.html"><strong aria-hidden="true">3.</strong> How to Contribute</a></li><li class="chapter-item expanded "><a href="../../CONTRIBUTORS.html"><strong aria-hidden="true">4.</strong> Contributors</a></li><li class="chapter-item expanded affix "><li class="part-title">Getting Started</li><li class="chapter-item expanded "><a href="../../support/guide/getting_started/introduction.html"><strong aria-hidden="true">5.</strong> Introducing Jaseci</a></li><li class="chapter-item expanded "><a href="../../support/guide/getting_started/installation.html"><strong aria-hidden="true">6.</strong> Installing Jaseci</a></li><li class="chapter-item expanded "><a href="../../support/guide/getting_started/setting_up_your_editor.html"><strong aria-hidden="true">7.</strong> Setting Up Your Editor</a></li><li class="chapter-item expanded "><a href="../../support/guide/getting_started/writing_your_first_app.html"><strong aria-hidden="true">8.</strong> Writing Your First App</a></li><li class="chapter-item expanded "><a href="../../support/guide/getting_started/understanding_jac_programs.html"><strong aria-hidden="true">9.</strong> Understanding JAC Programs</a></li><li class="chapter-item expanded affix "><li class="part-title">The JAC Programming Language Guide</li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/jac_language_overview.html"><strong aria-hidden="true">10.</strong> Language Overview</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/jac_grammar.html"><strong aria-hidden="true">11.</strong> Grammar</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/operators.html"><strong aria-hidden="true">12.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/control_flow.html"><strong aria-hidden="true">13.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/collections.html"><strong aria-hidden="true">14.</strong> Collections</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/nodes.html"><strong aria-hidden="true">15.</strong> Nodes</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/edges.html"><strong aria-hidden="true">16.</strong> Edges</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/graphs.html"><strong aria-hidden="true">17.</strong> Graphs</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/walkers.html"><strong aria-hidden="true">18.</strong> Walkers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/traversing_a_graph.html"><strong aria-hidden="true">18.1.</strong> Traversing a Graph</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/referencing_node_context.html"><strong aria-hidden="true">18.2.</strong> Referencing a Node in Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/passing_arguments.html"><strong aria-hidden="true">19.</strong> Passing Arguments</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/specifying_operating_context.html"><strong aria-hidden="true">20.</strong> Specifying Operating Context</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/actions.html"><strong aria-hidden="true">21.</strong> Actions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/date_actions.html"><strong aria-hidden="true">21.1.</strong> Date Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/file_actions.html"><strong aria-hidden="true">21.2.</strong> File Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/net_actions.html"><strong aria-hidden="true">21.3.</strong> Net Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/rand_actions.html"><strong aria-hidden="true">21.4.</strong> Rand Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/request_actions.html"><strong aria-hidden="true">21.5.</strong> Request Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/standard_actions.html"><strong aria-hidden="true">21.6.</strong> Standard Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/vector_actions.html"><strong aria-hidden="true">21.7.</strong> Vector Actions</a></li><li class="chapter-item expanded "><a href="../../support/guide/jac_language_guide/jaseci_actions.html"><strong aria-hidden="true">21.8.</strong> Jaseci Actions</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Examples and Tutorials</li><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter1.html"><strong aria-hidden="true">22.</strong> Building a Conversational AI System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter2.html"><strong aria-hidden="true">22.1.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter3.html"><strong aria-hidden="true">22.2.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter4.html"><strong aria-hidden="true">22.3.</strong> Chapter 4</a></li><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter5.html"><strong aria-hidden="true">22.4.</strong> Chapter 5</a></li><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter6.html"><strong aria-hidden="true">22.5.</strong> Chapter 6</a></li><li class="chapter-item expanded "><a href="../../support/codelabs/canonicai/chapter7.html"><strong aria-hidden="true">22.6.</strong> Chapter 7</a></li></ol></li><li class="chapter-item expanded "><a href="../../examples/CanoniCAI/CCAI_codelab.html" class="active"><strong aria-hidden="true">23.</strong> CanoniCAI Example</a></li><li class="chapter-item expanded "><a href="../../examples/ner_examples/index.html"><strong aria-hidden="true">24.</strong> NER Examples</a></li><li class="chapter-item expanded affix "><li class="part-title">Jaseci Library Reference</li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/index.html"><strong aria-hidden="true">25.</strong> Jaseci Kit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/encoders/index.html"><strong aria-hidden="true">25.1.</strong> Encoders</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/encoders/use_enc/index.html"><strong aria-hidden="true">25.1.1.</strong> USE Encoder</a></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/encoders/use_qa/index.html"><strong aria-hidden="true">25.1.2.</strong> USE QA</a></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/encoders/fast_enc/index.html"><strong aria-hidden="true">25.1.3.</strong> FastText</a></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/encoders/bi_enc/index.html"><strong aria-hidden="true">25.1.4.</strong> Bi-Encoder</a></li></ol></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/entity_utils/index.html"><strong aria-hidden="true">25.2.</strong> Entity Recognition</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/entity_utils/flair_ner/index.html"><strong aria-hidden="true">25.2.1.</strong> FLair NER</a></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/entity_utils/tfm_ner/index.html"><strong aria-hidden="true">25.2.2.</strong> Transformer NER</a></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/entity_utils/lstm_ner/index.html"><strong aria-hidden="true">25.2.3.</strong> LSTM NER</a></li></ol></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/summarization/index.html"><strong aria-hidden="true">25.3.</strong> Text Summarization</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/summarization/cl_summer/index.html"><strong aria-hidden="true">25.3.1.</strong> CL Summarization</a></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/summarization/t5_sum/index.html"><strong aria-hidden="true">25.3.2.</strong> T5 Summarization</a></li></ol></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/text_processing/index.html"><strong aria-hidden="true">25.4.</strong> Text Processing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/text_processing/text_seg/index.html"><strong aria-hidden="true">25.4.1.</strong> Text Segmenter</a></li></ol></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/object_detection/index.html"><strong aria-hidden="true">25.5.</strong> Object Detection</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/object_detection/yolo_v5/index.html"><strong aria-hidden="true">25.5.1.</strong> YOLO V5</a></li></ol></li><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/non_ai/index.html"><strong aria-hidden="true">25.6.</strong> Non-AI Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../support/guide/jaseci_kit/modules/non_ai/pdf_ext/index.html"><strong aria-hidden="true">25.6.1.</strong> PDF Extractor</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Jaseci Studio</li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/index.html"><strong aria-hidden="true">26.</strong> Jaseci UI Kit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/gettingStarted.html"><strong aria-hidden="true">26.1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/basic-concepts.html"><strong aria-hidden="true">26.2.</strong> Basic Concepts</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/built-in-actions.html"><strong aria-hidden="true">26.3.</strong> Built-in Actions</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/connecting-an-api.html"><strong aria-hidden="true">26.4.</strong> Connecting an API</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/list_of_componets.html"><strong aria-hidden="true">26.5.</strong> List of Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/AuthForm.html"><strong aria-hidden="true">26.5.1.</strong> AuthForm</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Badge.html"><strong aria-hidden="true">26.5.2.</strong> Badge</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Breadcrumbs.html"><strong aria-hidden="true">26.5.3.</strong> Breadcrumbs</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Button.html"><strong aria-hidden="true">26.5.4.</strong> Button</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/ButtonGroup.html"><strong aria-hidden="true">26.5.5.</strong> ButtonGroup</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Card.html"><strong aria-hidden="true">26.5.6.</strong> Card</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Carousel.html"><strong aria-hidden="true">26.5.7.</strong> Carousel</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Checkbox.html"><strong aria-hidden="true">26.5.8.</strong> Checkbox</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Collapse.html"><strong aria-hidden="true">26.5.9.</strong> Collapse</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Checkbox.html"><strong aria-hidden="true">26.5.10.</strong> Checkbox</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Collapse.html"><strong aria-hidden="true">26.5.11.</strong> Collapse</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Column.html"><strong aria-hidden="true">26.5.12.</strong> Column</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Container.html"><strong aria-hidden="true">26.5.13.</strong> Container</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/DataGrid.html"><strong aria-hidden="true">26.5.14.</strong> Datagrid</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/DataList.html"><strong aria-hidden="true">26.5.15.</strong> DataList</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/DatePicker.html"><strong aria-hidden="true">26.5.16.</strong> DatePicker</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Dialog.html"><strong aria-hidden="true">26.5.17.</strong> Dialog</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Divider.html"><strong aria-hidden="true">26.5.18.</strong> Divider</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Dropdown.html"><strong aria-hidden="true">26.5.19.</strong> Dropdown</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Hero.html"><strong aria-hidden="true">26.5.20.</strong> Hero</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Inputbox.html"><strong aria-hidden="true">26.5.21.</strong> Inputbox</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Navbar.html"><strong aria-hidden="true">26.5.22.</strong> Navbar</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Popover.html"><strong aria-hidden="true">26.5.23.</strong> Popover</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Progress.html"><strong aria-hidden="true">26.5.24.</strong> Progress</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Radio.html"><strong aria-hidden="true">26.5.25.</strong> Radio</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/RadioGroup.html"><strong aria-hidden="true">26.5.26.</strong> RadioGroup</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Range.html"><strong aria-hidden="true">26.5.27.</strong> Range</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Rating.html"><strong aria-hidden="true">26.5.28.</strong> Rating</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Row.html"><strong aria-hidden="true">26.5.29.</strong> Row</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Select.html"><strong aria-hidden="true">26.5.30.</strong> Select</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/SpeechInput.html"><strong aria-hidden="true">26.5.31.</strong> SpeechInput</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Stat.html"><strong aria-hidden="true">26.5.32.</strong> Stat</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Tabs.html"><strong aria-hidden="true">26.5.33.</strong> Tabs</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Text.html"><strong aria-hidden="true">26.5.34.</strong> Text</a></li><li class="chapter-item expanded "><a href="../../jaseci_ui_kit/components/docs/components/Textbox.html"><strong aria-hidden="true">26.5.35.</strong> Textbox</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Jaseci Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="build-a-conversational-ai-system-with-jaseci"><a class="header" href="#build-a-conversational-ai-system-with-jaseci">Build a Conversational AI System with Jaseci</a></h1>
<p>In this tutorial, you are going to learn how to build a state-of-the-art conversational AI system with Jaseci and the Jac language.
You will learn the basics of Jaseci, training state-of-the-art AI models, and everything in between, in order to create an end-to-end fully-functional conversational AI system.</p>
<p>Excited? Hell yeah! Let's jump in.</p>
<h2 id="preparation"><a class="header" href="#preparation">Preparation</a></h2>
<p>To install jaseci, run this in your development environment:</p>
<pre><code>pip install jaseci
</code></pre>
<p>To test the installation is successful, run:</p>
<pre><code>jsctl --help
</code></pre>
<p><code>jacctl</code> stands for the Jaseci Command Line Interface.
If the command above displays the help menu for <code>jacctl</code>, then you have successfully installed jaseci.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Take a look and get familiarized with these commands while you are at it. <code>jacctl</code> will be frequently used throughout this journey.</p>
</blockquote>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>A few essential concepts to get familiar with.</p>
<h3 id="graph-nodes-edges"><a class="header" href="#graph-nodes-edges">Graph, nodes, edges</a></h3>
<p>Refer to relevant sections of the Jaseci Bible.</p>
<h3 id="walker"><a class="header" href="#walker">Walker</a></h3>
<p>Refer to relevant sections of the Jaseci Bible.</p>
<h1 id="automated-faq-answering-chatbot"><a class="header" href="#automated-faq-answering-chatbot">Automated FAQ answering chatbot</a></h1>
<p>Our conversational AI system will consist of multiple components.
To start, we are going to build a chatbot that can answer FAQ questions without any custom training, using zeroshot NLP models.
At the end of this section, you will have a chatbot that, when given a question, searches in its knowledge base for the most relevant answer and returns that answer.</p>
<p>The use case here is a Tesla FAQ chatbot.
We will be using the list of FAQs from https://www.tesla.com/en_SG/support/faq.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This architecture works for any FAQ topics and use cases. Feel free to pick another product/website/company's FAQ if you'd like!</p>
</blockquote>
<h2 id="define-the-nodes"><a class="header" href="#define-the-nodes">Define the Nodes</a></h2>
<p>We have 3 different types of nodes:</p>
<ul>
<li><code>root</code>: This is the root node of the graph. It is a built-in node type and each graph has one root node only.</li>
<li><code>faq_root</code>: This is the entry point of the FAQ handler. We will make the decision on the most relevant answer at this node.</li>
<li><code>faq_state</code>: This node represents a FAQ entry. It contains a candidate answer from the knowledge base.</li>
</ul>
<p>Now let's define the custom node types.</p>
<pre><code class="language-jac">node faq_root;
node faq_state {
    has question;
    has answer;
}
</code></pre>
<p>The <code>has</code> keyword defines a node's variables. In this case, each <code>faq_state</code> has a <code>question</code> and <code>answer</code>.</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>The <code>root</code> node does not need explicit definition. It is a built-in node type. Avoid using <code>root</code> as a custom node type.</p>
</blockquote>
<h2 id="build-the-graph"><a class="header" href="#build-the-graph">Build the Graph</a></h2>
<p>For this FAQ chatbot, we will build a graph as illustrated here:</p>
<p><img src="images/faq_1.png" alt="Architecture of FAQ Bot" /></p>
<p>The idea here is that we will decide which FAQ entry is the most relevant to the incoming question at the <code>faq_root</code> node and then we will traverse to that node to fetch the corresponding answer.</p>
<p>To define this graph architecture:</p>
<pre><code class="language-jac">// Static graph definition
graph faq {
    has anchor faq_root;
    spawn {
        // Spawning the nodes
        faq_root = spawn node::faq_root;
        faq_answer_1 = spawn node::faq_state(
            question=&quot;How do I configure my order?&quot;,
            answer=&quot;To configure your order, log into your Tesla account.&quot;
        );
        faq_answer_2 = spawn node::faq_state(
            question=&quot;How do I order a tesla&quot;,
            answer=&quot;Visit our design studio to place your order.&quot;
        );
        faq_answer_3 = spawn node::faq_state(
            question=&quot;Can I request a test drive&quot;,
            answer=&quot;Yes. You must be a minimum of 25 years of age.&quot;
        );

        // Connecting the nodes together
        faq_root --&gt; faq_answer_1;
        faq_root --&gt; faq_answer_2;
        faq_root --&gt; faq_answer_3;
    }
}
</code></pre>
<p>Let's break down this piece of code.</p>
<p>We observe two uses of the <code>spawn</code> keyword. To spawn a node of a specific type, use the <code>spawn</code> keyword for:</p>
<pre><code class="language-jac">faq_answer_1 = spawn node::faq_state(
    question=&quot;How do I configure my order?&quot;,
    answer=&quot;To configure your order, log into your Tesla account.&quot;,
);
</code></pre>
<p>In the above example, we just spawned a <code>faq_state</code> node called <code>faq_answer_1</code> and initialized its <code>question</code> and <code>answer</code> variables.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>The <code>spawn</code> keyword can be used in this style to spawn many different jaseci objects, such as nodes, graphs and walkers.</p>
</blockquote>
<p>The second usage of <code>spawn</code> is with the graph:</p>
<pre><code class="language-jac">graph faq {
    has anchor faq_root;
    spawn {
       ...
    }
}
</code></pre>
<p>In this context, the <code>spawn</code> designates a code block with programmatic functionality to spawn a subgraph for which the root node of that spawned graph will be the <code>has anchor faq_root</code>.</p>
<p>In this block:</p>
<ul>
<li>We spawn 4 nodes, one of the type <code>faq_root</code> and three of the type <code>faq_state</code>.</li>
<li>We connect each of the faq answer states to the faq root with <code>faq_root --&gt; faq_answer_*</code>.</li>
<li>We set the <code>faq_root</code> as the anchor node of the graph. As we will later see, spawning a graph will return its anchor node.</li>
</ul>
<blockquote>
<p><strong>Warning</strong></p>
<p>An anchor node is required for every graph block. It must be assigned inside the spawn block of the graph definition.</p>
</blockquote>
<h2 id="initialize-the-graph"><a class="header" href="#initialize-the-graph">Initialize the Graph</a></h2>
<p>Similar to nodes, in order to create the graph, we will use the <code>spawn</code> keyword.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::faq;
    }
}
</code></pre>
<p>This is the first walker we have introduced, so let's break it down.</p>
<ul>
<li>The walker is called <code>init</code>.</li>
<li>It contains logic specifically for the <code>root</code> node, meaning that the code inside the <code>root {}</code> block will run <strong>only</strong> on the <code>root</code> node. This syntax applies for any node types, as you will see very soon. Every Jac program starts with a single root node, but as you will later learn, a walker can be executed on any node, though the root is used by default if none is specified.</li>
<li><code>spawn here --&gt; graph::faq</code> creates an instance of the <code>faq</code> graph and connects its anchor node to <code>here</code>, which is the node the walker is currently on.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p><code>init</code> can be viewed as similar to <code>main</code> in Python. It is the default walker to run when no specific walkers are specified for a <code>jac run</code> command.</p>
<p><code>here</code> is a very powerful keyword. It always evaluates to the specific node the walker is currently on. You will be using <code>here</code> a lot throughout this tutorial.</p>
</blockquote>
<h2 id="run-the-init-walker"><a class="header" href="#run-the-init-walker">Run the <code>init</code> Walker</a></h2>
<p>Now, let's run the init walker to initialize the graph.
First put all of the above code snippet into a single jac file and name it <code>main.jac</code>, including</p>
<ul>
<li>nodes definition</li>
<li>graph definition</li>
<li>init walker</li>
</ul>
<p>Run <code>jacctl</code> to get into the jaseci shell environment:</p>
<pre><code class="language-bash">jsctl
</code></pre>
<p>Inside the <code>jacctl</code> shell,</p>
<pre><code class="language-bash">jaseci &gt; jac dot main.jac
</code></pre>
<p>This command runs the <code>init</code> walker of the <code>main.jac</code> program and prints the state of its graph in DOT format after the walker has finished.
<a href="https://graphviz.org/doc/info/lang.html">The DOT language</a> is a popular graph description language widely used for representing complex graphs.</p>
<p>The output should look something like this</p>
<p><img src="images/dot_1.png" alt="Dot output for Faq graph" /></p>
<pre><code class="language-dot">strict digraph root {
    &quot;n0&quot; [ id=&quot;0955c04e4ff945b4b836748ef2bbd98a&quot;, label=&quot;n0:root&quot;  ]
    &quot;n1&quot; [ id=&quot;c1240d79110941c1bc2feb18581951bd&quot;, label=&quot;n1:faq_root&quot;  ]
    &quot;n2&quot; [ id=&quot;55333be285c246db88181ac34d16cd20&quot;, label=&quot;n2:faq_state&quot;  ]
    &quot;n3&quot; [ id=&quot;d4fa8f2c46ca463f9237ef818e086a29&quot;, label=&quot;n3:faq_state&quot;  ]
    &quot;n4&quot; [ id=&quot;f7b1c8ae82af4063ad53646adc5544e9&quot;, label=&quot;n4:faq_state&quot;  ]
    &quot;n0&quot; -&gt; &quot;n1&quot; [ id=&quot;a718fd6c938149269d3ade2af2eb023c&quot;, label=&quot;e0&quot; ]
    &quot;n1&quot; -&gt; &quot;n2&quot; [ id=&quot;3757cb15851249b4b6083d7cb3c34f8e&quot;, label=&quot;e1&quot; ]
    &quot;n1&quot; -&gt; &quot;n4&quot; [ id=&quot;626ce784a8f5423cae5d5d5ca857fc5c&quot;, label=&quot;e2&quot; ]
    &quot;n1&quot; -&gt; &quot;n3&quot; [ id=&quot;a609e7b54bde4a6a9c9711afdb123241&quot;, label=&quot;e3&quot; ]
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>We are not going to cover the DOT syntax. There are many resources online if you are interested, e.g., https://graphviz.org/doc/info/lang.html</p>
</blockquote>
<blockquote>
<p><strong>Note</strong></p>
<p>There are tools available to render a graph in DOT format. For example, https://dreampuf.github.io/GraphvizOnline has a WSIWYG editor to render dot graph in real time.</p>
</blockquote>
<p>Congratulations! You have just created your first functional jac program!</p>
<h2 id="ask-the-question"><a class="header" href="#ask-the-question">Ask the Question</a></h2>
<p>Alright, we have initialized the graph.
Now it's time to create the code for the question-answering.
We will start with a simple string matching for the answer selection algorithm.
For this, we will create a new walker called <code>ask</code>.</p>
<pre><code class="language-jac">walker ask {
    has question;
    root {
        question = std.input(&quot;AMA &gt; &quot;);
        take --&gt; node::faq_root;
    }
    faq_root {
        take --&gt; node::faq_state(question==question);
    }
    faq_state {:
        std.out(here.answer);
    }
}
</code></pre>
<p>This walker is more complex than the <code>init</code> one and introduces a few new concepts so let's break it down!</p>
<ul>
<li>Similar to nodes, walkers can also contain <code>has</code> variables. They define variables of the walker. They can also be passed as parameters when calling the walker.</li>
<li><code>std.input</code> and <code>std.out</code> read and write to the command line respectively.</li>
<li>This walker has logic for three types of node: <code>root</code>, <code>faq_root</code> and <code>faq_state</code>.
<ul>
<li><code>root</code>: It simply traverses to the <code>faq_root</code> node.</li>
<li><code>faq_root</code>: This is where the answer selection algorithm is. We will find the most relevant <code>faq_state</code> and then traverse to that node via a <code>take</code> statement. In this code snippet, we are using a very simple (and limited) string matching approach to try to match the predefined FAQ question with the user question.</li>
<li><code>faq_state</code>: Print the answer to the terminal.</li>
</ul>
</li>
</ul>
<p>Before we run this walker, we are going to update the <code>init</code> walker to speed up our development process</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::faq;
        spawn here walker::ask;
    }
}
</code></pre>
<p>This serves as a shorthand so that we can initialize the graph and ask a question in one command.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>This demonstrates how one walker can spawn another walker using the <code>spawn</code> keyword.</p>
</blockquote>
<p>Time to run the walker!</p>
<pre><code class="language-bash">jaseci &gt; jac run main.jac
</code></pre>
<p><code>jac run</code> functions very similarly to <code>jac dot</code>, with the only difference being that it doesn't return the graph in DOT format.
Try giving it one of the three questions we have predefined and it should respond with the corresponding answer.</p>
<h2 id="introducing-universal-sentence-encoder"><a class="header" href="#introducing-universal-sentence-encoder">Introducing Universal Sentence Encoder</a></h2>
<p>Now, obviously, what we have now is not very &quot;AI&quot; and we need to fix that.
We are going to use the Universal Sentence Encoder QA model as the answer selection algorithm.
Universal Sentence Encoder is a language encoder model that is pre-trained on a large corpus of natural language data and has been shown to be effective in many NLP tasks.
In our application, we are using it for zero-shot question-answering, i.e. no custom training required.</p>
<p>Jaseci has a set of built-in libraries or packages that are called Jaseci actions.
These actions cover a wide-range of state-of-the-art AI models across many different NLP tasks.
These actions are packaged in a Python module called <code>jaseci_kit</code>.</p>
<p>To install <code>jaseci_kit</code>:</p>
<pre><code class="language-bash">pip install jaseci_kit
</code></pre>
<p>Now we load the action we need into our jaseci environment</p>
<pre><code class="language-bash">jaseci &gt; actions load module jaseci_kit.use_qa
</code></pre>
<p>Let's update our walker logic to use the USE QA model:</p>
<pre><code class="language-jac">walker ask {
    can use.qa_classify;
    has question;
    root {
        question = std.input(&quot;&gt;&quot;);
        take --&gt; node::faq_root;
    }
    faq_root {
        answers = --&gt;.answer;
        best_answer = use.qa_classify(
            text = question,
            classes = answers
        );
        take --&gt; node::faq_state(answer==best_answer[&quot;match&quot;]);
    }
    faq_state {
        std.out(here.answer);
    }
}
</code></pre>
<p>Even though there are only 5 lines of new code, there are many interesting aspects, so let's break it down!</p>
<ul>
<li><code>--&gt;.answer</code> collects the <code>answer</code> variable of all of the nodes that are connected to <code>here</code>/<code>faq_root</code> with a <code>--&gt;</code> connection.</li>
<li><code>use.qa_classify</code> is one of the action supported by the USE QA action set. It takes in a question and a list of candidate answers and return the most relevant one.</li>
</ul>
<p>Now let's run this new updated walker and you can now ask questions that are relevant to the answers beyond just the predefined ones.</p>
<h2 id="scale-it-out"><a class="header" href="#scale-it-out">Scale it Out</a></h2>
<p>So far we have created a FAQ bot that is capable of providing answer in three topics.
To make this useful beyond just a prototype, we are now going to expand its database of answers.
Instead of manually spawning and connecting a node for each FAQ entry, we are going to write a walker that automatically expands our graph:</p>
<pre><code class="language-jac">walker ingest_faq {
    has kb_file;
    root: take --&gt; node::faq_root;
    faq_root {
        kb = file.load_json(kb_file);
        for faq in kb {
            answer = faq[&quot;answer&quot;];
            spawn here --&gt; node::faq_state(answer=answer);
        }
    }
}
</code></pre>
<p>An example knowledge base file look like this</p>
<pre><code class="language-jacon">[
  {
    &quot;question&quot;: &quot;I have a Model 3 reservation, how do I configure my order?&quot;,
    &quot;answer&quot;: &quot;To configure your order, log into your Tesla Account and select manage on your existing reservation to configure your Tesla. Your original USD deposit has now been converted to SGD.&quot;
  },
  {
    &quot;question&quot;: &quot;How do I order a Tesla?&quot;,
    &quot;answer&quot;: &quot;Visit our Design Studio to explore our latest options and place your order. The purchase price and estimated delivery date will change based on your configuration.&quot;
  },
  {
    &quot;question&quot;: &quot;Can I request a Test Drive?&quot;,
    &quot;answer&quot;: &quot;Yes, you can request for a test drive. Please note that drivers must be a minimum of 25 years of age and not exceeding 65 years of age, hold a full driving license with over 2 years of driving experience. Insurance conditions relating to your specific status must be reviewed and accepted prior to the test drive.&quot;
  }
]
</code></pre>
<p>Save the above json in a file named <code>tesla_faq.json</code> and make sure it is in the same location as <code>main.jac</code>.
Let's now update the <code>init</code> walker.
Because we are going to use the <code>ingest_faq</code> walker to generate the graph, we won't need the static graph definition.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; node::faq_root;
        spawn here walker::ingest_faq(kb_file=&quot;tesla_faq.json&quot;);
        spawn here walker::ask;
    }
}
</code></pre>
<p>What we are doing here is</p>
<ul>
<li>Spawning a <code>faq_root</code> node</li>
<li>Running the <code>ingest_faq</code> walker to create the neccessary <code>faq_state</code> nodes based on the question-answer entries in the <code>tesla_faq.json</code> file.</li>
<li>Launching the <code>ask</code> walker</li>
</ul>
<p>Let's run the program one more time and test it out!</p>
<pre><code class="language-bash">jaseci &gt; jac run main.jac
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Try more varied questions. Now we have a longer answer with more rich information, it has a higher coverage of information that will be able to answer more questions.</p>
</blockquote>
<blockquote>
<p><strong>Note</strong></p>
<p>If you are feeling adventurous, try downloading the complete list of entires on the Tesla FAQ page and use it to create a production-level FAQ bot. See if you can push the model to its limit!</p>
</blockquote>
<h1 id="next-up"><a class="header" href="#next-up">Next up!</a></h1>
<p><img src="images/arch.png" alt="Full architecture of Tesla AI" /></p>
<p>Here is a preview on what's next to come in this journey!</p>
<p>On the right is the architecture diagram of the complete system we are going to build. Here are the major components:</p>
<ul>
<li>Zero-shot FAQ (what we have built so far).</li>
<li>Action-oriented Multi-turn Dialogue System.</li>
<li>Training and inference with an intent classification model.</li>
<li>Training and inference with an entity extraction model.</li>
<li>Testing.</li>
<li>Deploying your Jac application to a production environment.</li>
<li>Training data collection and curation.</li>
</ul>
<h1 id="a-multi-turn-action-oriented-dialogue-system"><a class="header" href="#a-multi-turn-action-oriented-dialogue-system">A Multi-turn Action-oriented Dialogue System</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>In the previous section, we built a FAQ chabot.
It can search in a knowledge base of answers and find the most relevant one to a user's question.
While ths covers many diverse topics, certain user request can not be satisfied by a single answer.
For example, you might be looking to open a new bank account which requires mulitple different pieces of information about you.
Or, you might be making a reservation at a restaurant which requires information such as date, time and size of your group.
We refer to these as action-oriented conversational AI requests, as they often lead to a certain action or objective.</p>
<p>When interacting with a real human agent to accomplish this type of action-oriented requests, the interaction can get messy and unscripted and it also varies from person to person.
Again, use the restaurant reservation as an example, one migh prefer to follow the guidance of the agent and provide one piece of information at a time, while others might prefer to provide all the neccessary information in one sentence at the beginning of the interaction.</p>
<p>Therefore, in order to build a robust and flexible conversational AI to mimic a real human agent to support these types of messy action-oriented requests, we are going to need an architecture that is different than the single-turn FAQ.</p>
<p>And that is what we are going to build in this section -- a multi-turn action-oriented dialogue system.</p>
<blockquote>
<p><strong>Warning</strong></p>
<p>Start a new jac file (<code>dialogue.jac</code>) before moving fowrard. We will keep this program separate from the FAQ one we built. But, KEEP the FAQ jac file around, we will integrate these two systems into one unified conversational AI system later.</p>
</blockquote>
<h2 id="state-graph"><a class="header" href="#state-graph">State Graph</a></h2>
<p>Let's first go over the graph architecture for the dialogue system.
We will be building a state graph.
In a state graph, each node is a conversational state, which represent a possible user state during a dialgoue.
The state nodes are connected with transition edges, which encode the condition required to hop from one state to another state.
The conditions are often based on the user's input.</p>
<h2 id="define-the-state-nodes"><a class="header" href="#define-the-state-nodes">Define the State Nodes</a></h2>
<p>We will start by defining the node types.</p>
<pre><code class="language-jac">node dialogue_root;

node dialogue_state {
    has name;
    has response;
}
</code></pre>
<p>Here we have a <code>dialogue_root</code> as the entry point to the dialogue system and multiple <code>dialogue_state</code> nodes representing the conversational states.
These nodes will be connected with a new type of edge <code>intent_transition</code>.</p>
<h2 id="custom-edges"><a class="header" href="#custom-edges">Custom Edges</a></h2>
<pre><code class="language-jac">edge intent_transition {
    has intent;
}
</code></pre>
<p>This is the first custom edge we have introduced.
In jac, just like nodes, you can define custom edge type and edges can also have <code>has</code> variables.</p>
<p>In this case, we created an edge for intent transition. This is a state transition that will be triggered conditioned on its intent being detected from the user's input question.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Custom edge type and variables enable us to encode information into edges in addition to nodes. This is crucial for building a robust and flexible graph.</p>
</blockquote>
<h2 id="build-the-graph-1"><a class="header" href="#build-the-graph-1">Build the graph</a></h2>
<p>Let's build the first graph for the dialogue system.</p>
<pre><code class="language-jac">graph dialogue_system {
    has anchor dialogue_root;
    spawn {
        dialogue_root = spawn node::dialogue_root;
        test_drive_state = spawn node::dialogue_state(
            name = &quot;test_drive&quot;,
            response = &quot;Your test drive is scheduled for Jan 1st, 2023.&quot;
        );
        how_to_order_state = spawn node::dialogue_state (
            name = &quot;how_to_order&quot;,
            response = &quot;You can order a Tesla through our design studio.&quot;
        );

        dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;
        dialogue_root -[intent_transition(intent=&quot;order a tesla&quot;)]-&gt; how_to_order_state;
    }
}
</code></pre>
<p>We have already covered the syntax for graph definition, such as the <code>anchor</code> node and the <code>spawn</code> block in the previous section.
Refer to the FAQ graph definition step if you need a refresher.</p>
<p>We have a new language syntax here <code>dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;</code>.
Let's break this down!</p>
<ul>
<li>If you recall, we have used a similar but simpler syntax to connect two nodes with an edge <code>faq_root --&gt; faq_state;</code>. This connect <code>faq_root</code> to <code>faq_state</code> with a <strong>generic</strong> edge pointing to <code>faq_state</code>;</li>
<li>In <code>dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;</code>, we are connecting the two states with a <strong>custom</strong> edge of the type <code>intent_transition</code>.</li>
<li>In addition, we are initializing the variable <code>intent</code> of the edge to be <code>test drive</code>.</li>
</ul>
<p>To summarize, with this graph, a user will start at the dialogue root state when they first start the conversation.
Then based on the user's question and its intent, we will</p>
<h2 id="initialize-the-graph-1"><a class="header" href="#initialize-the-graph-1">Initialize the graph</a></h2>
<p>Let's create an <code>init</code> walker to for this new jac program.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::dialogue_system;
    }
}
</code></pre>
<p>Put all the code so far in a new file and name it <code>dialogue.jac</code>.</p>
<p>Let's initialize the graph and visualize it.</p>
<pre><code class="language-bash">jaseci &gt; jac dot dialogue.jac
</code></pre>
<pre><code class="language-dot">strict digraph root {
    &quot;n0&quot; [ id=&quot;7b4ee7198c5b4dcd8acfcf739d6971fe&quot;, label=&quot;n0:root&quot;  ]
    &quot;n1&quot; [ id=&quot;7caf939cfbce40d4968d904052368f30&quot;, label=&quot;n1:dialogue_root&quot;  ]
    &quot;n2&quot; [ id=&quot;2e06be95aed449b59056e07f2077d854&quot;, label=&quot;n2:dialogue_state&quot;  ]
    &quot;n3&quot; [ id=&quot;4aa3e21e13eb4fb99926a465528ae753&quot;, label=&quot;n3:dialogue_state&quot;  ]
    &quot;n1&quot; -&gt; &quot;n3&quot; [ id=&quot;6589c6d0dd67425ead843031c013d0fc&quot;, label=&quot;e0:intent_transition&quot; ]
    &quot;n1&quot; -&gt; &quot;n2&quot; [ id=&quot;f4c9981031a7446b855ec91b89aaa5ee&quot;, label=&quot;e1:intent_transition&quot; ]
    &quot;n0&quot; -&gt; &quot;n1&quot; [ id=&quot;bec764e7ee4048898799c2a4f01b9edb&quot;, label=&quot;e2&quot; ]
}
</code></pre>
<p><img src="images/dialogue/dot_1.png" alt="DOT of the dialogue system" /></p>
<h2 id="build-the-walker-logic"><a class="header" href="#build-the-walker-logic">Build the Walker Logic</a></h2>
<p>Let's now start building the walker to interact with this dialogue system.</p>
<pre><code class="language-jac">walker talk {
    has question;
    root {
        question = std.input(&quot;&gt; &quot;);
        take --&gt; node::dialogue_root;
    }
    dialogue_root {
        take -[intent_transition(intent==question)]-&gt; node::dialogue_state;
    }
    dialogue_state {
        std.out(here.response);
    }
}
</code></pre>
<p>Similar to the first walker we built for the FAQ system, we are starting with a simple string matching algorithm.
Let's update the init walker to include this walker.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::dialogue_system;
        spawn here walker::talk;
    }
}
</code></pre>
<p>Try out the following interactions</p>
<pre><code class="language-bash">$ jsctl jac run dialogue.jac
&gt; test drive
Your test drive is scheduled for Jan 1st, 2023.
{
  &quot;success&quot;: true,
  &quot;report&quot;: [],
  &quot;final_node&quot;: &quot;urn:uuid:9b8d9e1e-d7fb-4e6e-ae86-7ef7c7ad28a7&quot;,
  &quot;yielded&quot;: false
}
</code></pre>
<p>and</p>
<pre><code class="language-bash">$ jsctl jac run dialogue.jac
&gt; order a tesla
You can order a Tesla through our design studio.
{
  &quot;success&quot;: true,
  &quot;report&quot;: [],
  &quot;final_node&quot;: &quot;urn:uuid:168590aa-d579-4f22-afe7-da75ab7eefa3&quot;,
  &quot;yielded&quot;: false
}
</code></pre>
<p>What is happening here is based on the user's question, we are traversing the corresponding dialogue state and then return the response of that state.
For now, we are just matching the incoming question with the intent label as a simple algorithm, which we will now replace with an AI model.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Notice we are running <code>jacctl</code> commands directly from the terminal without first entering the jaseci shell? Any <code>jacctl</code> commands can be launched directly from the terminal by just prepending it with <code>jacctl</code>. Try it with the other <code>jacctl</code> comamnds we have encountered so far, such as <code>jac dot</code>.</p>
</blockquote>
<h2 id="intent-classificaiton-with-bi-encoder"><a class="header" href="#intent-classificaiton-with-bi-encoder">Intent classificaiton with Bi-encoder</a></h2>
<p>Let's introduce an intent classification AI model.
Intent Classification is the task of detecting and assigning one of a list of pre-defined intents to a given piece of text, to summarize what the text is conveying or asking.
It's one of the fundamental tasks in Natural Language Processing (NLP) with broad applications in many areas.</p>
<p>There are many models that have been proposed and applied to intent classification.
For this tutorial, we are going to use a Bi-Encoder model.
A Bi-encoder model has two transformer-based encoders that each encodes the input text and candidate intent labels into embedding vectors and then the model compare the similarity between the embedding vectors to find the most relevant/fitting intent label.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>If you don't fully understand the Bi-encoder model yet, do not worry! We will provide the neccessary code and tooling for you to wield this model as a black box. But, if you are interested, here is a paper for you to read up on it https://arxiv.org/pdf/1908.10084.pdf!</p>
</blockquote>
<p>Now let's train the model.
We have created a jac program and sample training data for this.
They are in the <code>code</code> directory next to this tutorial.
Copy <code>bi_enc.jac</code> and <code>clf_train_1.json</code> to your working directory.</p>
<p>You will find the Files <a href="https://github.com/Jaseci-Labs/jaseci/tree/main/examples/CanoniCAI/code">here</a></p>
<p>Let's first load the Bi-encoder action library into Jaseci.</p>
<pre><code class="language-bash">$ jsctl
jaseci &gt; actions load module jaseci_kit.bi_enc
</code></pre>
<p>We have provided an example training file that contains some starting point training data for the two intents, <code>test drive</code> and <code>order a tesla</code>.</p>
<pre><code class="language-jac">jaseci &gt; jac run bi_enc.jac -walk train -ctx &quot;{\&quot;train_file\&quot;: \&quot;clf_train_1.json\&quot;}&quot;
</code></pre>
<p>We are still using <code>jac run</code> but as you have noticied, this time we are using some new arguments. So let's break it down.</p>
<ul>
<li><code>-walk</code> specifies the name of the walker to run. By default, it runs the <code>init</code> walker.</li>
<li><code>-ctx</code> stands for <code>context</code>. This lets us provide input parameters to the walker. The input parameters are defined as <code>has</code> variables in the walker.</li>
</ul>
<blockquote>
<p><strong>Warning</strong></p>
<p><code>-ctx</code> expects a json string that contains a dictionary of parameters and their value. Since we are running this on the command line, you will need to escape the quotation marks <code>&quot;</code> properly for it to be a valid json string. Pay close attention to the example here <code>-ctx &quot;{\&quot;train_file\&quot;: \&quot;clf_train_1.json\&quot;}&quot;</code> and uses this as a reference.</p>
</blockquote>
<p>You should see an output block that looks like the following repeating many times on your screen:</p>
<pre><code class="language-bash">...
Epoch : 5
loss : 0.10562849541505177
LR : 0.0009854014598540146
...
</code></pre>
<p>Each training epoch, the above output will print with the training loss and learning rate at that epoch.
By default, the model is trained for 50 epochs.</p>
<p>If the training successfully finishes, you should see <code>&quot;success&quot;: true</code> at the end.</p>
<p>Now that the model has finished training, let's try it out!
You can use the <code>infer</code> walker to play with the model and test it out! <code>infer</code> is short for inference, which means using a trained model to run prediction on a given input.</p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk infer -ctx &quot;{\&quot;labels\&quot;: [\&quot;test drive\&quot;, \&quot;order a tesla\&quot;]}&quot;
</code></pre>
<p>Similar to training, we are using <code>jac run</code> to specifically invoke the <code>infer</code> walker and providing it with custom parameters.
The custom paremeter is the list of candidate intent labels, which are <code>test drive</code> and <code>order a tesla</code> in this case, as these were the intents the model was trained on.</p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk infer -ctx &quot;{\&quot;labels\&quot;: [\&quot;test drive\&quot;, \&quot;order a tesla\&quot;]}&quot;
Enter input text (Ctrl-C to exit)&gt; i want to order a tesla
{&quot;label&quot;: &quot;order a tesla&quot;, &quot;score&quot;: 9.812651595405981}
Enter input text (Ctrl-C to exit)&gt; i want to test drive
{&quot;label&quot;: &quot;test drive&quot;, &quot;score&quot;: 6.931458692617463}
Enter input text (Ctrl-C to exit)&gt;
</code></pre>
<p>In the output here, <code>label</code> is the predicted intent label and <code>score</code> is the score assigned by the model to that intent.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>One of the advantage of the bi-encoder model is that candidate intent labels can be dynamically defined at inference time, post training. This enables us to create custom contextual classifiers situationally from a single trained model. We will leverage this later as our dialogue system becomes more complex.</p>
</blockquote>
<p>Congratulations! You just trained your first intent classifier, easy as that.</p>
<p>The trained model is kept in memory and active until they are explicitly saved with <code>save_model</code>. To save the trained model to a location of your choosing, run</p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk save_model -ctx &quot;{\&quot;model_path\&quot;: \&quot;dialogue_intent_model\&quot;}&quot;
</code></pre>
<p>Similarly, you can load a saved model with <code>load_model</code></p>
<pre><code class="language-bash">jaseci &gt; jac run bi_enc.jac -walk load_model -ctx &quot;{\&quot;model_path\&quot;: \&quot;dialogue_intent_model\&quot;}&quot;
</code></pre>
<p>Always remember to save your trained models!</p>
<blockquote>
<p><strong>Warning</strong></p>
<p><code>save_model</code> works with relative path. When a relative model path is specified, it will save the model at the location relative to <strong>location of where you run jsctl</strong>. Note that until the model is saved, the trained weights will stay in memory, which means that it will not persisit between <code>jacctl</code> session. So once you have a trained model you like, make sure to save them so you can load them back in the next jsctl session.</p>
</blockquote>
<h2 id="integrate-the-intent-classifier"><a class="header" href="#integrate-the-intent-classifier">Integrate the Intent Classifier</a></h2>
<p>Now let's update our walker to use the trained intent classifier.</p>
<pre><code class="language-jac">walker talk {
    has question;
    can bi_enc.infer;
    root {
        question = std.input(&quot;&gt; &quot;);
        take --&gt; node::dialogue_root;
    }
    dialogue_root {
        intent_labels = -[intent_transition]-&gt;.edge.intent;
        predicted_intent = bi_enc.infer(
            contexts = [question],
            candidates = intent_labels,
            context_type = &quot;text&quot;,
            candidate_type = &quot;text&quot;
        )[0][&quot;predicted&quot;][&quot;label&quot;];
        take -[intent_transition(intent==predicted_intent)]-&gt; node::dialogue_state;
    }
    dialogue_state {
        std.out(here.response);
    }
}
</code></pre>
<p><code>intent_labels = -[intent_transition]-&gt;.edge.intent</code> collects the <code>intent</code> variables of all the outgoing <code>intent_transition</code> edges. This represents the list of candidate intent labels for this state.</p>
<p>Try playing with different questions, such as</p>
<pre><code class="language-bash">$ jsctl
jaseci &gt; jac run dialogue.jac
&gt; hey yo, I heard tesla cars are great, how do i get one?
You can order a Tesla through our design studio.
{
  &quot;success&quot;: true,
  &quot;report&quot;: [],
  &quot;final_node&quot;: &quot;urn:uuid:af667fdf-c2b0-4443-9ccd-7312bc4c66c4&quot;,
  &quot;yielded&quot;: false
}
</code></pre>
<h2 id="making-our-dialogue-system-multi-turn"><a class="header" href="#making-our-dialogue-system-multi-turn">Making Our Dialogue System Multi-turn</a></h2>
<p>Dialogues in real life have many turn of interaction.
Our dialogue system should also support that to provide a human-like conversational experinece.
In this section, we are going to take the dialogue system to the next level and create a multi-turn dialogue experience.</p>
<p>Before we do that we need to introduce two new concepts in Jac: node abilities and inheritance.</p>
<h3 id="node-abilities"><a class="header" href="#node-abilities">Node Abilities</a></h3>
<p>Node abilities are code that encoded as part of each node type.
They often contain logic that read, write and generally manipulate the variables and states of the nodes.
Node abilities are defined with the <code>can</code> keyword inside the definition of nodes, for example, in the code below, <code>get_plate_number</code> is an ability of the <code>vehicle</code> node.</p>
<pre><code class="language-jac">node vehicle {
    has plate_numer;
    can get_plate_numer {
        report here.plate_number;
    }
}
</code></pre>
<p>To learn more about node abilities, refer to the relevant sections of the Jaseci Bible.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Node abilities look and function similarly to member functions in object-oriented programming (OOP). However, there is a key difference in the concepts. Node abilities are the key concept in data-spatial programming, where the logic should stay close to its working set data in terms of the programming syntax.</p>
</blockquote>
<h3 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h3>
<p>Jac supports inheritance for nodes and edges.
Node variables (defined with <code>has</code>) and node abilities (defined with <code>can</code>) are inherited and can be overwritten by children nodes.</p>
<p>Here is an example:</p>
<pre><code class="language-jac">node vehicle {
    has plate_number;
    can get_plate_number {
        report here.plate_number;
    }
}

node car:vehicle {
    has plate_number = &quot;RAC001&quot;;
}

node bus:vehicle {
    has plate_number = &quot;SUB002&quot;;
}
</code></pre>
<p>To learn more about inheritance in Jac, refer to the relevant sections of the Jaseci Bible.</p>
<h2 id="build-the-multi-turn-dialogue-graph"><a class="header" href="#build-the-multi-turn-dialogue-graph">Build the Multi-turn Dialogue Graph</a></h2>
<p>Now that we have learnt about node abilities and node inheritance, let's put these new concepts to use to build a new graph for the multi-turn dialogue system</p>
<p>There are multiple parts to this so let's break it down one by one</p>
<h3 id="dialogue-state-specific-logic"><a class="header" href="#dialogue-state-specific-logic">Dialogue State Specific Logic</a></h3>
<p>With the node abilities and node inheritance, we will now introduce state specific logic.
Take a look at how the <code>dialogue_root</code> node definition has changed.</p>
<pre><code class="language-jac">node dialogue_state {
    can bi_enc.infer;
    can tfm_ner.extract_entity;

    can classify_intent {
        intent_labels = -[intent_transition]-&gt;.edge.intent;
        visitor.wlk_ctx[&quot;intent&quot;] = bi_enc.infer(
            contexts = [visitor.question],
            candidates = intent_labels,
            context_type = &quot;text&quot;,
            candidate_type = &quot;text&quot;
        )[0][&quot;predicted&quot;][&quot;label&quot;];
    }

    can extract_entities {
        // Entity extraction logic will be added a bit later on.
    }

    can init_wlk_ctx {
        new_wlk_ctx = {
            &quot;intent&quot;: null,
            &quot;entities&quot;: {},
            &quot;prev_state&quot;: null,
            &quot;next_state&quot;: null,
            &quot;respond&quot;: false
        };
        if (&quot;entities&quot; in visitor.wlk_ctx) {
            // Carry over extracted entities from previous interaction
            new_wlk_ctx[&quot;entities&quot;] = visitor.wlk_ctx[&quot;entities&quot;];
        }
        visitor.wlk_ctx = new_wlk_ctx;
    }
    can nlu {}
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = net.root();
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {}
}

node dialogue_root:dialogue_state {
    has name = &quot;dialogue_root&quot;;
    can nlu {
        ::classify_intent;
    }
    can process {
        visitor.wlk_ctx[&quot;next_state&quot;] = (-[intent_transition(intent==visitor.wlk_ctx[&quot;intent&quot;])]-&gt;)[0];
    }
    can nlg {
        visitor.response = &quot;Sorry I can't handle that just yet. Anything else I can help you with?&quot;;
    }
}
</code></pre>
<p>There are many interesting things going on in these ~30 lines of code so let's break it down!</p>
<ul>
<li>The <code>dialogue_state</code> node is the parent node and it is similar to a virtual class in OOP. It defines the variables and abilities of the nodes but the details of the abilities will be specified in the inheriting children nodes.</li>
<li>In this case, <code>dialogue_state</code> has 4 node abilities:
<ul>
<li><code>can nlu</code>: NLU stands for Natural Language Understanding. This ability will analyze user's incoming requset and apply AI models.</li>
<li><code>can process</code>: This ability uses the NLU results and figure out the next dialogue state the walker should go to.</li>
<li><code>can nlg</code>: NLG stands for Natural Language Generation. This abilitiy will compose response to the user, often based on the results from <code>nlu</code>.</li>
<li><code>can classify_intent</code>: an ability to handle intent classification. This is the same intent classification logic that has been copied over from the walker.</li>
<li><code>can extract_entities</code>: a new ability with a new AI model -- entity extraction. We will cover that just in a little bit (read on!).</li>
</ul>
</li>
<li>Between these four node abilities, <code>classify_intent</code> and <code>extract_entities</code> have concrete logic defined while <code>nlu</code> and <code>nlg</code> are &quot;virtual node abilities&quot;, which will be specified in each of the inheriting children.</li>
<li>For example, <code>dialogue_root</code> inherit from <code>dialogue_state</code> and overwrites <code>nlu</code> and <code>nlg</code>:
<ul>
<li>for <code>nlu</code>, it invokes intent classification because it needs to decide what's the intent of the user (test drive vs order a tesla).</li>
<li>for <code>nlg</code>, it just has a general fall-back response in case the system can't handle user's ask.</li>
</ul>
</li>
<li><strong>New Syntax</strong>: <code>visitor</code> is the walker that is &quot;visiting&quot; the node. And through <code>visitor.*</code>, the node abilities can access and update the context of the walker. In this case, the node abilities are updating the <code>response</code> variable in the walker's context so that the walker can return the response to its caller, as well as the <code>wlk_ctx</code> variable that will contain various walker context as the walker traverse the graph.
<ul>
<li>the <code>init_wlk_ctx</code> ability initializes the <code>wlk_ctx</code> variable for each new question.</li>
</ul>
</li>
</ul>
<p>In this new node architecture, each dialogue state will have its own node type, specifying their state-specific logic in <code>nlu</code>, <code>nlg</code> and <code>process</code>.
Let's take a look!</p>
<pre><code class="language-jac">node how_to_order_state:dialogue_state {
    has name = &quot;how_to_order&quot;;
    can nlg {
        visitor.response = &quot;You can order a Telsa through our design studio&quot;;
    }
}

node test_drive_state:dialogue_state {
    has name = &quot;test_drive&quot;;
    can nlu {
        if (!visitor.wlk_ctx[&quot;intent&quot;]): ::classify_intent;
        ::extract_entities;
    }
    can process {
        // Check entity transition
        required_entities = -[entity_transition]-&gt;.edge[0].context[&quot;entities&quot;];
        if (vector.sort_by_key(visitor.wlk_ctx[&quot;entities&quot;].d::keys) == vector.sort_by_key(required_entities)) {
            visitor.wlk_ctx[&quot;next_state&quot;] = -[entity_transition]-&gt;[0];
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        } elif (visitor.wlk_ctx[&quot;prev_state&quot;] and !visitor.wlk_ctx[&quot;prev_state&quot;].context[&quot;name&quot;] in [&quot;test_drive&quot;, &quot;td_confirmation&quot;]){
            next_state = -[intent_transition(intent==visitor.wlk_ctx[&quot;intent&quot;])]-&gt;;
            if (next_state.length &gt; 0 and visitor.wlk_ctx[&quot;intent&quot;] != &quot;no&quot;) {
                visitor.wlk_ctx[&quot;next_state&quot;] = next_state[0];
                visitor.wlk_ctx[&quot;prev_state&quot;] = here;
            } else {
                visitor.wlk_ctx[&quot;respond&quot;] = true;
            }
        } else {
            visitor.wlk_ctx[&quot;respond&quot;] = true;
        }
    }
    can nlg {
        if (&quot;name&quot; in visitor.wlk_ctx[&quot;entities&quot;] and &quot;address&quot; not in visitor.wlk_ctx[&quot;entities&quot;]):
            visitor.response = &quot;What is your address?&quot;;
        elif (&quot;address&quot; in visitor.wlk_ctx[&quot;entities&quot;] and &quot;name&quot; not in visitor.wlk_ctx[&quot;entities&quot;]):
            visitor.response = &quot;What is your name?&quot;;
        else:
            visitor.response = &quot;To set you up with a test drive, we will need your name and address.&quot;;
    }
}

node td_confirmation:dialogue_state {
    has name = &quot;test_drive_confirmation&quot;;
    can nlu {
        if (!visitor.wlk_ctx[&quot;intent&quot;]): ::classify_intent;
    }
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = -[intent_transition(intent==visitor.wlk_ctx[&quot;intent&quot;])]-&gt;[0];
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {
        visitor.response =
            &quot;Can you confirm your name to be &quot; + visitor.wlk_ctx[&quot;entities&quot;][&quot;name&quot;][0] + &quot; and your address as &quot; + visitor.wlk_ctx[&quot;entities&quot;][&quot;address&quot;][0] + &quot;?&quot;;
    }
}

node td_confirmed:dialogue_state {
    has name = &quot;test_drive_confirmed&quot;;
    can nlg {
        visitor.response = &quot;You are all set for a Tesla test drive!&quot;;
    }
}

node td_canceled:dialogue_state {
    has name = &quot;test_drive_canceled&quot;;
    can nlg {
        visitor.response = &quot;No worries. We look forward to hearing from you in the future!&quot;;
    }
}
</code></pre>
<ul>
<li>
<p>Each dialogue state now has its own node type, all inheriting from the same generic <code>dialogue_state</code> node type.</p>
</li>
<li>
<p>We have 4 dialogue states here for the test drive capability:</p>
<ul>
<li><code>test_drive</code>: This is the main state of the test drive intent. It is responsible for collecting the neccessary information from the user.</li>
<li><code>test_drive_confirmation</code>: Ths is the state for user to confirm the information they have provided are correct and is ready to actually schedule the test drive.</li>
<li><code>test_drive_confirmed</code>: This is the state after the user has confirmed.</li>
<li><code>test_drive_canceled</code>: User has decided, in the middle of the dialogue, to cancel their request to schedule a test drive.</li>
</ul>
</li>
<li>
<p>The <code>process</code> ability contains the logic that defines the conversational flow of the dialogue system. It uses the data in <code>wlk_ctx</code> and assign a <code>next_state</code> which will be used by the walker in a <code>take</code> statement, as you will see in a just a little bit.</p>
</li>
<li>
<p><strong>New Syntax</strong>: The code in <code>test_drive_state</code>'s ability demonstrates jac support for list and dictionary. To access the list and dictionary-specific functions, first cast the variable with <code>.l</code>/<code>.list</code> for list and <code>.d</code>/<code>.dict</code> for dictionaries, then proceed with <code>:</code> to access the built-in functions for list and dictioinaries. For more on jac's built-in types, refer to the relevant sections of the Jaseci Bible.</p>
<ul>
<li>Specifically in this case, we are comparing the list of entities of the <code>entity_transition</code> edge with the list of entities that have been extracted by the walker and the AI model (stored in <code>wlk_ctx[&quot;entities]</code>). Since there can be multiple entities required and they can be extracted in arbitrary order, we are sorting and then comparing here.</li>
</ul>
</li>
<li>
<p><strong>New Syntax</strong>: <code>-[entity_transition]-&gt;.edge</code> shows how to access the edge variable. Consider <code>-[entity_transition]-&gt;</code> as a filter. It returns all valid nodes that are connected to the implicit <code>here</code> via an <code>entity_transition</code>. On its own, it will return all the qualified nodes. When followed by <code>.edge</code>, it will return the set of edges that are connected to the qualified nodes.</p>
</li>
</ul>
<p>You might notice that some states do not have a <code>process</code> ability.
These are states that do not have any outgoing transitions, which we refer to as leaf nodes.
If these nodes are reached, they indicate that a dialogue has been completed end to end.
The next state for these node will be returning to the root node so that the next dialogue can start fresh.
To facilitate this, we will add the following logic to the <code>process</code> ability of the <strong>parent <code>dialogue_state</code> node</strong> so that by default, any nodes inheriting it will follow this rule.</p>
<pre><code class="language-jac">node dialogue_state {
...
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = net.root();
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
...
}
</code></pre>
<blockquote>
<p><strong>Note</strong></p>
<p>Pay attention to the 4 dialogue states here. This pattern of <code>main</code> -&gt; <code>confirmation</code> -&gt; <code>confirmed</code> -&gt; <code>canceled</code> is a very common conversational state graph design pattern and can apply to many topics, e.g., make a restaurant reservation and opening a new bank account. Essentially, almost any action-oriented requests can leverage this conversational pattern. Keep this in mind!</p>
</blockquote>
<h3 id="entity-extraction"><a class="header" href="#entity-extraction">Entity Extraction</a></h3>
<p>Previously, we have introduced intent classification and how it helps to build a dialogue system.
We now introduce the second key AI models, that is specifically important for a multi-turn dialogue system, that is entity/slot extraction.</p>
<p>Entity extraction is a NLP task that focuses on extracting words or phrases of interests, or entities, from a given piece of text.
Entity extraction, sometimes also referred to as Named Entity Recognition (NER), is useful in many domains, including information retrieval and conversational AI.
We are going to use a transformer-based entity extraction model for this exercise.</p>
<p>Let's first take a look at how we are going to use an entity model in our program.
Then we will work on training an entity model.</p>
<p>First, we introduce a new type of transition:</p>
<pre><code class="language-jac">edge entity_transition {
    has entities;
}
</code></pre>
<p>Recall the <code>intent_transition</code> that will trigger if the intent is the one that is being predicted.
Similarly, the idea behind an <code>entity_transition</code> is that we will traverse this transition if all the specified entities have been fulfilled, i.e., they have been extracted from user's inputs.</p>
<p>With the <code>entity_transition</code>, let's update our graph</p>
<pre><code class="language-jac">graph dialogue_system {
    has anchor dialogue_root;
    spawn {
        dialogue_root = spawn node::dialogue_root;
        test_drive_state = spawn node::test_drive_state;
        td_confirmation = spawn node::td_confirmation;
        td_confirmed = spawn node::td_confirmed;
        td_canceled = spawn node::td_canceled;

        how_to_order_state = spawn node::how_to_order_state;

        dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;
        test_drive_state -[intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;
        test_drive_state -[entity_transition(entities=[&quot;name&quot;, &quot;address&quot;])]-&gt; td_confirmation;
        test_drive_state -[intent_transition(intent=&quot;provide name or address&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;yes&quot;)]-&gt; td_confirmed;
        td_confirmation - [intent_transition(intent=&quot;no&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;

        dialogue_root -[intent_transition(intent=&quot;order a tesla&quot;)]-&gt; how_to_order_state;
    }
}
</code></pre>
<p>Your graph should look something like this!</p>
<p><img src="images/dialogue/multi-turn.png" alt="Multi-turn Dialogue Graph" /></p>
<h2 id="update-the-walker-for-multi-turn-dialogue"><a class="header" href="#update-the-walker-for-multi-turn-dialogue">Update the Walker for Multi-turn Dialogue</a></h2>
<p>Let's now turn our focus to the walker logic</p>
<pre><code class="language-jac">walker talk {
    has question;
    has wlk_ctx = {};
    has response;
    root {
        take --&gt; node::dialogue_root;
    }
    dialogue_state {
        if (!question) {
            question = std.input(&quot;Question (Ctrl-C to exit)&gt; &quot;);
            here::init_wlk_ctx;
        }
        here::nlu;
        here::process;
        if (visitor.wlk_ctx[&quot;respond&quot;]) {
            here::nlg;
            std.out(response);
            question = null;
            take here;
        } else {
            take visitor.wlk_ctx[&quot;next_state&quot;] else: take here;
        }
    }
}
</code></pre>
<p>The walker logic looks very different now. Let's break it down!</p>
<ul>
<li>First off, because the intent classification logic is now a node ability, the walker logic has become simpler and, more importantly, more focused on graph traversal logic without the detailed (and occasionally convoluted) logic required to process to interact with an AI model.</li>
<li><strong>New Syntax</strong>: <code>here::nlu</code> and <code>here::nlg</code> invokes the node abilities. <code>here</code> can be subtitied with any node variables, not just the one the walker is currently on.</li>
</ul>
<p>Now that we have explained some of the new language syntax here, let's go over the overall logic of this walker.
For a new question from the user, the walker will</p>
<ol>
<li>analyze the question (<code>here:nlu</code>) to identify its intent (<code>predicted_intent</code>) and/or extract its entities (<code>extracted_entities</code>).</li>
<li>based on the NLU results, it will traverse the dialogue state graph (the two <code>take</code> statements) to a new dialogue state</li>
<li>at this new dialogue state, it will perform NLU, specific to that state (recall that <code>nlu</code> is a node ability that varies from node to node) and repeat step 2</li>
<li>if the walker can not make any state traversal anymore (<code>take ... else {}</code>), it will construct a response (<code>here::nlg</code>) using the information it has gathered so far (the walker's context) and return that response to the user.</li>
</ol>
<p>If this still sounds fuzzy, don't worry! Let's use a real dialogue as an example to illustrate this.</p>
<pre><code class="language-bash">Turn #1:
    User: hey i want to schedule a test drive
    Tesla AI: To set you up with a test drive, we will need your name and address.

Turn #2:
    User: my name is Elon and I live at 123 Main Street
    Tesla AI: Can you confirm your name to be Elon and your address as 123 Main Street?

Turn #3:
    User: Yup! that is correct
    Tesla AI: You are all set for a Tesla test drive!
</code></pre>
<p>At turn #1,</p>
<ul>
<li>The walker starts at <code>dialogue_root</code>.</li>
<li>The <code>nlu</code> at <code>dialogue_root</code> is called and classify the intent to be <code>test drive</code>.</li>
<li>There is an <code>intent_transition(test_drive)</code> connecting <code>dialogue_root</code> to <code>test_drive_state</code> so the walker <code>takes</code> itself to <code>test_drive_state</code> .</li>
<li>We are now at <code>test_drive_state</code>, its <code>nlu</code> requires <code>entity_extraction</code> which will look for <code>name</code> and <code>address</code> entities. In this case, neither is provided by the user.</li>
<li>As a result, the walker can no longer traverse based on the <code>take</code> rules and thus construct a response based on the <code>nlg</code> logic at the <code>test_drive_state</code>.</li>
</ul>
<p>At turn #2,</p>
<ul>
<li>The walker starts at <code>test_drive_state</code>, picking up where it left off.</li>
<li><code>nlu</code> at <code>test_drive_state</code> perform intent classification and entity extractions. This time it will pick up both name and address.</li>
<li>As a result, the first <code>take</code> statement finds a qualified path and take that path to the <code>td_confirmation</code> node.</li>
<li>At <code>td_confirmation</code>, no valid take path exists so a response is returned.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>Turn #3 works similiarly as turn #1. See if you can figure out how the walker reacts at turn #3 yourself!</p>
</blockquote>
<h2 id="train-an-entity-extraction-model"><a class="header" href="#train-an-entity-extraction-model">Train an Entity Extraction Model</a></h2>
<p>Let's now train an entity extraction model!
We are using a transformer-based token classification model.</p>
<p>First, we need to load the actions. The action set is called <code>tfm_ner</code> (<code>tfm</code> stands for transformer).</p>
<pre><code class="language-bash">jaseci &gt; actions load module jaseci_kit.tfm_ner
</code></pre>
<blockquote>
<p><strong>Warning</strong></p>
<p>If you installed <code>jaseci_kit</code> prior to September 5th, 2022, please upgrade via <code>pip install --upgrade jaseci_kit</code>. There has been an update to the module that you will need for remainder of this exercise. You can check your installed version via <code>pip show jaseci_kit</code>. You need to be on version 1.3.4.6 or higher.</p>
</blockquote>
<p>Similar to Bi-encoder, we have provided a jac program to train and inference with this model, as well as an example training dataset.
Go into the <code>code/</code> directory and copy <code>tfm_ner.jac</code> and <code>ner_train.json</code> to your working directory.
We are training the model to detect two entities, <code>name</code> and <code>address</code>, for the test drive use case.</p>
<p>Let's quickly go over the training data format.</p>
<pre><code class="language-jacon">[
    &quot;sure my name is [tony stark](name) and i live at [10880 malibu point california](address)&quot;,
    &quot;my name is [jason](name)&quot;
]
</code></pre>
<p>The training data is a json list of strings, each of which is a training example.
<code>[]</code> indicate the entitiy text while the <code>()</code> following it defines the entity type.
So in the example above, we have two entities, <code>name:tony stark</code> and <code>address: 10880 malibu point california</code>.</p>
<p>To train the model, run</p>
<pre><code class="language-bash">jaseci &gt; jac run tfm_ner.jac -walk train -ctx &quot;{\&quot;train_file\&quot;: \&quot;ner_train.json\&quot;}&quot;
</code></pre>
<p>After the model is finished training, you can play with the model using the <code>infer</code> walker</p>
<pre><code class="language-jac">jaseci &gt; jac run ner.jac -walk infer
</code></pre>
<p>For example,</p>
<pre><code class="language-bash">jaseci &gt; jac run tfm_ner.jac -walk infer
Enter input text (Ctrl-C to exit)&gt; my name is jason
[{&quot;entity_text&quot;: &quot;jason&quot;, &quot;entity_value&quot;: &quot;name&quot;, &quot;conf_score&quot;: 0.5514775514602661, &quot;start_pos&quot;: 11, &quot;end_pos&quot;: 16}]
</code></pre>
<p>The output of this model is a list of dictionaries, each of which is one detected entitiy.
For each detected entity, <code>entity_value</code> is the type of entity, so in this case either <code>name</code> or <code>address</code>;
and <code>entity_text</code> is the detected text from the input for this entity, so in this case the user's name or their address.</p>
<p>Let's now update the node ability to use the entity model.</p>
<pre><code class="language-jac">node dialogue_state {
    ...
    can extract_entities {
        res = tfm_ner.extract_entity(visitor.question);
        for ent in res {
            ent_type = ent[&quot;entity_value&quot;];
            ent_text = ent[&quot;entity_text&quot;];
            if (!(ent_type in visitor.wlk_ctx[&quot;entities&quot;])){
                visitor.wlk_ctx[&quot;entities&quot;][ent_type] = [];
            }
            visitor.wlk_ctx[&quot;entities&quot;][ent_type].l::append(ent_text);
        }
    }
    ...
}
</code></pre>
<p>There is one last update we need to do before this is fully functional.
Because we have more dialogue states and a more complex graph, we need to update our classifier to include the new intents.
We have provided an example training dataset at <code>code/clf_train_2.json</code>.
Re-train the bi-encoder model with this dataset.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Refer to previous code snippets if you need a reminder on how to train the bi-encoder classifier model.</p>
</blockquote>
<p>Now try running the walker again with <code>jac run dialogue.jac</code>!</p>
<p>Congratulations! You now have a fully functional multi-turn dialogue system that can handle test drive requests!</p>
<h1 id="unify-the-dialogue-and-faq-systems"><a class="header" href="#unify-the-dialogue-and-faq-systems">Unify the Dialogue and FAQ Systems</a></h1>
<p>So far, we have built two separate conversational AI systems, a FAQ system that automatically scales with the available question-answer pairs and a multi-turn action-oriented dialogue system that can handle complex requests.
These two systems serve different use cases and can be combined to a single system to provide a flexible and robust conversational AI experience.
In this section, we are going to unify these two systems into one coherent conversational AI system.</p>
<p>While these two systems rely on different AI models, they share many of the same logic flow.
They both follow the general steps of first analyizing user's question with NLU AI models, make decision on the next conversational state to be and then construct and return a response to the user.
Leveraging this shared pattern, we will first unify the node architecture of the two systems with a single parent node type, <code>cai_state</code> (<code>cai</code> is short of conversational AI).</p>
<pre><code class="language-jac">node cai_state {
    has name;
    can init_wlk_ctx {
        new_wlk_ctx = {
            &quot;intent&quot;: null,
            &quot;entities&quot;: {},
            &quot;prev_state&quot;: null,
            &quot;next_state&quot;: null,
            &quot;respond&quot;: false
        };
        if (&quot;entities&quot; in visitor.wlk_ctx) {
            // Carry over extracted entities from previous interaction
            new_wlk_ctx[&quot;entities&quot;] = visitor.wlk_ctx[&quot;entities&quot;];
        }
        visitor.wlk_ctx = new_wlk_ctx;
    }
    can nlu {}
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            visitor.wlk_ctx[&quot;next_state&quot;] = net.root();
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {}
}
</code></pre>
<p>Note that the logic for <code>init_wlk_ctx</code> and the default <code>process</code> logic have been hoisted up into <code>cai_state</code> as they are shared by the dialogue system and FAQ system.
You can remove these two abilities from <code>dialogue_state</code> node, as it will be inheriting them from <code>cai_state</code> now.</p>
<p>We then update the defintion of <code>dialogue_state</code> in <code>dialogue.jac</code> to inherit from <code>cai_state</code>:</p>
<pre><code class="language-jac">node dialogue_state:cai_state{
    // Rest of dialogue_state code remain the same
}
</code></pre>
<p>Before we move on, we will take a quick detour to introduce multi-file jac program and how import works in jac.</p>
<h2 id="multi-file-jac-program-and-import"><a class="header" href="#multi-file-jac-program-and-import">Multi-file Jac Program and Import</a></h2>
<p>Jac's support for multi-file is quite simple.
You can import object definitions from one jac file to another with the <code>import</code> keyword.
With <code>import {*} with &quot;./code.jac&quot;</code>, everything from <code>code.jac</code> will be imported, which can include nodes, edges, graph and walker definition.
Alternaitvely, you can import specific objects with <code>import {node::state} with &quot;./code.jac&quot;</code>.</p>
<p>To compile a multi-file Jac program, you will need one jac file that serves as the entry point of the program.
This file need to import all the neccessary components of the program.
Chained importing is supported.</p>
<p>Once you have the main jac file (let's call it <code>main.jac</code>), you will need to compile it and its imports into a single <code>.jir</code> file.
<code>jir</code> here stands for Jac Intermediate Representation.
To compile a jac file, use the <code>jac build</code> command</p>
<pre><code class="language-jac">jaseci &gt; jac build main.jac
</code></pre>
<p>If the compilation is successful, a <code>.jir</code> file with the same name will be generated (in this case, <code>main.jir</code>).
<code>jir</code> file can be used with <code>jac run</code> or <code>jac dot</code> the same way as the <code>jac</code> source code file.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>The <code>jir</code> format is what you will use to deploy your jac program to a production jaseci instance.</p>
</blockquote>
<h2 id="unify-faq--dialogue-code"><a class="header" href="#unify-faq--dialogue-code">Unify FAQ + Dialogue Code</a></h2>
<p>For <code>faq_state</code>, we need to now define the <code>nlu</code> and <code>nlg</code> node abilities for FAQ.
So let's update the following in <code>faq.jac</code>
First, <code>faq_root</code></p>
<pre><code class="language-jac">node faq_root:cai_state {
    can use.qa_classify;
    can nlu {
        if (!visitor.wlk_ctx[&quot;prev_state&quot;]) {
            answers = --&gt;.answer;
            best_answer = use.qa_classify(
                text = visitor.question,
                classes = answers
            );
            visitor.wlk_ctx[&quot;intent&quot;] = best_answer[&quot;match&quot;];
        }
    }
    can process {
        if (visitor.wlk_ctx[&quot;prev_state&quot;]): visitor.wlk_ctx[&quot;respond&quot;] = true;
        else {
            for n in --&gt; {
                if (n.context[&quot;answer&quot;] == visitor.wlk_ctx[&quot;intent&quot;]){
                    visitor.wlk_ctx[&quot;next_state&quot;] = n;
                    break;
                }
            }
            visitor.wlk_ctx[&quot;prev_state&quot;] = here;
        }
    }
    can nlg {
        visitor.response = &quot;I can answer a variety of FAQs related to Tesla. What can I help you with?&quot;;
    }
}
</code></pre>
<p>At this point, if you have been following this journey along, this code should be relatively easy to understand.
Let's quickly break it down.</p>
<ul>
<li>For FAQ, the <code>nlu</code> logic uses the USE QA model to find the most relevant answer. Here we are re-using the <code>intent</code> field in the walker context to save the matched answer. You can also opt to create another field dedicated to FAQ NLU result.</li>
<li>For the traversal logic, this is very similar to the previous FAQ logic, i.e. find the <code>faq_state</code> node connected to here that contains the most relevant answer.</li>
<li><code>for n in --&gt;</code> iterates through all the nodes connected with an outgoing edge from the current node. You can use <code>.context</code> on any node variables to access its variables.</li>
</ul>
<p>And the logic for the <code>faq_state</code> that contains the answer is relatively simple;</p>
<pre><code class="language-jac">node faq_state:cai_state {
    has question;
    has answer;
    can nlg {
        visitor.response = here.answer;
    }
}
</code></pre>
<p>With these new nodes created, let's update our graph definition.
We have renamed our graph to be <code>tesla_ai</code> and the <code>dialogue.jac</code> file to <code>tesla_ai.jac</code>.</p>
<pre><code class="language-jac">graph tesla_ai {
    has anchor dialogue_root;
    spawn {
        dialogue_root = spawn node::dialogue_root;
        test_drive_state = spawn node::test_drive_state;
        td_confirmation = spawn node::td_confirmation;
        td_confirmed = spawn node::td_confirmed;
        td_canceled = spawn node::td_canceled;

        dialogue_root -[intent_transition(intent=&quot;test drive&quot;)]-&gt; test_drive_state;
        test_drive_state -[intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;
        test_drive_state -[entity_transition(entities=[&quot;name&quot;, &quot;address&quot;])]-&gt; td_confirmation;
        test_drive_state -[intent_transition(intent=&quot;provide name or address&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;yes&quot;)]-&gt; td_confirmed;
        td_confirmation - [intent_transition(intent=&quot;no&quot;)]-&gt; test_drive_state;
        td_confirmation - [intent_transition(intent=&quot;cancel&quot;)]-&gt; td_canceled;

        faq_root = spawn graph::faq;
        dialogue_root -[intent_transition(intent=&quot;i have a question&quot;)]-&gt; faq_root;
    }
}
</code></pre>
<p>One thing worth pointing out here is that we are spawning a graph inside a graph spawn block.</p>
<p>Our graph should now looks like this!</p>
<p><img src="images/complete.png" alt="" /></p>
<p>Here comes the biggest benefit of our unified node architecture -- the exact same walker logic can be shared to traverse both systems.
The only change we need to make is to change from <code>dialogue_state</code> to <code>cai_state</code> to apply the walker logic to a more generalized set of nodes.</p>
<pre><code class="language-jac">walker talk {
    ...
    root {
        take --&gt; node::dialogue_root;
    }
    cai_state {
        if (!question) {
            question = std.input(&quot;Question (Ctrl-C to exit)&gt; &quot;);
            here::init_wlk_ctx;
        }
        ...
    }
}
</code></pre>
<p>Update the graph name in the <code>init</code> walker as well.</p>
<pre><code class="language-jac">walker init {
    root {
        spawn here --&gt; graph::tesla_ai;
        spawn here walker::talk;
    }
}
</code></pre>
<p>To compile the program,</p>
<pre><code class="language-jac">jaseci &gt; jac build tesla_ai.jac
</code></pre>
<p>As mentioned before, if the compiliation succeedd, a <code>tesla_ai.jir</code> will be generated.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Run into issues at this build step? First check if all the imports are set up correctly.</p>
</blockquote>
<p>Running a <code>jir</code> is just like running a <code>jac</code> file</p>
<pre><code class="language-jac">jaseci &gt; jac run tesla_ai.jir
</code></pre>
<p>One last step, since we introduce a new intent <code>i have a questions</code>, we need to update our classifier model again.
This time, use the <code>clf_train_3.json</code> example training data.</p>
<p>The model is trained? Great! Now run the jir and try questions like &quot;I have some telsa related questions&quot; then following with FAQ questioins!</p>
<p>Congratulations! You have created a single conversational AI system that is capable of answering FAQs and perform complex multi-step actions.</p>
<h1 id="bring-your-application-to-production"><a class="header" href="#bring-your-application-to-production">Bring Your Application to Production</a></h1>
<p>Typing in questions and getting responses via <code>jacctl</code> in terminal is a quick and easy way of interactively test and use your program.
But the ultimate goal of building any products is to eventually deploying it to production and having it serve real users via standard interface such as RESTful API endpoints.
In this section, we will cover a number of items related to bringing your jac program to production.</p>
<h2 id="introducing-yield"><a class="header" href="#introducing-yield">Introducing <code>yield</code></a></h2>
<p><code>yield</code> is a jac keyword that suspend the walker and return a response, which then can be resumed at a later time with the walker context retained.
Walker context includes its <code>has</code> variables and its node traversal plan (i.e., any nodes that have been queued by previously executed <code>take</code> statements).
This context retention is done on a per-user basis.
<code>yield</code> is a great way to maintaining user-specific context and history in between walker calls.
To learn more about <code>yield,</code> refer to the relevant sections of the Jaseci Bible.</p>
<p>In the case of our conversational AI system, it is essential for our walker to remember the context information gained from previous interactions with the same user.
So let's update our walker with <code>yield.</code></p>
<pre><code class="language-jac">walker talk {
    has question, interactive = false;
    has wlk_ctx = {
        &quot;intent&quot;: null,
        &quot;entities&quot;: {},
        &quot;prev_state&quot;: null,
        &quot;next_state&quot;: null,
        &quot;respond&quot;: false
    };
    has response;
    root {
        take --&gt; node::dialogue_root;
    }
    cai_state {
        if (!question and interactive) {
            question = std.input(&quot;Question (Ctrl-C to exit)&gt; &quot;);
            here::init_wlk_ctx;
        } elif (!question and !interactive){
            std.err(&quot;ERROR: question is required for non-interactive mode&quot;);
            disengage;
        }
        here::nlu;
        here::process;
        if (visitor.wlk_ctx[&quot;respond&quot;]) {
            here::nlg;
            if (interactive): std.out(response);
            else {
                yield report response;
                here::init_wlk_ctx;
            }
            question = null;
            take here;
        } else {
            take visitor.wlk_ctx[&quot;next_state&quot;] else: take here;
        }
    }
}
</code></pre>
<p>Two new syntax here:</p>
<ul>
<li><code>report</code> returns variable from walker to its caller. When calling a walker via its REST API, the content of the API response payload will be what is reported.</li>
<li><code>yield report</code> is a shorthand for yielding and reporting at the same time. This is equivalane to <code>yield; report response;</code>.</li>
</ul>
<h2 id="introduce-sentinel"><a class="header" href="#introduce-sentinel">Introduce <code>sentinel</code></a></h2>
<p><code>sentinel</code> is the overseer of walkers, nodes and edges.
It is the abstraction Jaseci uses to encapsulate compiled walkers and architype nodes and edges.
The key operation with respesct to <code>sentinel</code> is &quot;register&quot; a sentinel.
You can think of registering a <code>sentinel</code> as a compiling your jac program.
The walkers of a given sentinel can then be invoked and run on arbitrary nodes of any graph.</p>
<p>Let's register our jac program</p>
<pre><code class="language-bash">jaseci &gt; sentinel register tesla_ai.jir -set_active true -mode ir
</code></pre>
<p>Three things are happening here:</p>
<ul>
<li>First, we registered the <code>jir</code> we compiled earlier to new sentinel. This means this new sentinel now has access to all of our walkers, nodes and edges. <code>-mode ir</code> option speciifes a <code>jir</code> program is registered instead of a <code>jac</code> program.</li>
<li>Second, with <code>-set_active true</code> we set this new sentinel to be the active sentinel. In other words, this sentinel is the default one to be used when requests hit the Jac APIs, if no specific sentinels are specified.</li>
<li>Third, <code>sentinel register</code> has automatically creates a new <code>graph</code> (if no currently active graph) and run the <code>init</code> walker on that graph. This behavior can be customized with the options <code>-auto_run</code> and <code>-auto_create_graph</code>.</li>
</ul>
<p>To check your graph</p>
<pre><code class="language-bash">jaseci &gt; graph get -mode dot
</code></pre>
<p>This will return the current active graph in DOT format.
This is the same output we get from running <code>jac dot</code> earlier.
Use this to check if your graph is successfully created.</p>
<p>Once a sentinel is registered, you can update its jac program with</p>
<pre><code class="language-bash">jaseci &gt; sentinel set -snt SENTINEL_ID -mode ir tesla_ai.jir
</code></pre>
<p>To get the sentinel ID, you can run one of the two following commands</p>
<pre><code class="language-bash">jaseci &gt; sentinel get
</code></pre>
<p>or</p>
<pre><code class="language-bash">jaseci &gt; sentinel list
</code></pre>
<p><code>sentinel get</code> returns the information about the current active sentinel, while <code>sentinel list</code> returns all available sentinels for the user.
The output will look something like this</p>
<pre><code class="language-jacon">{
  &quot;version&quot;: null,
  &quot;name&quot;: &quot;main.jir&quot;,
  &quot;kind&quot;: &quot;generic&quot;,
  &quot;jid&quot;: &quot;urn:uuid:817b4ff4-e6b7-4296-b383-55515e1e8b4a&quot;,
  &quot;j_timestamp&quot;: &quot;2022-08-04T20:23:16.952641&quot;,
  &quot;j_type&quot;: &quot;sentinel&quot;
}
</code></pre>
<p>The <code>jid</code> field is the ID for the sentinel. (<code>jid</code> stands for jaseci ID).</p>
<p>With a sentinel and graph, we can now run walker with</p>
<pre><code class="language-bash">jaseci &gt; walker run talk -ctx {\&quot;question\&quot;: \&quot;I want to schedule a test drive\&quot;}
</code></pre>
<p>And with <code>yield</code>, the next walker run will pick up where it leaves off and retain its variable states and nodes traversal plan.</p>
<h2 id="tests"><a class="header" href="#tests">Tests</a></h2>
<p>Just like any program, a set of automatic tests cases with robust coverage is essential to the success of the program through development to production.
Jac has built-in tests support and here is how you create a test case in jac.</p>
<pre><code class="language-jac">import {*} with &quot;tesla_ai.jac&quot;;

test &quot;testing the Tesla conv AI system&quot;
with graph::tesla_ai by walker::talk(question=&quot;Hey I would like to go on a test drive&quot;){
    res = std.get_report();
    assert(res[-1] == &quot;To set you up with a test drive, we will need your name and address.&quot;);
}
</code></pre>
<p>Let's break this down.</p>
<ul>
<li><code>test &quot;testing the tesla conv AI system&quot;</code> names the test.</li>
<li><code>with graph::tesla_ai</code> specify the graph to be used as the text fixture.</li>
<li><code>by walker::talk</code> specify the walker to test. It will be spawned on the anchor node of the graph.</li>
<li><code>std.get_report()</code> let you access the report content of the walker so that you can set up any assertion neccessary with <code>assert</code>.</li>
</ul>
<p>To run jac tests, save the test case(s) in a file (say <code>tests.jac</code>) and import the neccessary walkers and graphs. Then run</p>
<pre><code class="language-bash">jaseci &gt; jac test tests.jac
</code></pre>
<p>This will execute all the test cases in <code>tests.jac</code> squentially and report success or any assertion failures.</p>
<h2 id="running-jaseci-as-a-service"><a class="header" href="#running-jaseci-as-a-service">Running Jaseci as a Service</a></h2>
<p>So far, we have been interacting jaseci through <code>jacctl</code>.
jaseci can also be run as a service serving a set of RESTful API endpoints.
This is useful in production settings.
To run jaseci as a service, first we need to install the <code>jaseci_serv</code> package.</p>
<pre><code class="language-bash">pip install jaseci_serv
</code></pre>
<p>Then launching a jaseci server is as simple as</p>
<pre><code class="language-bash">jsserv makemigrations
jsserv migrate
jsserv runserver 0.0.0.0:3000
</code></pre>
<p>This will launch a Django RESTful API server at localhost and port 3000.
The Jaseci server supports a wide range of API endpoints.
All the <code>jacctl</code> commands we have used throughput this tutorial have an equivalent API endpoint, such as <code>walker_run</code> and <code>sentinel_register</code>.
As a matter of fact, the entire development journey in this tutorial can be done completely with a remote jaseci server instance.
You can go to <code>localhost:3000/docs</code> to check out all the available APIs.</p>
<h1 id="improve-your-ai-models-with-crowdsource"><a class="header" href="#improve-your-ai-models-with-crowdsource">Improve Your AI Models with Crowdsource</a></h1>
<p>Coming soon!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../support/codelabs/canonicai/chapter7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../examples/ner_examples/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../support/codelabs/canonicai/chapter7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../examples/ner_examples/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
