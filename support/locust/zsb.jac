version:'1.2.1'\r\n\r\nnode botset { has plan_type, current_bot_count, max_bot_count, current_transaction_count, max_transaction_count, last_reset_date, customer_id, subscription_id, onboarding_flag ;}\r\nnode bot { has anchor name, answer_count, description, created_time, last_updated_time, metadata; }\r\nnode log_chunk { has history, feedback, callback; }\r\nnode category { has anchor name, color; }\r\nnode integration { has anchor identifier, path, type, settingsobj; }\r\nnode testsuite { has anchor name , test_count, created_time, last_updated_time, last_result_summary, last_ran_time;  }\r\nnode testcase { has anchor question , expected_answerid, last_test_status, last_actual_answerid, last_ran_time;  }\r\nnode answer {\r\n    has anchor text, show_text, score, created_time, last_updated_time;\r\n    has private encoding; \r\n    has qlinks, hitcount;\r\n    has editor;\r\n    has categoryid;\r\n    has quick_reply, quick_reply_options;\r\n    has callback;\r\n}\r\nnode default_answer { has anchor text,show_text, thresh_score, hitcount; }\r\n\r\nwalker similar_questions {\r\n    has text, thresh;\r\n    can use.get_embedding, use.dist_score;\r\n    with entry{\r\n        if(not here.thresh): here.thresh=0.1;\r\n        }\r\n    \r\n    log_chunk {\r\n        enc=use.get_embedding(text);\r\n        for i in here.history:\r\n            if(use.dist_score(enc,i[1])<thresh): report i;\r\n    }\r\n}\r\n\r\n\/\/botset\r\n\r\nwalker get_botset {\r\n   \r\n    root { report --> node::botset; }\r\n}\r\n\r\nwalker change_botset {\r\n   \r\n    root { take --> node::botset; }\r\n    botset{\r\n    if (plan_type): here.plan_type=plan_type;\r\n    if (max_bot_count): here.max_bot_count=max_bot_count;\r\n    if (max_transaction_count):here.max_transaction_count=max_transaction_count;\r\n    if (not here.customer_id)\r\n    {\r\n        if(customer_id):here.customer_id=customer_id;\r\n    }\r\n    if(subscription_id):here.subscription_id=subscription_id;\r\n\r\n    }\r\n}\r\n\r\nwalker set_onboarding_flag {\r\n    has flag;\r\n    root { take --> node::botset; }\r\n    botset{\r\n        if(not here.onboarding_flag): here.onboarding_flag=[];\r\n        here.onboarding_flag = here.onboarding_flag + [flag];\r\n        report here.onboarding_flag;\r\n    }\r\n}\r\n\r\nwalker reset_onboarding_flag {\r\n    has flag;\r\n    root { take --> node::botset; }\r\n    botset\r\n        {\r\n        here.onboarding_flag = [];\r\n          if(flag){\r\n            for i in here.onboarding_flag\r\n            {\r\n                if(i!=flag)\r\n                {\r\n                    here.onboarding_flag = here.onboarding_flag + [i];\r\n                }\r\n            }\r\n        }\r\n    report here.onboarding_flag;\r\n    }\r\n}\r\n\r\nwalker reset_botset_count {\r\nroot { take --> node::botset; }\r\n botset{\r\n     here.current_transaction_count=0;\r\n }\r\n}\r\n\r\n\/\/ Bot\r\n\r\nwalker get_bots {\r\n    has count, bots,bot_count; \r\n    root { take --> node::botset; }\r\n    botset { \r\n        bot_count =0;\r\n\r\n        for i in --> node::bot{\r\n            bot_count+=1;\r\n            if not(i.answer_count)\r\n            {\r\n            count = spawn i walker :: get_answer_count();\r\n            i.answer_count = count;\r\n            }\r\n          \r\n           report i; \r\n        }\r\n        here.current_bot_count=bot_count;\r\n        disengage;\r\n        }\r\n}\r\n\r\n\r\n\r\nwalker add_bot {\r\n    has name,desc,created_time, default_answer;\r\n    default_answer=\"I do not have that information yet. Try another query ?\";\r\n    thresh_score=0.1;\r\n    metadata={\"greetings\":[],\"defaultAnswer\":default_answer,\"threshold\":thresh_score,\"others\":{\"language\":\"English (U.S)\"}};\r\n    root { \r\n        take --> node::botset; \r\n        }\r\n    botset {\r\n        here.current_bot_count+=1;\r\n        if (here.current_bot_count>here.max_bot_count)\r\n        {\r\n            here.current_bot_count-=1;\r\n            disengage;\r\n        }\r\n        created_time=std.time_now();\r\n        bot=spawn here --> node::bot(name=name,description=desc,metadata=metadata,created_time=created_time,last_updated_time=created_time );\r\n        spawn bot walker::create_default_answer(text=default_answer,thresh_score=thresh_score);\r\n        report bot;\r\n        disengage;\r\n    }\r\n   \r\n}\r\n\r\nwalker delete_bot {\r\n    has botset;\r\n    with entry\r\n    {\r\n        botset=<--node::botset[0];\r\n\r\n    }\r\n    bot, category, answer {\r\n        take --> ;\r\n        destroy here;\r\n    }\r\n    with exit{\r\n        botset.current_bot_count-=1;\r\n    }\r\n}\r\n\r\nwalker change_bot {\r\n    has name,desc,metadata,answer_count,thresh_score,no_response;\r\n    thresh_score=0.1;\r\n    default_answer=\"I do not have that information yet. Try another query ?\";\r\n\r\n    bot {\r\n        if (name):here.name=name;\r\n        if (desc):here.description=desc;\r\n        if (metadata)\r\n        {\r\n            if(metadata['defaultAnswer'])\r\n            {\r\n              spawn here walker::change_default_answer(text=metadata['defaultAnswer'],no_report=true);\r\n            }\r\n            else\r\n            {\r\n                if(metadata['threshold']):thresh_score=metadata['threshold'];\r\n                spawn here walker::create_default_answer(text=default_answer,thresh_score=thresh_score);\r\n                metadata['defaultAnswer']=default_answer;\r\n            }\r\n             if(metadata['threshold'])\r\n            {\r\n              spawn here walker::change_default_answer(thresh_score=metadata['threshold'],no_report=true);\r\n            }\r\n            here.metadata=metadata;\r\n\r\n        }\r\n        if (answer_count):here.answer_count=answer_count;\r\n        here.last_updated_time=std.time_now();\r\n        if (not no_response):report here;\r\n        disengage;\r\n    }\r\n}\r\n\r\n\/\/ Answer \r\n\r\nwalker get_answers {\r\n    bot {\r\n        report -->node::answer;\r\n        report -->node::default_answer;\r\n        disengage;\r\n    }\r\n   \r\n}\r\n\r\n walker get_answer_array {\r\n    has anchor answer_array;\r\n    with entry{\r\n        answer_array=[];\r\n    }\r\n    bot {\r\n        for i in -->node::answer\r\n        {\r\n            answer_array = answer_array + [i.text];\r\n        }\r\n    }\r\n }\r\n\r\n\r\nwalker get_answer_count {\r\n     has anchor count;\r\n     \r\n     with entry{\r\n         count = 0;\r\n     }\r\n    bot {\r\n        for i in -->node::answer{\r\n            count+=1;\r\n        }\r\n    }\r\n }\r\n\r\nwalker create_answer {\r\n    has text,show_text,qlinks, categoryid, created_time,answer_count;\r\n    has quick_reply, quick_reply_options, callback,editor;\r\n    can use.enc_answer;\r\n    with entry{\r\n        if (not show_text):show_text = text;\r\n        if (not qlinks):qlinks = [];\r\n        if (not quick_reply):quick_reply = \"false\";\r\n        if (not quick_reply_options):quick_reply_options = [];\r\n        if (not callback):callback = \"false\";\r\n        if (not editor):editor = \"rte\";\r\n        answer_count = spawn here walker::get_answer_count();\r\n    }\r\n    bot  {\r\n        created_time=std.time_now();\r\n        ans = spawn here --> node::answer(text=text,show_text=show_text,qlinks=qlinks,categoryid=categoryid,created_time=created_time,last_updated_time=created_time,quick_reply=quick_reply,quick_reply_options=quick_reply_options,callback=callback,editor=editor);\r\n        pretext=\"\";\r\n        for i in qlinks: pretext+=i;\r\n        ans.encoding = use.enc_answer(pretext+text);\r\n        answer_count+=1;\r\n        report ans;\r\n        disengage;\r\n    }\r\n    with exit{\r\n        spawn here walker:: change_bot(answer_count=answer_count,no_response='true');\r\n    }\r\n}\r\n\r\nwalker create_many_answers {\r\n    has textlist;\r\n\r\n    bot, category  {\r\n       for i in textlist: spawn here walker:: create_answer(text=i,show_text=i);\r\n    }\r\n}\r\n\r\nwalker delete_answer {\r\n\r\n    with entry{\r\n       thisbot=<--node::bot[0];\r\n        answer_count = spawn thisbot walker::get_answer_count();\r\n    }\r\n    answer {\r\n        destroy here;\r\n        answer_count=answer_count-1;\r\n    }\r\n    with exit{\r\n       spawn thisbot walker:: change_bot(answer_count=answer_count,no_response='true');\r\n    }\r\n}\r\n\r\nwalker change_answer {\r\n    has text,show_text,editor,categoryid, quick_reply, quick_reply_options, callback, qlinks, encoding;\r\n    can use.enc_answer;\r\n\r\n    answer {\r\n        if (text)\r\n            {\r\n                pretext=\"\";\r\n                here.text = text;\r\n                if(here.qlinks){for i in here.qlinks: pretext+=i;}\r\n                here.encoding = use.enc_answer(pretext+text);\r\n            }\r\n        if (show_text): here.show_text = show_text;\r\n        if (editor): here.editor = editor;\r\n        if (categoryid): here.categoryid = categoryid;\r\n        if (quick_reply): here.quick_reply = quick_reply;\r\n        if (callback): here.callback = callback;\r\n        if (quick_reply_options): here.quick_reply_options = quick_reply_options;\r\n        here.last_updated_time=std.time_now();\r\n        report here;\r\n        disengage;\r\n    }\r\n}\r\n\r\n\/\/ Default Answer \r\n\r\nwalker get_default_answer {\r\n    bot {\r\n        report -->node::default_answer;\r\n        disengage;\r\n    }\r\n   \r\n}\r\n\r\nwalker get_default_answerid {\r\n    has anchor default_answerid;\r\n    bot {\r\n        default_answerid =  --> node::default_answer[0];\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker create_default_answer {\r\n    has text, show_text, thresh_score;\r\n    \r\n    bot  {\r\n        if (not thresh_score):thresh_score=0.1;\r\n        take (--> node::default_answer) else {\r\n        default = spawn here --> node::default_answer(text=text,show_text=text,thresh_score=thresh_score);\r\n        }\r\n        disengage;\r\n    }\r\n}\r\n\r\n\r\nwalker change_default_answer {\r\n    has text,show_text,thresh_score,no_report;\r\n    bot{\r\n    take --> node::default_answer[0];\r\n    }\r\n    default_answer {\r\n        if (text)\r\n        {\r\n            here.text = text;\r\n            here.show_text = text;\r\n        }\r\n        if(thresh_score)\r\n        {\r\n            here.thresh_score=thresh_score;\r\n        }\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker delete_default_answer {\r\n\r\n    default_answer {\r\n        destroy here;\r\n    }\r\n}\r\n\r\n\r\n\/\/Category \r\nwalker create_category {\r\n    has name, color;\r\n    \r\n    bot  {\r\n        cat = spawn here --> node::category(name=name,color=color);\r\n        report cat;\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker get_categories {\r\n    bot {\r\n        report -->node::category;\r\n    }\r\n }\r\n\r\n walker get_category_array {\r\n     has anchor category_array;\r\n\r\n     with entry{\r\n         category_array=[];\r\n     }\r\n     \r\n    bot {\r\n        for i in -->node::category\r\n        {\r\n            category_array+=[{\"category\":i.name,\"id\":i}];\r\n        }\r\n    }\r\n }\r\n\r\n walker get_category_name {\r\n        has anchor category_obj;\r\n        \r\n        category{\r\n            category_obj={\"name\":here.name, \"color\":here.color};\r\n        }\r\n    }\r\n\r\n walker change_category {\r\n    has name, color;\r\n    category {\r\n        if (name):here.name=name;\r\n        if (color):here.color=color;\r\n        report here;\r\n        disengage;\r\n    }\r\n }\r\n\r\n\r\nwalker delete_category {\r\nhas thisbot, categoryid, deleteanswers;\r\n    with entry{\r\n       thisbot=<--node::bot[0];\r\n       categoryid=&here;\r\n    }\r\n    category {\r\n       destroy here;\r\n    }\r\n    with exit{\r\n        if (not deleteanswers):deleteanswers=\"\";\r\n       spawn thisbot walker:: reset_category(categoryid=categoryid,deleteanswers=deleteanswers);\r\n        \r\n    }\r\n}\r\n\r\n walker reset_category {\r\n    has categoryid,deleteanswers;\r\n    bot\r\n    {\r\n        for i in node::answer\r\n        {\r\n            if (i.categoryid==categoryid)\r\n            {\r\n                if (deleteanswers==\"Yes\")\r\n                {\r\n                 destroy i;\r\n                }\r\n                else\r\n                {\r\n                i.categoryid=\"\";\r\n                }\r\n                report i;\r\n            } \r\n        }\r\n    }\r\n }\r\n\r\n\r\n\/\/ Integration \r\n\r\nwalker create_integration {\r\n    has identifier, type, path, settings;\r\n    \r\n    bot  {\r\n        intg = spawn here --> node::integration(identifier=identifier,type=type, path=path, settingsobj=settingsobj);\r\n        report intg;\r\n        disengage;\r\n    }\r\n}\r\n\r\n walker get_integrations {\r\n    bot {\r\n        report -->node::integration;\r\n    }\r\n }\r\n\r\n\r\n walker change_integration {\r\n    has identifier, type, path, settingsobj;\r\n    integration {\r\n        if (identifier):here.identifier=identifier;\r\n        if (type):here.type=type;\r\n        if (path):here.path=path;\r\n        if (settingsobj): here.settingsobj=settingsobj;\r\n        report here;\r\n        disengage;\r\n    }\r\n }\r\n\r\n\r\n\r\n\r\n\/\/ Test Suite\r\n\r\nwalker create_testsuite {\r\n    has name, time;\r\n    \r\n    bot  {\r\n        time=std.time_now();\r\n        suite = spawn here --> node::testsuite(name=name,created_time=time,last_updated_time=time);\r\n        report suite;\r\n        disengage;\r\n    }\r\n}\r\n\r\n\r\nwalker change_testsuite {\r\n    has name;\r\n    \r\n    testsuite  {\r\n        if (name): here.name=name;\r\n        here.last_updated_time=std.time_now();\r\n        report here;\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker get_testsuites {\r\n    has count;\r\n    take -->node::testsuite;\r\n    testsuite {\r\n        count = spawn here walker :: get_testcase_count();\r\n            here.test_count = count;\r\n         report here;\r\n        }\r\n}\r\n\r\n walker delete_testsuite {\r\n    testsuite {\r\n        destroy here;\r\n    }\r\n}\r\n\r\nwalker run_testsuite {\r\nhas name;\r\nhas response; \r\nhas pass_count, fail_count,actual_answer,thisbot;\r\nhas questionarray;\r\n\r\nwith entry{\r\n    if (not response):response=true;\r\n    thisbot=<--node::bot[0];\r\n    questionarray=[];\r\n    actual_answer=\"\";\r\n    \/\/take -->node::testsuite;\r\n    pass_count=0;\r\n    fail_count=0;\r\n          }\r\n\r\n          testsuite{\r\n         \r\n                  for i in --> node::testcase\r\n                    {\r\n                     actual_answer =  spawn thisbot walker::ask_question_nolog_noreport(text=i.question);\r\n                       if (actual_answer == i.expected_answerid) \r\n                        {\r\n\r\n                            pass_count+=1;\r\n                            i.last_test_status= 1;\r\n                            \r\n                        } \r\n                        else{\r\n\r\n                            fail_count+=1;\r\n                            i.last_test_status = 0;\r\n                        }\r\n                    i.last_actual_answerid=actual_answer;\r\n                    i.last_ran_time = std.time_now();\r\n                    }\r\n            here.last_result_summary = {\"success\": pass_count, \"fail\": fail_count};\r\n            here.last_ran_time = std.time_now();\r\n            \r\n            if (response==true): report -->node::testcase;\r\n            disengage; \r\n          }\r\n       \r\n}\r\n\r\n\/\/ Test Case \r\n\r\nwalker create_testcase {\r\n    has question, answerid, time;\r\n    \r\n    testsuite  {\r\n        time=std.time_now();\r\n        suite = spawn here --> node::testcase(question=question, expected_answerid= answerid, created_time=time,last_updated_time=time);\r\n        report suite;\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker create_many_testcases {\r\n    has question_array, answerid, time;\r\n    has current_question_array;\r\n    has answer, default_answerid;\r\n\r\n     with entry\r\n    {\r\n        thisbot=<--node::bot[0];\r\n        current_question_array=[];\r\n    }\r\n    \r\n    testsuite  {\r\n        time=std.time_now();\r\n        current_question_array= spawn here walker :: get_testcase_array();\r\n\r\n        for i in question_array\r\n        {\r\n                if( not i in current_question_array)\r\n                {\r\n                    current_question_array= current_question_array + [i];\r\n                    if(answer==\"default\")\r\n                    {\r\n                        default_answerid = spawn thisbot walker :: get_default_answerid();\r\n                        test_case = spawn here --> node::testcase(question=i, expected_answerid= default_answerid, created_time=time,last_updated_time=time);\r\n                        report test_case;\r\n                    }\r\n                    else\r\n                    {\r\n                       answerid =  spawn thisbot walker::ask_question_nolog_noreport(text=i);\r\n                       test_case = spawn here --> node::testcase(question=i, expected_answerid= answerid, created_time=time,last_updated_time=time);\r\n                       report test_case;\r\n                    }\r\n                }\r\n            \r\n        }\r\n        \/\/ report here;\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker change_testcase {\r\n    has question, answerid;\r\n    \r\n    testcase  {\r\n        if (question): here.question=question;\r\n        if (answerid): here.expected_answerid=answerid;\r\n        here.last_updated_time=std.time_now();\r\n        report here;\r\n        disengage;\r\n    }\r\n}\r\n\r\nwalker get_testcases {\r\n    testsuite {\r\n        report -->node::testcase;\r\n    }\r\n }\r\n\r\n walker get_testcase_array {\r\n    has anchor testcase_array;\r\n    with entry{\r\n        testcase_array=[];\r\n    }\r\n    testsuite {\r\n        for i in -->node::testcase\r\n        {\r\n            testcase_array = testcase_array + [i.question];\r\n        }\r\n    }\r\n }\r\n\r\n walker get_testcase_count {\r\n     has anchor count;\r\n     \r\n     with entry{\r\n         count = 0;\r\n     }\r\n    testsuite {\r\n        for i in -->node::testcase{\r\n            count+=1;\r\n        }\r\n    }\r\n }\r\n\r\n walker delete_testcase {\r\n    testcase {\r\n        destroy here;\r\n    }\r\n}\r\n\r\nwalker run_all_tests {\r\nhas name;\r\nhas pass_count, fail_count,actual_answer,thisbot;\r\nhas questionarray;\r\nhas thissuite;\r\ntake -->node::testsuite; \r\ntestsuite{\r\n     spawn here walker :: run_testsuite(response='false');\r\n       report here;  \r\n    } \r\n       \r\n}\r\n\r\n\/\/ Import Export \r\n\r\nwalker import_answerbank {\r\n    has answerbank;\r\n    has category_array,categoryid;\r\n    has quick_reply,quick_reply_options,callback,editor;\r\n    with entry{\r\n\r\n        category_array= spawn here walker :: get_category_array();\r\n        quick_reply='false';\r\n        quick_reply_options = null;\r\n        callback = 'false';\r\n        editor = 'rte';\r\n        current_answer_array=[];\r\n\r\n    }\r\n\r\n    bot  {\r\n      \r\n       current_answer_array= spawn here walker :: get_answer_array();\r\n\r\n       for i in answerbank{\r\n\r\n           if( not i['text'] in current_answer_array)\r\n           {\r\n             categoryid=\"\";\r\n             if (i['category'])\r\n             {\r\n           for j in category_array{\r\n               if (i['category']==j['category'])\r\n               {\r\n                   categoryid=j['id'];\r\n               }\r\n              \r\n              }  \r\n\r\n               if (not categoryid)\r\n               {\r\n                categoryid = spawn here --> node::category(name=i['category'],color=i['category_color']);\r\n                category_array+=[{\"category\":i['category'],\"id\":categoryid}];\r\n               }\r\n             }\r\n             if(quick_reply in i):quick_reply=i['quick_reply'];\r\n             if(quick_reply_options in i):quick_reply_options=i['quick_reply_options'];\r\n             if(callback in i):callback=i['callback'];\r\n             if(editor in i):editor=i['editor'];\r\n\r\n           spawn here walker:: create_answer(text=i['text'],show_text=i['show_text'],qlinks=i['qlinks'],categoryid=categoryid,quick_reply=quick_reply,quick_reply_options=quick_reply_options,callback=callback,editor=editor);\r\n       } \r\n       }\r\n    }\r\n}\r\n\r\nwalker export_bot{\r\nhas name,desc,metadata;\r\nhas botobj,ansobj,quickreplyobj;\r\nhas category_obj;\r\n\r\nwith entry {\r\n    botobj = \"\";\r\n    name= here.name ;\r\n    desc= here.description ;\r\n    metadata = here.metadata;\r\n}\r\n\r\nbot  {\r\n    ansobj = [];\r\n    quickreplyobj= [];\r\n   for i in --> node::answer\r\n        {\r\n            categoryid=i.categoryid;\r\n            if(categoryid): category_obj= spawn categoryid walker:: get_category_name();\r\n            else: category_obj={\"name\":\"\", \"color\":\"\"};\r\n            ansobj += [{\"text\" : i.text,\r\n                        \"show_text\" : i.show_text,\r\n                        \"qlinks\" : i.qlinks, \r\n                        \"category\": category_obj['name'], \r\n                        \"category_color\": category_obj['color'],\r\n                        \"quick_reply\": i.quick_reply,\r\n                        \"quick_reply_options\": i.quick_reply_options,\r\n                        \"callback\": i.callback,\r\n                        \"editor\": i.editor\r\n                        }];\r\n           \r\n       } \r\n    }\r\n\r\nwith exit \r\n    {\r\n    botobj = {\"name\": here.name ,\"desc\": here.description ,\"metadata\": here.metadata,\"answerbank\": ansobj };\r\n    report botobj;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nwalker import_bot {\r\n    has name,desc,metadata,answerbank;\r\n    has thisbot;\r\n    has default_answer, thresh_score;\r\n    can use.enc_answer;\r\n\r\n    root {\r\n        take --> node::botset;\r\n    }\r\n\r\n    botset {\r\n        default_answer=\"I do not have that information yet. Try another query ?\";\r\n        thresh_score=0.1;\r\n        thisbot = spawn here --> node::bot(name=name,description=desc,metadata=metadata,created_time=std.time_now(),last_updated_time=std.time_now());\r\n        report thisbot;\r\n    }\r\n\r\n    with exit {\r\n            if(metadata)\r\n            {\r\n                if (metadata['defaultAnswer']):default_answer=metadata['defaultAnswer'];\r\n                if (metadata['threshold']):thresh_score=metadata['threshold'];\r\n            }\r\n            spawn thisbot walker:: create_default_answer(text=default_answer,thresh_score=thresh_score);\r\n            spawn thisbot walker:: import_answerbank(answerbank=answerbank);\r\n     \r\n    }\r\n}\r\n\r\n\/\/ Category Templates \r\n\r\nwalker get_category_templates{\r\n\r\n    has template_array; \r\n\r\n    with entry{\r\n        template_array = \r\n        [\r\n            {\r\n                \"template_category\": \"Greetings\",\r\n                \"template_category_color\": \"#333333\",\r\n                \"answers\": [\r\n                            {\r\n                                \"text\": \"You're welcome! Thanks for chatting with me today.\",\r\n                                \"show_text\": \"You're welcome! Thanks for chatting with me today.\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Thanks for chatting with me today. Goodbye!\",\r\n                                \"show_text\": \"Thanks for chatting with me today. Goodbye!\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"I am right where you left me.\",\r\n                                \"show_text\": \"<p>I am right where you left me.<\/p>\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"You're so polite!\",\r\n                                \"show_text\": \"You're so polite!\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Good evening!\",\r\n                                \"show_text\": \"<p>Good evening! How's your day been?<\/p>\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Good morning!\",\r\n                                \"show_text\": \"<p>Good morning! How are you today?<\/p>\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Good night. Sleep tight!\",\r\n                                \"show_text\": \"<p>Sleep tight!<\/p>\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Whats up ?  I am just here, waiting to help someone.\",\r\n                                \"show_text\": \"<p>I am just here, keen to share my knowledge<\/p>\",\r\n                                \"qlinks\": [\"hey what's up\"]\r\n                            }, {\r\n                                \"text\": \"I'm doing very well. Thanks!\",\r\n                                \"show_text\": \"I'm doing very well. Thanks!\",\r\n                                \"qlinks\": []\r\n                            }\r\n                        ]\r\n\t        },\r\n            {\r\n                \"template_category\": \"Emotions\",\r\n                \"template_category_color\": \"#599999\",\r\n                \"answers\": [\r\n                            {\r\n                                \"text\": \"Glad you think I'm funny.\",\r\n                                \"show_text\": \"Glad you think I'm funny.\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Wow indeed!\",\r\n                                \"show_text\": \"Wow indeed!\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"No big deal. I don't hold a grudge.\",\r\n                                \"show_text\": \"No big deal. I don't hold a grudge.\",\r\n                                \"qlinks\": []\r\n                            }, {\r\n                                \"text\": \"Hugs are the best!\",\r\n                                \"show_text\": \"Hugs are the best!\",\r\n                                \"qlinks\": []\r\n                            }\r\n                        ]\r\n            }\r\n    ];\r\n    \r\n    }\r\n\r\n    with exit\r\n    {\r\n        report template_array;\r\n    }\r\n}\r\n\r\n\r\nwalker import_category_template {\r\nhas category_object_array, category_object;\r\nhas category_array,categoryid,count;\r\n    \r\n    with entry\r\n    {\r\n        category_array= spawn here walker :: get_category_array();\r\n        count=0;\r\n    }\r\n    \r\n    bot  \r\n    {\r\n\r\n        for a in category_object_array\r\n        {\r\n            category_object=category_object_array[count];\r\n            category_name= category_object['template_category'];\r\n            category_color= category_object['template_category_color'];\r\n            count+=1;    \r\n            for i in category_object['answers']\r\n            {\r\n                    categoryid=\"\";\r\n                \r\n                        for j in category_array\r\n                        {\r\n                            if (category_name==j['category'])\r\n                            {\r\n                                categoryid=j['id'];\r\n                            }\r\n                            \r\n                        }  \r\n\r\n                        if (not categoryid)\r\n                        {\r\n                            categoryid = spawn here --> node::category(name=category_name,color=category_color); \r\n                            category_array+=[{\"category\":category_name,\"id\":categoryid}];\r\n                            \r\n                        }\r\n                spawn here walker:: create_answer(text=i['text'],show_text=i['show_text'],qlinks=i['qlinks'],categoryid=categoryid,quick_reply=i['quick_reply'],quick_reply_options=i['quick_reply_options'],callback=i['callback'],editor=i['editor']);\r\n            } \r\n        }\r\n    }\r\n}\r\n\r\n\/\/ Ask Question \r\n\r\nwalker ask_question {\r\n    has text, selected;\r\n    has max_score, thisbot, botset, dont_log, metadata, default, thresh_score;\r\n    can use.enc_question, use.qa_score;\r\n\r\n    with entry {\r\n        enc=use.enc_question(text);\r\n        selected = false;\r\n        max_score=0; \r\n        thresh_score=0;\r\n        thisbot=here;\r\n        botset=<--node::botset[0];\r\n    }\r\n    bot, default_answer {\r\n        for j in --> node::default_answer: default=j;\r\n        if (default): thresh_score=default.thresh_score;\r\n\r\n        for i in --> node::answer{\r\n            score=use.qa_score(enc, i.encoding);\r\n            if(score[0][0]>max_score){\r\n                selected = i;\r\n                max_score=score[0][0];\r\n            }\r\n        }\r\n         selected.score=max_score;\r\n\r\n        }\r\n        \r\n    with exit {\r\n        if (max_score>thresh_score){\r\n\r\n                if(not dont_log):\r\n                    spawn thisbot walker:: log_question(text=text, selected=selected, metadata=metadata);\r\n                if(selected.hitcount): selected.hitcount+=1;\r\n                else: selected.hitcount=1;\r\n                if ( metadata != {\"channel\":\"ZSB Platform\"})\r\n                {\r\n                botset.current_transaction_count+=1;\r\n                }\r\n                report selected;\r\n        }\r\n        else\r\n        {\r\n            if (default)\r\n            {    if(not dont_log):\r\n                    spawn thisbot walker:: log_question(text=text, selected=default, metadata=metadata);\r\n                if(default.hitcount): default.hitcount+=1;\r\n                else: default.hitcount=1;\r\n                report default;\r\n            }\r\n            else : report {\"context\":{\"text\":\"I do not have that information yet. Try another query ?\",\"show_text\":\"I do not have that information yet. Try another query ?\"}};\r\n            \r\n        }\r\n    }\r\n   \r\n}\r\n\r\nwalker pub_ask_question:anyone {\r\n    has text, selected;\r\n    has max_score, thisbot, botset, dont_log, metadata, default, thresh_score;\r\n    can use.enc_question, use.qa_score;\r\n\r\n    with entry {\r\n        enc=use.enc_question(text);\r\n        selected = false;\r\n        max_score=0; \r\n        thresh_score=0;\r\n        thisbot=here;\r\n        botset=<--node::botset[0];\r\n    }\r\n    bot, default_answer {\r\n        for j in --> node::default_answer: default=j;\r\n        if (default): thresh_score=default.thresh_score;\r\n\r\n        for i in --> node::answer{\r\n            score=use.qa_score(enc, i.encoding);\r\n            if(score[0][0]>max_score){\r\n                selected = i;\r\n                max_score=score[0][0];\r\n            }\r\n        }\r\n         selected.score=max_score;\r\n\r\n        }\r\n        \r\n    with exit {\r\n        if (max_score>thresh_score){\r\n\r\n                if(not dont_log):\r\n                    spawn thisbot walker:: log_question(text=text, selected=selected, metadata=metadata);\r\n                if(selected.hitcount): selected.hitcount+=1;\r\n                else: selected.hitcount=1;\r\n                if ( metadata != {\"channel\":\"ZSB Platform\"})\r\n                {\r\n                botset.current_transaction_count+=1;\r\n                }\r\n                report selected;\r\n        }\r\n        else\r\n        {\r\n            if (default)\r\n            {    if(not dont_log):\r\n                    spawn thisbot walker:: log_question(text=text, selected=default, metadata=metadata);\r\n                if(default.hitcount): default.hitcount+=1;\r\n                else: default.hitcount=1;\r\n                report default;\r\n            }\r\n            else : report {\"context\":{\"text\":\"I do not have that information yet. Try another query ?\",\"show_text\":\"I do not have that information yet. Try another query ?\"}};\r\n            \r\n        }\r\n    }\r\n   \r\n}\r\n\r\n\r\nwalker ask_question_nolog_noreport {\r\nhas text; \r\nhas anchor selected;\r\ncan use.enc_question, use.qa_score;\r\n\r\n    with entry {\r\n        enc=use.enc_question(text);\r\n        selected = false;\r\n        thresh_score=0;\r\n    }\r\n   bot, default_answer {\r\n        for j in --> node::default_answer: default=j;\r\n        if (default): thresh_score=default.thresh_score;\r\n\r\n        max_score = 0;\r\n        for i in --> node::answer{\r\n            score=use.qa_score(enc, i.encoding);\r\n            if(score[0][0]>max_score){\r\n                selected = i;\r\n                max_score=score[0][0];\r\n            }\r\n        }\r\n\r\n          if (max_score<thresh_score)\r\n        {\r\n            if (default)\r\n            {   \r\n                selected = default;\r\n            }\r\n            \r\n        }\r\n\r\n         \r\n        }\r\n    \r\n\r\n}\r\n\r\n\r\nwalker get_question_matches {\r\n    has text, num_matches, matches, thresh_score;\r\n    can use.enc_question, use.qa_score;\r\n\r\n    with entry {\r\n        matches=[];\r\n    thresh_score=0;\r\n    }\r\n\r\n    bot, default_answer {\r\n       for j in --> node::default_answer: default=j;\r\n       if (default): thresh_score=default.thresh_score; \r\n    \r\n        enc=use.enc_question(text);\r\n        for i in --> node::answer{\r\n            score=use.qa_score(enc, i.encoding);\r\n            matches += [[score[0][0], &i]];\r\n        }\r\n\r\n    }\r\n\r\n    with exit {\r\n        if(num_matches>matches.length):\r\n            num_matches=matches.length;\r\n        matches=std.sort_by_col(matches, 0, 'reverse');\r\n        if (matches[0][0]< thresh_score): report [thresh_score,&default];\r\n        for i=0 to i<num_matches by i+=1:\r\n            report matches[i];\r\n    }\r\n}\r\n\r\n\/\/Logging \r\n\r\nwalker log_question {\r\n    has text, selected, metadata;\r\n    bot {\r\n        take --> node::log_chunk else { \r\n                spawn here --> node::log_chunk;\r\n                take --> node::log_chunk;\r\n            }            \r\n    }\r\n\r\n    log_chunk {\r\n        if(not here.history): here.history=[];\r\n        here.history = [{\"datetime\":std.time_now(),\"log_type\":\"question\",\"question\":text, \"answerid\":&selected, \"answertext\":selected.text, \"answer_showtext\":selected.show_text, \"metadata\": metadata}] + here.history;\r\n        std.log({\"datetime\":std.time_now(),\"log_type\":\"question\",\"question\":text, \"answerid\":&selected, \"answertext\":selected.text, \"answer_showtext\":selected.show_text, \"metadata\": metadata});\r\n    }\r\n}\r\n\r\nwalker log_feedback {\r\n    has feedback, metadata;\r\n    bot {\r\n        take --> node::log_chunk else { \r\n                spawn here --> node::log_chunk;\r\n                take --> node::log_chunk;\r\n            }\r\n    }\r\n\r\n    log_chunk {\r\n        if(not here.feedback): here.feedback=[];\r\n        here.feedback = [{\"datetime\":std.time_now(),\"log_type\":\"feedback\",\"feedback\":feedback, \"metadata\": metadata}] + here.feedback;\r\n    }\r\n}\r\n\r\nwalker log_callback {\r\n    has customer_info, session_id;\r\n    bot {\r\n        take --> node::log_chunk else { \r\n                spawn here --> node::log_chunk;\r\n                take --> node::log_chunk;\r\n            }\r\n    }\r\n\r\n    log_chunk {\r\n        if(not here.callback): here.callback=[];\r\n        here.callback = [{\"datetime\":std.time_now(),\"log_type\":\"callback\",\"customer_info\":customer_info, \"session_id\": session_id}] + here.callback;\r\n    }\r\n}\r\n\r\n\r\nwalker get_log {\r\n    has target_answer;\r\n    bot {\r\n        take --> node::log_chunk;\r\n    }\r\n    log_chunk {\r\n        if(target_answer){\r\n            for i in here.history {\r\n                if(&i['answerid']==target_answer)\r\n                {\r\n                    report i;\r\n                }\r\n            }\r\n        }\r\n        else {report here.history;}\r\n    }\r\n}\r\n\r\nwalker drain_log {\r\n    bot {\r\n        take --> node::log_chunk;\r\n    }\r\n    log_chunk {\r\n        report here.history;\r\n        here.history=[];\r\n    }\r\n}\r\n\r\n\r\n\/\/ APi for date filter of log history\r\nwalker get_log_date_filter {\r\n    has start_date,end_date;\r\n    with entry\r\n    {\r\n        if not(start_date):start_date=std.time_now();\r\n        if not(end_date):end_date=start_date;\r\n    }\r\n    bot {\r\n        take --> node::log_chunk;\r\n    }\r\n    log_chunk {\r\n            if (not here.history): disengage;\r\n            for i in here.history {\r\n                if(&i['datetime']>=start_date && &i['datetime']<=end_date)\r\n                {\r\n                    std.out(i);\r\n                    report i;\r\n                }\r\n                else \r\n                {\r\n                    if (&i['datetime']< start_date) : disengage;\r\n                }\r\n            }\r\n           \r\n       \r\n    }\r\n}\r\n\r\n\r\n\r\nwalker get_feedback_date_filter {\r\n    has start_date,end_date;\r\n    with entry\r\n    {\r\n        if not(start_date):start_date=std.time_now();\r\n        if not(end_date):end_date=start_date;\r\n    }\r\n    bot {\r\n        take --> node::log_chunk;\r\n    }\r\n    log_chunk {\r\n            if (not here.feedback): disengage;\r\n            for i in here.feedback {\r\n                if(&i['datetime']>=start_date && &i['datetime']<=end_date)\r\n                {\r\n                    report i;\r\n               }\r\n                else \r\n                {\r\n                     if (&i['datetime']< start_date) \r\n                    {\r\n                    disengage;\r\n                    }\r\n                }\r\n            }\r\n           \r\n       \r\n    }\r\n}\r\n\r\nwalker get_callback_date_filter {\r\n    has start_date,end_date;\r\n    with entry\r\n    {\r\n        if not(start_date):start_date=std.time_now();\r\n        if not(end_date):end_date=start_date;\r\n    }\r\n    bot {\r\n        take --> node::log_chunk;\r\n    }\r\n    log_chunk {\r\n            if (not here.callback): disengage;\r\n            for i in here.callback {\r\n                if(&i['datetime']>=start_date && &i['datetime']<=end_date)\r\n                {\r\n                    report i;\r\n               }\r\n                else \r\n                {\r\n                    if (&i['datetime']< start_date) \r\n                    {\r\n                    disengage;\r\n                    }\r\n                }\r\n            }\r\n           \r\n       \r\n    }\r\n}\r\n\r\n \r\nwalker get_question_log {\r\n    has target_answer;\r\n    bot {\r\n        take --> node::log_chunk;\r\n    }\r\n    log_chunk {\r\n        if(target_answer){\r\n            for i in here.history {\r\n                if(&i['answerid']==target_answer)\r\n                {\r\n                    report [i['question'],i['datetime']];\r\n                }\r\n            }\r\n        }\r\n        else {report here.history;}\r\n    }\r\n}\r\n\r\n\/\/ Linking of a question to an answer\r\n\r\nwalker link_question {\r\n    has text, answerid;\r\n    has thisbot, actual_answer, actual_link_array;\r\n    can use.enc_answer, use.dist_score;\r\n    with entry{\r\n        thisbot=<--node::bot[0];\r\n    }\r\n\r\n    answer {\r\n        answerid =  &here;\r\n        actual_link_array = here.qlinks;\r\n        if(here.qlinks){if(not text in here.qlinks): here.qlinks += [text];}\r\n        else: here.qlinks = [text];\r\n        pretext=\"\";\r\n        if(here.qlinks){for i in here.qlinks: pretext+=i;}\r\n        old_enc = here.encoding;\r\n        here.encoding = use.enc_answer(pretext+text);\r\n        actual_answer =  spawn thisbot walker::ask_question_nolog_noreport(text=text);\r\n        if (&actual_answer != answerid ) \r\n        {\r\n         here.encoding = old_enc;\r\n         here.qlinks = actual_link_array;\r\n         report [[0]]; \r\n         disengage;\r\n        } \r\n        else: report use.dist_score(old_enc, here.encoding);\r\n    }\r\n}\r\n\r\nwalker unlink_question {\r\n    has idx;\r\n    can use.enc_answer, use.dist_score;\r\n\r\n    answer {\r\n            if(not here.qlinks or here.qlinks.length < idx): \r\n            report \"Index out of range!\";\r\n       else{\r\n            here.qlinks.destroy(idx);\r\n            pretext=\"\";\r\n            for i in here.qlinks: pretext+=i;\r\n            old_enc = here.encoding;\r\n            here.encoding = use.enc_answer(pretext+here.text);\r\n            report use.dist_score(old_enc, here.encoding);\r\n       }\r\n    }\r\n}\r\n\r\n\r\n\r\n\/\/ Init Jac file into Jaseci\r\n\r\nwalker init {\r\n    root {\r\n        take (--> node::botset)\r\n        else {\r\n            spawn here --> node::botset(plan_type= 'free' , current_bot_count=0, max_bot_count=10, current_transaction_count=0, max_transaction_count=10000, last_reset_date= std.time_now(), onboarding_flag=[] );\r\n            std.log(-->);\r\n            take --> node::botset;\r\n        }\r\n    }\r\n      botset{\r\n            if (not here.plan_type):here.plan_type='free';\r\n            if (not here.max_bot_count):here.max_bot_count=10;\r\n            if (not here.max_transaction_count):here.max_transaction_count=10000;\r\n            if (not here.current_transaction_count):here.current_transaction_count=0;\r\n            if (not here.last_reset_date):here.last_reset_date=std.time_now();\r\n            if (not here.onboarding_flag): here.onboarding_flag=[];\r\n        report here;\r\n        disengage;\r\n        }\r\n}\r\n\r\n\r\nnode data_nugget { has anchor name, data; }\r\nwalker create_nugget \r\n{ has name, data;\r\n \r\n     spawn here --> node::data_nugget(name=name, data=data); \r\n    \r\n     }\r\n\r\nwalker get_nugget {has name; report --> node::data_nugget == name;}\r\nwalker delete_nugget {has name; destroy --> node::data_nugget == name;}\r\nwalker update_nugget {has name, data; n= --> node::data_nugget == name; if(n): n.data=data;}