\chapter{A Coding Tour}
\minitoc


\section{Coding in Jac}

Jac, which is short hand for \textbf{Ja}seci \textbf{C}ode,  is a programming language designed for building programs for Jaseci. The language itself is inspired by a mixture of Javascript and Python and can be used standalone or as glue code for libraries built in other languages ecosystems. Jac is to Python, what Python is to C, what C is to assembly language for scalable sophisticated applications running in the cloud. In this section, we'll cover basics to advanced assuming no programming experience. Though we'll try to cover everything from first time coders to pros, we'll move fast through some of the rudimentary concepts so have your Google ready if you need to drill in a bit more of some of the basic programming concepts. Lets Jump in!

\subsection{Jac Basics}

Launch VSCode, spool up a terminal window, and lets tinker with an example. We'll start with Jac Code~\ref{jac:tldr_hello.jac}. I'd strongly recommend you type out this example (instead of cutting and pasting) especially if this might be your first time programming or are a little rusty with Python and or Javascript. It's the best way to learn!

\par
\jaccode{tldr_hello.jac}{Example program introducing basic syntax.}

This first example Jac Code~\ref{jac:tldr_hello.jac} shows a simple program example demonstrating a number of basic language features. Firstly, observe that the first three assignments in the program to \texttt{x}, \texttt{y}, and \texttt{z} does not specify any types indicating that Jac is a \gls{dynamically typed language}. This means the types are inferred from the assignment of variables, and these types can change dynamically as new assignments are applied to the same variables. This feature is designed to work almost exactly like the dynamic typing in Python.

\par
Next we find a conditional statement much like any other language. Do note operators like the Python inspired \lstinline{or} is supported along side the C/C++/Javascript \lstinline{||} operator. Other such operators include \lstinline{and} (\lstinline{\&\&}), \lstinline{not} (\lstinline{!}), etc.

\par
After the conditional we have a library call \lstinline{std.out(x)} on line 11. This call prints the value of x to the screen. \lstinline{std.out} in Jac is equivalent to the the \texttt{print} in Python and analogous to the \texttt{printf}, \texttt{cout}, and \texttt{console.log} you'd find in C, C++, and Javascript respectively. A suite of core standard library operations for the language has the preamble of \lstinline{std}.

Output:
\shellout{tldr_hello.jac.output}


\subsection{Types in Jac}
[Types example]
\jaccode{tldr_types.jac}{First Example}
Output:
\shellout{tldr_types.jac.output}

\subsection{Fun with Lists and Dictionaries}
[Fun with Lists and Dictionaries]
\jaccode{tldr_listdict.jac}{First Example}
Output:
\shellout{tldr_listdict.jac.output}

\subsection{Control Flow}
[Fun with Control Flow]
\jaccode{tldr_control.jac}{First Example}
Output:
\shellout{tldr_control.jac.output}

\subsection{Graphs in Jac}
[Bringing Graphs in with special operators]
\jaccode{tldr_graph.jac}{First Example}
\jacdotnw{tldr_graph}{.7}{Graph in memory for JC~\ref{jac:tldr_graph.jac}}
Output:
\shellout{tldr_graph.jac.output}

\subsection{Navigating Graphs with Walkers}
[Walking Graphs]
\jaccode{tldr_graphwalk.jac}{First Example}
\jacdotnw{tldr_graphwalk}{.7}{Graph in memory for JC~\ref{jac:tldr_graphwalk.jac}}
Output:
\shellout{tldr_graphwalk.jac.output}

\subsection{Compute in Nodes}
[Compute into the Nodes]
\jaccode{tldr_nodecompute.jac}{First Example}
\jacdotnw{tldr_nodecompute}{.4}{Graph in memory for JC~\ref{jac:tldr_nodecompute.jac}}
Output:
\shellout{tldr_nodecompute.jac.output}

\subsection{Static Graphs}
[Static graphs]
\jaccode{tldr_staticgraph.jac}{First Example}
\jacdotnw{tldr_staticgraph}{.97}{Graph in memory for JC~\ref{jac:tldr_staticgraph.jac}}

\subsection{Writing Tests}
[Tests]
\jaccode{tldr_test.jac}{First Example}
Output:
\shellout{tldr_test.jac.output}

\section{Jac Hacking Workflow}
In this section, we discuss a typical workflow and organization of a Jac coding project. To this end, we will be creating a simple toy chatbot project and examine it's file organization and development workflow. First, lets take a look at the files for this project.
\par
\shellout{tldr_wf_ls.shell}

Now lets take a look a what each of these files represent:

\begin{itemize}
    \item \texttt{cai.jac} - This is the main file for the project to which the various other elements (nodes, edges, graphs, etc) are imported from other files in the directory.
    \item \texttt{nodes.jac} - This file houses the node architypes created for this application. Functionality is specified in both the walkers and as node abilities.
    \item \texttt{edges.jac} - This file contains the edge architypes we've specified in the design of our conversational AI. These edges represent various types of transitions we can make throughout the converstation.
    \item \texttt{static\_conv.jac} - This file contains a static conversational graph that represents the posible conversational flows via state nodes and transition edges.
    \item \texttt{load\_faq.jac} - This file contains a static constructor for graph elements to correspond to frequently asked questions by loading them from a file.
    \item \texttt{faq\_answers.txt} - This file specifies a list of answers to frequently asked questions, we'll be using a model that only depends on the answers themselves.
    \item \texttt{tests.jac} - This file is where we house all the tests for our project.
\end{itemize}

\subsection{Using Imports}

\jaccode{tldr_wf_cai.jac}{Main CAI Jac App}

\jaccode{tldr_wf_nodes.jac}{Nodes for CAI}

\jaccode{tldr_wf_edges.jac}{edges for CAI}

\subsection{Leveraging Static Graphs for Quick Prototyping}
\jaccode{tldr_wf_static_conv.jac}{Static Conversational Graph}

\subsection{Test Driven Development}
\jaccode{tldr_wf_tests.jac}{Tests for CAI}

\subsection{File I/O}
\jaccode{tldr_wf_load_faq.jac}{FAQ Graph Loader}
\shellout{tldr_wf_faq_answers.txt}


\subsection{Building to JIR}

\section{AI with Jaseci Kit}



\subsection{Installing Jaseci Kit}
\par
\shellout{tldr_jskitinstall.shell}

\subsection{Loading Actions from Jaseci Kit}
\par
\shellout{tldr_defaultactions.shell}

\par
\shellout{tldr_loaduseqa.shell}

\par
\shellout{tldr_actionsloaded.shell}
\subsection{Using AI in Jac}
[Adding some AI]
\jaccode{tldr_ai.jac}{Universal Sentence Encoding QA in Jac}
Output:
\shellout{tldr_ai.jac.output}

\section{Launching a Jaseci Web Server}

\section{Deploying Jaseci at Scale}

\subsection{Quick-start with Kubectl}

\subsection{Managing Jac in Cloud}